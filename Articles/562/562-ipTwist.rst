Using an API with OpenAPI spec
===============================

An API with an OpenAPI 3.0 spec can be used to generate an AIMMS Library.
This AIMMS Library can subsequently be used to ease interfacing the corresponding service significantly.

This article illustrates interfacing a service with an OpenAPI 3.0 specification, and assumes the following architecture:

.. image:: images/client-server-openapi-lib.png
    :align: center

This article illustrates how to:

#.  initialize such an generated AIMMS library from an OpenAPI spec,

#.  make a request via such a library (arrow 1), and

#.  handle a response from such a library (arrow 4). 


The Story
----------

`ipTwist service <https://iptwist.com/>`_ provides a service for GeoLocating; translating an IP Address to a location on the globe. 

For instance, the IP Address ``111.111.111.111`` will return Latitude 35.68, Longitude 136.69; which is in Tokyo, Japan.

`API gurus <https://apis.guru/>`_ lists shared Open API specifications, including the one from `ipTwist OpenAPI spec <https://api.apis.guru/v2/specs/iptwist.com/1.0.0/openapi.json>`_ . 

Preparation
-----------

The library ``openapi_ipTwist``, with prefix ``ipTwist`` generated by the `DataExchange Library <https://documentation.aimms.com/dataexchange/openapi-client.html>`_ needs to be initialized as follows:

#.  To make the mappings of request and response files available, they need to be read in.
    Thus the procedure ``ipTwist::pr_readmappings`` with the following body is to be executed:
    
    .. code-block:: aimms 
        :linenos:

        DirectoryOfLibraryProject("openapi_ipTwist", sp_libFolder);
        dex::ReadMappings(
            startPath :  sp_libFolder, 
            subFolder :  "Generated/openapi-ipTwist", 
            recursive :  0);

    whereby we conveniently assume the mapping files were copied to the library.

#.  The library needs the URL of the server, and your API key.  
    `ipTwist setttings <https://iptwist.com/settings>`_ provides you with an API key.

    The following code initializes the corresponding library parameters:
    
    .. code-block:: aimms 
        :linenos:

        ipTwist::api::APIServer := "https://iptwist.com" ;
        ipTwist::api::APIKey(ipTwist::api::secscheme):= sp_ipTwist_apiKey ;
        ipTwist::api::RequestResponseFilePrefix := "./RequestResponseFileFolder/";
    
    Remarks:
    
    #.  Line 1: specify the URL of the server.  
        Some services are provides from multiple servers, thus 
        OpenAPI generated AIMMS libraries need to have the server identified.
        
    #.  Line 2: the API key for ipTwist needs to be specified before the first API call.
        When you don't specify your API key in the code, the ipTwist example will pop up a dialogue offering you to enter your API key.
    
    #.  Line 3: Intermediate request and response files, as generated by the ipTwist OpenAPI AIMMS Library, 
        should go to this folder. 
        This line is optional, but if you do not specify it, the AIMMS project folder is assumed.

Calling the API
---------------

Using the ``openapi_ipTwist`` library, making a request is just as follows:

.. code-block:: aimms 
    :linenos:
    :emphasize-lines: 5

    ! Starting current call.
    ipTwist::api::NewCallInstance(ep_openapi_ipTwist_CallInstance);

    ! Fill in the data for making the request.
    ipTwist::_Request::ip(ep_openapi_ipTwist_CallInstance) := sp_myIPAddress ;

    ! Clear RequestFile to ensure it will be generated by the library in the next call.
    ipTwist::api::post_::RequestFile(ipTwist::api::post_::reqpart) := "" ;

    ! Install hook, which will copy the data or handle the error
    ipTwist::api::post_::UserResponseHook :=
        'pr_GeolocateResponseHook' ;

    ! Start the request.
    ipTwist::api::post_::apiCall(ep_openapi_ipTwist_CallInstance);

Remarks:

#.  Line 2: Each request is an object.  
    The value of this mechanism will be illustrated in another how-to.

#.  Line 5: Here the data of the application is actually copied to the parameters of the ``openapi_ipTwist`` library.
    As you can see, it is an assignment in AIMMS syntax.  
    
    .. note:: The translation of this data to a format accepted by the server is handled by the generated ``openapi_ipTwist`` library, and therefore not specified in this procedure.

#.  Line 8: Every time a call is made, the request file parameter of the library is set. 
    As we want to avoid using the previous generated file, we clear the parameter here.

#.  Line 11: The library needs to know which procedure should handle the response (arrow 4).

#.  Line 15: Actually starting the request.

Handling the response
----------------------

Using the ``openapi_ipTwist`` library, handling the response is just as follows:

.. code-block:: aimms 
    :linenos:
    :emphasize-lines: 6-13

    switch ipTwist::api::CallStatusCode(ep_callInstance) do

        '200':
            ! Success, add user to core data structures.
            block ! Copy to data structures of scalar widget.
                sp_city         := ipTwist::_Response::city(        ep_callInstance);
                sp_country      := ipTwist::_Response::country(     ep_callInstance);
                sp_countryCode  := ipTwist::_Response::country_code(ep_callInstance);
                p_lat           := ipTwist::_Response::latitude(    ep_callInstance);
                p_lon           := ipTwist::_Response::longitude(   ep_callInstance);
                sp_state        := ipTwist::_Response::state(       ep_callInstance);
                sp_timezone     := ipTwist::_Response::timezone_(   ep_callInstance);
                sp_zip          := ipTwist::_Response::zip(         ep_callInstance);
            endblock ;
            block ! Copy to data structures of map widget.
                p_shownLocLatitude(  ep_ipLoc ) := p_lat ;
                p_shownLocLongitude( ep_ipLoc ) := p_lon ;
            endblock ;

        '400','401','402','403','404','405','406','407','408','409','410','411','412','413','414','415','416','417','421','422','423','424','425','426','427','428','429','431','451',
        '500','501','502','503','504','505','506','507','508','510','511':
            raise error formatString("ipTwist::Geolocate(%s) failed (status: %e, error: %e): %s",
                sp_myIPAddress,
                openapi_ipTwist::api::CallStatusCode(ep_callInstance), 
                openapi_ipTwist::api::CallErrorCode(ep_callInstance), 
                fnc_errorFunc( ipTwist::api::CallStatusCode(ep_callInstance) ) );

        default:
            raise error formatString("ipTwist::Geolocate(%s) failed (status: %e, error: %e): %s",
                sp_myIPAddress,
                openapi_ipTwist::api::CallStatusCode(ep_callInstance), 
                openapi_ipTwist::api::CallErrorCode(ep_callInstance), 
                "unknown reason" );

    endswitch ;

Remarks:

#.  Lines 6-13: here we copy the data from the ``openapi_ipTwist`` library into the data structures of the application.

#.  Lines 22-26, and 29-33: try to be nice to the end-user by sharing information about a failure. 
    By making this best practice, a common practice, you will 

#.  Line 26: The service from ipTwist does not provide a schema for error messages.
    Instead, its OpenAPI spec documents how to handle status codes in case of failure.
    This is why a separate function is built to translate documented status code to explanations.

.. spelling::
   ipTwist