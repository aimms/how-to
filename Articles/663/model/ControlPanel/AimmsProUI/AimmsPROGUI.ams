## ams_version=1.0

LibraryModule AimmsProGUI {
    Prefix: guipro;
    Interface: data { OpenRequestManagement, 'progress::UpdateCallBack', EditAuthorization } + Authentication_Data;
    Property: NoSave;
    Procedure OpenRequestManagement {
        Body: {
            if SessionHasVisibleGUI then
                    LocalizationInitialize;
                    if (not session::DateToList) then
                            session::DateToList := CurrentToStringDelta(-24*60*60);        ! Requests for the last 24h
                    endif;
                    PageOpen("Managed Requests");
            endif;
            return 1;
        }
        Parameter ret;
    }
    Section Private_Tools {
        Quantity TimeDuration {
            BaseUnit: s;
            Comment: "Expresses the value for the duration of periods.";
        }
        Function CurrentToStringDelta {
            Arguments: (deltaSeconds);
            Range: string;
            Body: {
                tmpSec := CurrentToMoment([s], "2011-01-01 00:00:00") ;
                tmpSec += (deltaSeconds) [s];
                CurrentToStringDelta := MomentToString( "%c%y-%m-%d %H:%M:%S", [s], "2011-01-01 00:00:00", tmpSec );
            }
            Parameter deltaSeconds {
                Property: Input;
            }
            Parameter tmpHour {
                Range: integer;
            }
            Parameter tmpMin {
                Range: integer;
            }
            Parameter tmpSec {
                Range: integer;
                Unit: s;
            }
        }
        Procedure SaveAndOpenVersionInTemp {
            Arguments: (versionID);
            Body: {
                ret := pro::LoadLogMessages( versionID, guipro::session::sessionLogFile );
                if not (ret) then return 0; endif;
                
                PageOpen("Log File Viewer");
                
                return 1;
            }
            StringParameter versionID {
                Property: Input;
            }
            StringParameter getFileName {
                InitialData: "";
            }
            Parameter ret;
            StringParameter logFolder;
        }
    }
    Section Localization {
        Set AllLanguages {
            Index: language;
            Parameter: CurrentLanguage;
            Property: NoSave;
            OrderBy: User;
            Definition: Data { English };
            Comment: {
                "This set should contain all languages for which you want to
                localize your AIMMS end-user application. You can add new
                languages at any time. However, you should always make sure
                that your development language remains the first language
                in the set. AIMMS will use this language to create new
                localization entries during the automated localization
                procedure as well as in the localization wizards."
            }
        }
        Set LocalizedTextIndexSet {
            SubsetOf: Integers;
            Index: lti;
            Property: NoSave;
            Definition: Data { 1 .. 67 };
            Comment: {
                "This set is used to number all localized strings in your
                end-user interface. The localization wizards automatically
                update the definition of this set whenever new localization
                strings are added. Therefore, you should not edit the
                definition of this set by hand, unless you are sure
                what you are doing."
            }
        }
        StringParameter LocalizedText {
            IndexDomain: (lti,language);
            Property: NoSave;
            Comment: {
                "This string parameter contains the actual localized strings
                that are visible in the end-user interface. You can edit its
                contents in the `Localized Text` window, which is accessible
                through the `Tools-Localization` menu. The `Localized Text`
                window is also opened when you invoke the `Data ...` menu
                for any of the localization identifiers."
            }
        }
        StringParameter LocalizedTextDescription {
            IndexDomain: (lti);
            Property: NoSave;
            Comment: {
                "This string parameter contains an (optional) description for
                each localization string. You can edit its contents in the
                `Localized Text` window, which is accessible through the
                `Tools-Localization` menu. The `Localized Text` window is
                also opened when you invoke the `Data ...` menu for any of
                the localization identifiers."
            }
        }
        Procedure LocalizationReadLanguage {
            Arguments: ThisLanguage;
            Body: {
                LanguageFileName := FormatString("<lib:guipro>:Localization\\%e.txt", ThisLanguage );
                
                if FileExists( LanguageFileName ) then
                    Read From File LanguageFileName;
                endif;
            }
            Comment: "This procedure reads the localization data for a single language.";
            ElementParameter ThisLanguage {
                Range: AllLanguages;
                Property: Input;
            }
            StringParameter LanguageFileName;
        }
        Procedure LocalizationWriteLanguage {
            Arguments: ThisLanguage;
            Body: {
                if ( ProjectDeveloperMode and
                     Count( lti | LocalizedText(lti,ThisLanguage) ) ) then
                
                    LanguageFileName := FormatString("<lib:guipro>:Localization\\%e.txt", ThisLanguage );
                    put f;
                    display LocalizedText(lti,ThisLanguage);
                    putclose;
                
                endif;
            }
            Comment: {
                "This procedure writes the localization data for a single language.
                AIMMS will only write data, if data for the language is actually
                present. This will prevent loss of localization data which is
                written without being read before."
            }
            ElementParameter ThisLanguage {
                Range: AllLanguages;
                Property: Input;
            }
            StringParameter LanguageFileName;
            File f {
                Name: LanguageFileName;
                Device: Disk;
                Mode: replace;
            }
        }
        Procedure LocalizationReadAll {
            Body: {
                for ( language ) do
                    LocalizationReadLanguage( language );
                endfor;
                
                if ( ProjectDeveloperMode and
                     FileExists("<lib:guipro>:Localization\\Descriptions.txt") ) then
                    read from file "<lib:guipro>:Localization\\Descriptions.txt";
                endif;
            }
            Comment: {
                "Execute this procedure if you intend to edit the localization
                parameters by hand (i.e. without using the localization wizards).
                In that case, do not forget to call LocalizationWriteAll before
                the end of your AIMMS session."
            }
        }
        Procedure LocalizationWriteAll {
            Body: {
                for ( language ) do
                    LocalizationWriteLanguage( language );
                endfor;
                
                if ( ProjectDeveloperMode and
                     Count( lti | LocalizedTextDescription(lti) ) ) then
                
                    write LocalizedTextDescription to file "<lib:guipro>:Localization\\Descriptions.txt";
                
                endif;
            }
            Comment: {
                "You should execute this procedure if you have edited the
                localization parameters by hand. Before editing, you can
                call LocalizationReadAll to obtain all currently present
                localization data."
            }
        }
        Procedure LocalizationInitialize {
            Body: {
                if not CurrentLanguage then
                    CurrentLanguage := first(AllLanguages);
                endif;
                
                LocalizationReadLanguage(CurrentLanguage);
            }
            Comment: {
                "This procedure initializes localization support for your application.
                It is automatically added to the end of MainInitialization during the
                localization setup. If the element parameter CurrentLanguage already
                has been assigned a value at that time, AIMMS will read the localization
                strings for that language. In all other cases, the localization data
                for the development language is read."
            }
        }
    }
    Module Progress_Window {
        Prefix: progress;
        ElementParameter WatchedSession {
            Range: session::SessionList;
            Property: NoSave;
            InitialData: '';
        }
        Parameter UpdateDelay {
            Range: integer;
            Property: NoSave;
            InitialData: 5000;
        }
        ElementParameter UpdateSession {
            Range: session::SessionList;
            Property: NoSave;
        }
        Parameter UpdateRequested {
            Range: binary;
            Property: NoSave;
            InitialData: 0;
        }
        Set TimeSlots {
            Index: tm;
            Parameter: TimeElement;
            Property: NoSave;
            OrderBy: tm;
        }
        Set Items {
            Index: item;
            Parameter: ItemElement;
            Property: NoSave;
            OrderBy: ItemOrder(item);
        }
        Parameter ItemOrder {
            IndexDomain: item;
            Range: integer;
            Default: 0;
            Property: NoSave;
            InitialData: 0;
        }
        StringParameter Value {
            IndexDomain: (tm,item);
            Property: NoSave;
        }
        StringParameter WorkerValue {
            IndexDomain: (item);
            Property: NoSave;
            Definition: Value('worker',item);
        }
        Parameter GAP {
            IndexDomain: (tm);
            Property: NoSave;
        }
        StringParameter BeginTime {
            Property: NoSave;
        }
        StringParameter EndTime {
            Property: NoSave;
        }
        Parameter WatchedSessionNotRunning {
            Range: binary;
            Property: NoSave;
            Definition: if (WatchedSession and pro::session::ActiveSessionRunning) then 0 else 1 endif;
        }
        Parameter PausedSessionNotRunning {
            Range: binary;
            Property: NoSave;
            Definition: if ((WatchedSession or PausedSession) and pro::session::ActiveSessionRunning) then 0 else 1 endif;
        }
        Procedure UpdateCallBack {
            Body: {
                ! If requested, collect and send data
                if UpdateRequested then
                        empty Items, Value;
                        TimeSlots := {'worker'};
                
                        ! Session basic data
                        SetElementAdd(Items,ItemElement,"Username");
                        Value('worker',ItemElement) := pro::GetPROUserName + "@" + pro::GetPROEnvironment;
                
                        ! Mathematical program data
                        if (CurrentGeneratedMathematicalProgram <> '') then
                                MpType := GMP::Instance::GetMathematicalProgrammingType(CurrentGeneratedMathematicalProgram);
                
                                SetElementAdd(Items,ItemElement,"# Constraints");
                                Value('worker',ItemElement) := FormatString("%i",GMP::Instance::GetNumberOfRows(CurrentGeneratedMathematicalProgram));
                
                                SetElementAdd(Items,ItemElement,"# Variables");
                                if (MpType='MIP' or MpType='MIQP' or MpType='MIQCP' or MpType='COP' or MpType='CSP') then
                                	Value('worker',ItemElement) := FormatString("%i\t(%i integer)",GMP::Instance::GetNumberOfColumns(CurrentGeneratedMathematicalProgram),
                                	                                                     GMP::Instance::GetNumberOfIntegerColumns(CurrentGeneratedMathematicalProgram));
                                else
                                	Value('worker',ItemElement) := FormatString("%i",GMP::Instance::GetNumberOfColumns(CurrentGeneratedMathematicalProgram));
                                endif;
                
                                SetElementAdd(Items,ItemElement,"# Nonzeros");
                                Value('worker',ItemElement) := FormatString("%i",GMP::Instance::GetNumberOfNonzeros(CurrentGeneratedMathematicalProgram));
                
                                SetElementAdd(Items,ItemElement,"Solver");
                                Value('worker',ItemElement) := GMP::Instance::GetSolver(CurrentGeneratedMathematicalProgram);
                
                                if (MpType='LP' or MpType='NLP' or MpType='QP' or MpType='QCP' or MpType='COP' or MpType='CSP') then
                                        SetElementAdd(Items,ItemElement,"Objective");
                                        Value('worker',ItemElement) := GMP::Solution::GetObjective(CurrentGeneratedMathematicalProgram,1);
                
                                elseif (MpType='MIP' or MpType='MIQP' or MpType='MIQCP') then
                                		BestBnd := GMP::Solution::GetLinearObjective(CurrentGeneratedMathematicalProgram,1);
                                		if ( Abs( BestBnd ) >= 1e50 ) then
                                			BestBnd := na;
                                		endif;
                
                                        SetElementAdd(Items,ItemElement,"Best Bound");
                                        Value('worker',ItemElement) := FormatString("%<4.2f",BestBnd);
                
                                        SetElementAdd(Items,ItemElement,"Incumbent");
                                        Value('worker',ItemElement) := FormatString("%<4.2f",GMP::Solution::GetObjective(CurrentGeneratedMathematicalProgram,1));
                
                                        SetElementAdd(Items,ItemElement,"Gap");
                                        Value('worker',ItemElement) := FormatString("%<3.1f",100*Abs((GMP::Solution::GetObjective(CurrentGeneratedMathematicalProgram,1) - BestBnd)
                                                                /$
                                                                GMP::Solution::GetObjective(CurrentGeneratedMathematicalProgram,1)));
                
                                        SetElementAdd(Items,ItemElement,"Nodes");
                                        Value('worker',ItemElement) := FormatString("%i",GMP::Solution::GetNodesUsed(CurrentGeneratedMathematicalProgram,1));
                                endif;
                
                                SetElementAdd(Items,ItemElement,"Memory");
                                Value('worker',ItemElement) := FormatString("%3.2f Mb",GMP::Solution::GetMemoryUsed(CurrentGeneratedMathematicalProgram,1));
                
                                SetElementAdd(Items,ItemElement,"Program Status");
                                Value('worker',ItemElement) := GMP::Solution::GetProgramStatus(CurrentGeneratedMathematicalProgram,1);
                
                				if ( MpType='COP' or MpType='CSP') then
                					CurrentMathematicalProgram := GMP::Instance::GetSymbolicMathematicalProgram(CurrentGeneratedMathematicalProgram);
                
                					SetElementAdd(Items,ItemElement,"Branches");
                                	if pro::management::GetScalarSuffixValue(CurrentMathematicalProgram,"NumberOfBranches",tmpStr) then Value('worker',ItemElement) := FormatString("%i",Val(tmpStr)); endif;
                
                                	SetElementAdd(Items,ItemElement,"Failures");
                                	if pro::management::GetScalarSuffixValue(CurrentMathematicalProgram,"NumberOfFails",tmpStr) then Value('worker',ItemElement) := FormatString("%i",Val(tmpStr)); endif;
                				else
                                	SetElementAdd(Items,ItemElement,"Iterations");
                                	Value('worker',ItemElement) := FormatString("%i",GMP::Solution::GetIterationsUsed(CurrentGeneratedMathematicalProgram,1));
                                endif;
                
                                SetElementAdd(Items,ItemElement,"Solution Time");
                                Value('worker',ItemElement) := FormatString("%4.2f",GMP::Solution::GetCPUSecondsUsed(CurrentGeneratedMathematicalProgram,1)/100);
                        endif;
                
                        UpdateRequested := 0;
                        progress::UpdateWindowAction(UpdateSession,CurrentToString("%H:%M:%S"),Items,WorkerValue);
                endif;
                
                ! When this callback gets executed through GMP, the return value 1 indicates that the solve should continue.
                ! Without it, the solve will aborted. When solving via the SOLVE statement, aborting the solve is arranged via
                ! .CallbackReturnStatus suffix of the math program.
                return 1;
            }
            Comment: "Collect execution information and send to be shown in Progress Window client-side";
            ElementParameter MpType {
                Range: AllMathematicalProgrammingTypes;
            }
            ElementParameter CurrentMathematicalProgram {
                Range: AllMathematicalPrograms;
            }
            StringParameter tmpStr;
            Parameter BestBnd;
        }
        Procedure Activate {
            Arguments: (sessionElement);
            Body: {
                if sessionElement = '' then
                        ! Deactivate updates
                        WatchedSession := '';
                        pro::session::SetActiveSession(WatchedSession);
                
                elseif sessionElement <> WatchedSession then
                        empty TimeSlots, Items, Value;
                
                        if WatchedSession = '' then
                                ! Activate updates
                                WatchedSession := sessionElement;
                                pro::session::SetActiveSession(WatchedSession);
                
                                NextCheck := CurrentToString("%c%y-%m-%d %H:%M:%S");
                                Items := {'Connecting to session...'};
                                progress::RepeatUpdate;
                        else
                                ! Redefines session to be updated
                                WatchedSession := sessionElement;
                                pro::session::SetActiveSession(WatchedSession);
                        endif;
                
                        PageOpen("Progress Window");
                else
                        ! Deactivate updates
                        WatchedSession := '';
                        pro::session::SetActiveSession(WatchedSession);
                endif;
                return 1;
            }
            ElementParameter sessionElement {
                Range: session::SessionList;
                Property: Input;
            }
        }
        Procedure RepeatUpdate {
            Body: {
                if WatchedSessionNotRunning then return 0;
                
                ! Run update and schedule nex check
                elseif progress::UpdateWindow(WatchedSession) then
                        if pro::GetPROLastErrorMessage = "" then
                                NextCheck := CurrentToStringDelta(UpdateDelay/1000);
                                if not ScheduleAt(NextCheck, 'guipro::progress::RepeatUpdate') then
                                        raise error "Error scheduling updateprogress procedure: " + CurrentErrorMessage code 'PRO-Error-scheduling-progress-procedure' ;
                                endif;
                        else
                                WatchedSession := '';
                                pro::session::SetActiveSession(WatchedSession);
                        endif;
                endif;
                return 1;
            }
        }
        Procedure UpdateWindow {
            Arguments: (sessionToUpdate,UpdateDelay);
            Body: {
                ! Basic validation
                if sessionToUpdate = '' then
                        raise error "Invalid request reference" code 'PRO-Invalid-request-reference-update-progress' ;
                        return 0;
                elseif UpdateDelay < 1000 then
                        raise error "The update frequency must be greater than 1 second" code 'PRO-invalid-update-frequency' ;
                        return 0;
                endif;
                
                ! If the PRO library has not been finalized do not call the server.
                if (not pro::management::IsInitialized()) then return 0; endif;
                
                ! Delegate the remainder of the execution to the server side
                return UpdateWindowServer(sessionToUpdate, UpdateDelay);
            }
            Comment: "Collect execution information and send to be shown in Progress Window client-side";
            ElementParameter sessionToUpdate {
                Range: session::SessionList;
                Property: Input;
            }
            Parameter UpdateDelay {
                Range: integer;
                Default: 5000;
                Property: Optional;
            }
        }
        Procedure UpdateWindowServer {
            Arguments: (sessionToUpdate,UpdateDelay);
            Body: {
                ! Execution at the server side
                if pro::DelegateToServer(
                        RequestQueue : session::WorkerQueue(sessionToUpdate),
                        flags : pro::PROMFLAG_PRIORITY + pro::PROMFLAG_LIVE
                ) then return 1; endif;
                
                ! Request data to be collect during next callback
                UpdateSession   := sessionToUpdate;
                UpdateRequested := 1;
                return 1;
            }
            Comment: "Collect execution information and send to be shown in Progress Window client-side";
            ElementParameter sessionToUpdate {
                Range: session::SessionList;
                Property: Input;
            }
            Parameter UpdateDelay {
                Range: integer;
                Default: 5000;
                Property: Optional;
            }
        }
        Procedure UpdateWindowAction {
            Arguments: (sessionToUpdate,argTime,argItems,argValue);
            Body: {
                ! Execution at the client side
                if pro::DelegateToClient(
                        ProcedureName : 'guipro::progress::UpdateWindowAction',
                        flags : pro::PROMFLAG_LIVE
                ) then return 1; endif;
                
                ! Only update the progress window if the update message coming in is actually for the session
                ! we're watching. This situation may occur if the same user has multiple PRO clients opened
                ! simultaneously.
                if (sessionToUpdate <> WatchedSession) then
                        return;
                endif;
                
                if StringToElement(Items,"connecting to session...") then
                        Items -= 'connecting to session...';
                endif;
                
                ! Add the new values and update current PW_Time_Element
                TimeElement := StringToElement(TimeSlots,argTime,1);
                
                SetElementAdd(Items,ItemElement,"LastUpdate");
                Value(TimeElement,ItemElement) := argTime;
                SetElementAdd(Items,ItemElement,"Request");
                Value(TimeElement,ItemElement) := session::RequestDescription(guipro::session::selectedSession);
                
                for argItem do
                        SetElementAdd(Items,ItemElement,argItem);
                        Value(TimeElement,ItemElement) := argValue(argItem);
                endfor;
                
                ! GAP or objective value for graphics
                if StringToElement(argItems,"Gap") <> '' then
                        GAP(TimeElement) := Val(Value(TimeElement,'Gap'));
                        ChartLabel := LocalizedText( '51', CurrentLanguage ); ! "GAP Evolution:"
                else
                        GAP(TimeElement) := Val(Value(TimeElement,'Objective'));
                        ChartLabel := LocalizedText( '52', CurrentLanguage ); ! "Objective:"
                endif;
                
                ! Limit number of points
                While Card(TimeSlots) > 100 do TimeSlots -= First(TimeSlots); endwhile;
                
                ! GUI: Correct ordenation
                UpdateProgressWindowOrdenation;
                PageRefreshAll;
                
                return 1;
            }
            Comment: "Receives a vector of elements to be displayed in Progress Window";
            ElementParameter sessionToUpdate {
                Range: session::SessionList;
                Property: Input;
            }
            StringParameter argTime {
                Property: Input;
            }
            Set argItems {
                Index: argItem;
                Property: Input;
            }
            StringParameter argValue {
                IndexDomain: argItem;
                Property: Input;
            }
        }
        Section Progress_Windows_GUI {
            StringParameter NextCheck {
                Default: "";
                Property: NoSave;
            }
            ElementParameter PausedSession {
                Range: session::SessionList;
                Property: NoSave;
                InitialData: '';
            }
            StringParameter Label {
                Property: NoSave;
                Definition: {
                    if WatchedSession = "" or session::selectedSession <> WatchedSession then
                            LocalizedText( '47', CurrentLanguage ) !"Progress Window"
                    else
                            LocalizedText( '48', CurrentLanguage ) !"Stop Progress Window"
                    endif
                }
            }
            StringParameter ChartLabel {
                Property: NoSave;
            }
            StringParameter PauseResumeLabel {
                Property: NoSave;
                Definition: {
                    if WatchedSession = "" then
                            LocalizedText( '49', CurrentLanguage ) !"Resume Updates"
                    else
                            LocalizedText( '50', CurrentLanguage ) !"Pause Updates"
                    endif
                }
            }
            ElementParameter PauseResumeColor {
                Range: AllColors;
                Property: NoSave;
                Definition: {
                    if WatchedSession = "" then
                            'light grey'
                    else
                            'white'
                    endif
                }
            }
            ElementParameter LineColor {
                IndexDomain: item;
                Range: AllColors;
                Property: NoSave;
                Definition: {
                    if ItemOrder(item) > 0 and Mod(ItemOrder(item),100) = 0 then 'blue'
                    else 'black' endif
                }
            }
            Set Frequency {
                Index: freq;
                Parameter: FreqElement;
                Property: NoSave;
                Definition: data { '5 seconds', '15 seconds', '1 minute', '5 minutes' };
            }
            Parameter FreqValue {
                IndexDomain: (freq);
                Range: integer;
                Property: NoSave;
                Definition: data { '5 seconds' : 5000,  '15 seconds' : 15000,  '1 minute' : 60000,  '5 minutes' : 300000 };
            }
            Parameter ShowDetails {
                Range: binary;
                Property: NoSave;
                InitialData: 0;
            }
            Parameter Resume {
                IndexDomain: item;
                Range: binary;
                Property: NoSave;
                Definition: {
                    if      item = "PRO SESSION" or
                            item = "Request" or
                            item = "LastUpdate" or
                            item = "SOLVER SESSION" or
                            item = "Best Bound" or
                            item = "Incumbent" or
                            item = "Gap" or
                            item = "Solver" or
                            item = "Solution Time" or
                            item = "Connecting to session..." then 1
                    else 0
                    endif
                }
            }
            Set GUIItems {
                SubsetOf: Items;
                Index: guiItem;
                Property: NoSave;
                OrderBy: ItemOrder(guiItem);
                Definition: {
                    if ShowDetails then
                            {item}
                    else
                            {item | Resume(item)}
                    endif
                }
            }
            Parameter NoTerminationConfirmation {
                Property: NoSave;
                InitialData: 1;
            }
            Procedure UpdateProgressWindow {
                Body: {
                    ! Default update frequency
                    if FreqElement = '' then
                            FreqElement := '5 seconds';
                    endif;
                    
                    ! Clear data from old updates
                    empty TimeSlots, Items, ItemOrder;
                    cleandependents TimeSlots, Items;
                    
                    return Activate(guipro::session::selectedSession);
                }
            }
            Procedure UpdateProgressWindowFreq {
                Body: {
                    ! Default update frequency
                    if FreqElement = '' then
                            FreqElement := '5 seconds';
                    endif;
                    UpdateDelay := FreqValue(FreqElement);
                    
                    return 1;
                }
            }
            Procedure UpdateProgressWindowPause {
                Body: {
                    PausedSession := WatchedSession;
                    WatchedSession := '';
                }
            }
            Procedure UpdateProgressWindowPauseResume {
                Body: {
                    if WatchedSessionNotRunning then
                            WatchedSession := PausedSession;
                            RepeatUpdate;
                    else
                            PausedSession := WatchedSession;
                            WatchedSession := '';
                    endif;
                }
            }
            Procedure UpdateProgressWindowOrdenation {
                Body: {
                    SetElementAdd(Items,ItemElement,"PRO SESSION");
                    SetElementAdd(Items,ItemElement,"SOLVER SESSION");
                    
                    ! Line ordenation
                    if Exists(item | ItemOrder(item)=0) then for item do
                            ! PRO Session
                            if item='PRO SESSION' then ItemOrder(item):=100;
                            elseif item='Request' then ItemOrder(item):=101;
                            elseif item='ServerURL' then ItemOrder(item):=102;
                            elseif item='Username' then ItemOrder(item):=103;
                            elseif item='LastUpdate' then ItemOrder(item):=104;
                    
                            ! PRO Session
                            elseif item='SOLVER SESSION' then ItemOrder(item):=200;
                            elseif item='EndPoint' then ItemOrder(item):=201;
                            elseif item='# Constraints' then ItemOrder(item):=202;
                            elseif item='# Variables' then ItemOrder(item):=203;
                            elseif item='# Nonzeros' then ItemOrder(item):=204;
                            elseif item='Solver' then ItemOrder(item):=205;
                            elseif item='Iterations' then ItemOrder(item):=206;
                            elseif item='Nodes' then ItemOrder(item):=207;
                            elseif item='Branches' then ItemOrder(item):=208;
                            elseif item='Failures' then ItemOrder(item):=209;
                            elseif item='Objective' then ItemOrder(item):=210;
                            elseif item='Best Bound' then ItemOrder(item):=211;
                            elseif item='Incumbent' then ItemOrder(item):=212;
                            elseif item='Gap' then ItemOrder(item):=213;
                            elseif item='Solution Time' then ItemOrder(item):=214;
                            elseif item='Memory' then ItemOrder(item):=215;
                            elseif item='Program Status' then ItemOrder(item):=216;
                    
                            else ItemOrder(item):=1001; endif;
                    endfor; endif;
                    
                    update LineColor;
                    
                    return 1;
                }
            }
            Procedure SolveInterruptSession {
                Body: {
                    if (NoTerminationConfirmation) then
                            ret := 1;
                    else
                            ret := DialogAsk("Do you want to interrupt the current solve? The execution will continue in the next statement.","Yes","No",title:"PRO Framework");
                    endif;
                    
                    if (ret = 1) then
                            return pro::client::StopExecution(session::WorkerQueue(guipro::session::selectedSession),pro::AIMMSAPI_INTERRUPT_SOLVE);
                    endif;
                }
                Parameter ret;
            }
            Procedure ProcedureInterruptSession {
                Body: {
                    if (NoTerminationConfirmation) then
                            ret := 1;
                    else
                            ret := DialogAsk("Do you want to interrupt the current procedure? The request will be finished.","Yes","No",title:"PRO Framework");
                    endif;
                    if (ret = 1) then
                            return pro::client::StopExecution(session::WorkerQueue(guipro::session::selectedSession),pro::AIMMSAPI_INTERRUPT_EXECUTE);
                    endif;
                }
                Parameter ret;
            }
            Procedure TerminateSession {
                Body: {
                    if (NoTerminationConfirmation) then
                            ret := 1;
                    else
                            ret := DialogAsk("Do you want to terminate the request? No data will be retrieved.","Yes","No",title:"PRO Framework");
                    endif;
                    
                    if (ret = 1) then
                            ! Finish progress window, if activated
                            if(WatchedSession = guipro::session::selectedSession) then
                                    WatchedSession := '';
                            endif;
                            return pro::sessionmanager::TerminateSession(guipro::session::selectedSession);
                    endif;
                }
                Parameter ret;
            }
        }
    }
    Module User_Sessions {
        Prefix: session;
        Set SessionList {
            Index: sess;
            Parameter: selectedSession;
            Property: NoSave;
        }
        StringParameter ClientQueue {
            IndexDomain: (sess);
            Property: NoSave;
            InitialData: "";
        }
        StringParameter WorkerQueue {
            IndexDomain: (sess);
            Property: NoSave;
            InitialData: "";
        }
        Parameter CurrentStatus {
            IndexDomain: (sess);
            Property: NoSave;
            InitialData: 0;
        }
        StringParameter CreateTime {
            IndexDomain: (sess);
            Property: NoSave;
            InitialData: "";
        }
        StringParameter UserEnv {
            IndexDomain: (sess);
            Property: NoSave;
            InitialData: "";
        }
        StringParameter UserName {
            IndexDomain: (sess);
            Property: NoSave;
            InitialData: "";
        }
        StringParameter Application {
            IndexDomain: (sess);
            Property: NoSave;
            InitialData: "";
        }
        Parameter IsManaged {
            IndexDomain: sess;
            Range: binary;
            Property: NoSave;
            InitialData: 0;
        }
        StringParameter RequestDescription {
            IndexDomain: sess;
            Property: NoSave;
            InitialData: "";
        }
        StringParameter RequestProcedure {
            IndexDomain: sess;
            Property: NoSave;
            InitialData: "";
        }
        Parameter RunTimeOut {
            IndexDomain: sess;
            Property: NoSave;
            InitialData: 0;
        }
        StringParameter VersionID {
            IndexDomain: sess;
            Property: NoSave;
            InitialData: "";
        }
        StringParameter ResponseVersionID {
            IndexDomain: sess;
            Property: NoSave;
            InitialData: "";
        }
        StringParameter MessageLogVersionID {
            IndexDomain: sess;
            Property: NoSave;
            InitialData: "";
        }
        StringParameter ErrorMessage {
            IndexDomain: sess;
            Property: NoSave;
            InitialData: "";
        }
        StringParameter RequestTime {
            IndexDomain: sess;
            Property: NoSave;
            InitialData: "";
        }
        StringParameter OriginalCasePath {
            IndexDomain: sess;
            Property: NoSave;
            InitialData: "";
        }
        Parameter ActiveStatus {
            IndexDomain: sess;
            Property: NoSave;
            InitialData: 0;
        }
        Parameter ErrorCode {
            IndexDomain: sess;
            Property: NoSave;
            InitialData: 0;
        }
        StringParameter Summary {
            Property: NoSave;
            Definition: {
                if ( selectedSession ) then
                	"Selected Request\t: " + RequestDescription(selectedSession) + "\n" +
                	"Request Time\t: " + CreateTime(selectedSession) + "\n" +
                	"Current Status\t: " + CurrentStatus(selectedSession) + "\n" +
                	"Case Path\t: " + OriginalCasePath(selectedSession) + "\n" +
                	"Error Message\t: " + ErrorMessage(selectedSession)
                else
                	"Selected Request\t: \n" +
                	"Request Time\t: \n" +
                	"Current Status\t: \n" +
                	"Case Path\t: \n" +
                	"Error Message\t: "
                endif
            }
        }
        Procedure LoadSessionList {
            Arguments: (SinceDate,AllUsers);
            Body: {
                ! Initialize PRO Framework (if not initialized yet)
                ret := pro::Initialize();
                if not (ret) then return 0; endif;
                
                if (AllUsers) then
                        SessionModelId := "";
                        SessionModelVersion := "";
                else
                        SessionModelId := pro::ModelName;
                        ! Retrieve sessions for all versions of the model
                        SessionModelVersion := ""; ! don't restrict to a specific ModelVersion
                endif;
                
                empty SessionList;
                
                if (not SinceDate) then
                        SinceDate := CurrentToStringDelta(-24*60*60);        ! Requests for the last 24h
                endif;
                
                ! Load raw session list from PROT
                ret := pro::sessionmanager::ListSessionSinceDate(SinceDate,SessionList,ClientQueue,WorkerQueue,CurrentStatus,
                                                      CreateTime,UserEnv,UserName,Application,
                                                      OriginalCasePath, RequestDescription, RequestProcedure, RunTimeOut,
                                                      VersionID, ResponseVersionID, MessageLogVersionID,
                                                      ErrorMessage, ActiveStatus, ErrorCode, AllUsers, SessionModelId, SessionModelVersion);
                
                if not pro::HandleError(ret) then return 0; endif;
                if Card(SessionList) = 0 then return 1; endif;
                
                if not pro::HandleError(ret) then return 0; endif;
                
                ! Update session list data with managed session info, if available
                IsManaged(sess) := 1;
                
                return 1;
            }
            Parameter ret;
            StringParameter contList;
            Set Containers {
                Index: CONT;
                Parameter: Container;
            }
            Set Items {
                Index: Item;
                Parameter: PeItem;
            }
            StringParameter Value {
                IndexDomain: (CONT,ITEM);
            }
            ElementParameter Ref {
                IndexDomain: (CONT,ITEM);
                Range: Containers;
            }
            StringParameter SinceDate {
                Property: Input;
            }
            Parameter AllUsers {
                Default: 0;
                Property: Optional;
            }
            StringParameter SessionModelID;
            StringParameter SessionModelVersion;
        }
        Procedure PurgeSessionList {
            Arguments: (sList);
            Body: {
                if Card(sList) = 0 then return 0; endif;
                
                ! prevent incoming messages for sessions that are to be deleted from being handled
                for sessList do
                        pro::session::RemoveManagedSession(sessList);
                endfor;
                
                ! Request to remove sessions in PROT, this includes clearing out the message database
                warnStr := "";
                ret := pro::sessionmanager::ClearSessionDatabase(sList,warnStr);
                if not pro::HandleError(ret) then return 0; endif;
                
                if (warnStr <> "") then
                        DialogMessage(warnStr,"Warnings");
                endif;
                
                return 1;
            }
            Set sList {
                Index: sessList;
                Property: Input;
            }
            Parameter ret;
            StringParameter warnStr;
            StringParameter contList;
            Set queueList {
                Index: sessQueueList;
                Parameter: sessionListElement;
            }
        }
        Procedure ExportSessionList {
            Arguments: (sList);
            Body: {
                if Card(sList) = 0 then return 0; endif;
                
                if (pro::IsNewDataManagementStyle) then
                        if not DirectorySelect(CaseFolder, title: "Select case folder") then return 0; endif;
                else
                        PackFileName := "PRORequests.dat";
                        if not FileSelectNew(PackFileName, title : "Select file to pack") then return 0; endif;
                
                    if not FileExists("StgConv.exe") then
                            FileCopy("<lib:pro>:StgConv.exe","StgConv.exe");
                        endif;
                
                        CaseFolder := pro::PROTempFolder + pro::FileSeparator + "Empty.dat";
                        ! Generate the empty case structure
                        if DirectoryExists(CaseFolder) then
                                DirectoryDelete(CaseFolder);
                        endif;
                        FileCopy("<lib:pro>:Empty.dat",CaseFolder,0);
                        pro::management::UnpackIStorage(CaseFolder);
                
                        ! Fill index
                        CaseTree := CaseFolder + pro::FileSeparator + "{CASETREE}";
                        PUT Content;
                endif;
                
                fileCont := 0;
                for sessList do
                        sessionElement := StringToElement(SessionList,sessList);
                        if IsManaged(sessionElement) and ResponseVersionID(sessionElement) <> "" then
                                if (pro::IsNewDataManagementStyle) then
                                    caseFilename := CaseFolder + pro::FileSeparator + FindReplaceStrings(FormatString("%s (%i).data",RequestDescription(sessionElement),fileCont), ":", "-");
                                else
                                    caseFilename := CaseFolder + FormatString("%s%>08i",pro::FileSeparator, fileCont);
                                endif;
                
                                pro::GetObjectVersionDirect(ResponseVersionID(sessionElement),caseFilename);
                
                                if (not pro::IsNewDataManagementStyle) then
                                        ! Index entry
                                        if fileCont = 1 then PUT "c"; else PUT "n"; endif;
                                        PUT FormatString(" %i 0 0 0 00022626 -1 1 5", fileCont), /;
                                        PUT "GE113CC98-C66F-4DDC-9830-D3C2ECBFF825", /;
                                        PUT FormatString("N%s (%i)",RequestDescription(sessionElement),fileCont), /;
                                endif;
                        endif;
                endfor;
                
                if (not pro::IsNewDataManagementStyle) then
                        PUT "p";
                        PUTCLOSE Content;
                
                        ! Pack the content into a single file
                        pro::management::PackIStorage(pro::PROTempFolder + "//Empty.dat");
                        FileMove(pro::PROTempFolder + "//Empty.dat",PackFileName,0);
                        DialogMessage("Selected cases downloaded to file \"" + PackFileName + "\". You can now import all cases to your project through menu \"Edit\"/\"Import\" in the Data Manager page");
                endif;
                
                return 1;
            }
            StringParameter caseFilename;
            Set sList {
                Index: sessList;
                Property: Input;
            }
            ElementParameter sessionElement {
                Range: SessionList;
            }
            StringParameter PackFileName;
            StringParameter CaseFolder;
            Parameter ret;
            StringParameter CaseTree;
            File Content {
                Name: CaseTree;
                Encoding: 'UTF8';
                Mode: replace;
            }
            StringParameter getFileName;
            Parameter fileCont {
                Range: integer;
                InitialData: 0;
            }
        }
        Procedure LoadResponse {
            Arguments: (Request);
            Body: {
                ! Basic validation
                if Request = '' then
                        raise error "Invalid request reference" code 'PRO-Invalid-request-reference' ;
                        return 0;
                endif;
                
                changedStatus := pro::version::GetCaseStatus();
                
                ! Either error state or not available state
                if (ResponseVersionID(Request) = "") then
                        ! Collect error information
                        if (ErrorCode(Request)) then
                        ret := 2;
                        if MessageLogVersionID(Request) <> "" then
                                ret := DialogAsk("Execution finished with an error. Do you want to download and open the messages.log file?","Yes","No",title:"PRO Framework");
                
                                if (ret = 1) then
                                        SaveAndOpenVersionInTemp(MessageLogVersionID(Request));
                                        return 0;
                                endif;
                        endif;
                
                        if ret = 2 AND ErrorMessage(Request) <> "" then
                                DialogMessage("Execution finished with error message: " + ErrorMessage(Request),title:"PRO Framework");
                                return 0;
                        endif;
                        endif;
                
                        if (MessageLogVersionID(Request) = "") and (ErrorCode(Request) = 0) then
                                DialogMessage("No output case was generated by the application",title:"PRO Framework");
                                return 0;
                        endif;
                
                        return 1;
                else
                        ! Open options page
                        guipro::session::Request := Request;
                
                        pro::version::FindCase(OriginalCasePath(Request),guipro::session::OriginalCase);
                
                        if (changedStatus) then
                                guipro::session::WarningNonSavedData := "Attention: the current case contains unsaved data; loading a new case will overwrite this!";
                        else
                                empty guipro::session::WarningNonSavedData;
                                pro::version::ResetCaseStatus();
                        endif;
                
                        PageOpen("Load Response");
                
                        return 1;
                endif;
            }
            ElementParameter Request {
                Range: SessionList;
                Property: Input;
            }
            Parameter ret;
            StringParameter tmpFile {
                InitialData: "";
            }
            StringParameter tmpFileLog {
                InitialData: "";
            }
            StringParameter tmpStr {
                InitialData: "";
            }
            Parameter changedStatus {
                Range: binary;
            }
            StringParameter logFolder;
        }
        Section User_Session_List_GUI {
            StringParameter DateToList {
                Property: NoSave;
            }
            StringParameter PersistentSelectedFolder {
                Property: NoSave;
                InitialData: "";
            }
            Parameter Mark {
                IndexDomain: sess;
                Range: binary;
                Property: NoSave;
                InitialData: 0;
            }
            StringParameter SessionName {
                IndexDomain: sess;
                Property: NoSave;
                Definition: {
                    if IsManaged(sess) then
                            RequestDescription(sess)
                    else
                            "<<not managed>>"
                    endif
                }
            }
            StringParameter CurrentStatusDescr {
                IndexDomain: sess;
                Property: NoSave;
                Definition: {
                    if(CurrentStatus(sess) = 0) then
                    "Created"
                    elseif(CurrentStatus(sess) = 1) then
                    "Queued"
                    elseif(CurrentStatus(sess) = 2) then
                    "Starting server session"
                    elseif(CurrentStatus(sess) = 3) then
                    "Waiting for tasks"
                    elseif(CurrentStatus(sess) = 4) then
                    "Running"
                    elseif(CurrentStatus(sess) = 5) then
                    "Closing server session"
                    elseif(CurrentStatus(sess) = 6) then
                    "Finished"
                    elseif(CurrentStatus(sess) = 7) then
                    "Terminated"
                    elseif(CurrentStatus(sess) = 8) then
                    "Finished with errors"
                    elseif(CurrentStatus(sess) = 9) then
                    "Deleted"
                    else
                    "Unknown"
                    endif
                }
            }
            Parameter GotResults {
                IndexDomain: sess;
                Range: binary;
                Property: NoSave;
                Definition: ResponseVersionID(sess) <> "";
            }
            Set sessionMarked {
                SubsetOf: SessionList;
                Index: sessMark;
                Property: NoSave;
                Definition: {
                    {sess | Mark(sess)}
                }
            }
            Parameter noSessionsMarked {
                Property: NoSave;
                Definition: card(sessionMarked) = 0;
            }
            Parameter nonAdminUser {
                Property: NoSave;
                InitialData: 1;
            }
            Parameter allUsersRequests {
                Property: NoSave;
                InitialData: 0;
            }
            Parameter singleUserRequest {
                Property: NoSave;
                Definition: 1 $ (not allUsersRequests);
            }
            Parameter markAllRequests {
                Range: binary;
                Property: NoSave;
            }
            StringParameter sessionLogFile {
                Property: NoSave;
            }
            ElementParameter sessionColor {
                IndexDomain: session::sess;
                Range: AllColors;
                Property: NoSave;
                Definition: if session::sess = session::selectedSession then 'blue' endif;
            }
            Procedure MarkAll {
                Body: {
                    Mark(sess) := markAllRequests;
                    return 1;
                }
            }
            Procedure SeeActions {
                Body: {
                    PageOpen("Actions");
                    return 1;
                }
            }
            Procedure DownloadMarked {
                Body: {
                    if Card(sessionMarked) = 0 then return 0; endif;
                    
                    ret := ExportSessionList(sessionMarked);
                    if not (ret) then return 0; endif;
                    
                    return 1;
                }
                Parameter ret;
            }
            Procedure TerminateMarked {
                Body: {
                    if Card(sessionMarked) = 0 then return 0; endif;
                    
                    ! Remove in batches to prevent call timeouts
                    sessionsToTerminate := sessionMarked;
                    for sess in sessionsToTerminate | IsManaged(sess) do
                            ret := pro::sessionmanager::TerminateSession(sess);
                    endfor;
                    
                    ! Update session list
                    ret := UpdateSessionList;
                    if not (ret) then return 0; endif;
                    
                    return 1;
                }
                Set sessionsToTerminate {
                    SubsetOf: SessionList;
                }
                Set sessionTerminateList {
                    SubsetOf: SessionList;
                }
                Parameter ret;
                Set VersionToRemove {
                    Parameter: PeVersionToRemove;
                }
            }
            Procedure RemoveMarked {
                Body: {
                    if Card(sessionMarked) = 0 then return 0; endif;
                    
                    ! Remove in batches to prevent call timeouts
                    sessionsToRemove := sessionMarked;
                    while (card(sessionsToRemove) > 0) do
                            sessionRemoveList := SubRange(sessionsToRemove, Element(sessionsToRemove,1),
                                                                            Element(sessionsToRemove,Min(50,Card(sessionsToRemove))));
                            sessionsToRemove -= sessionRemoveList;
                    
                            ret := PurgeSessionList(sessionRemoveList);
                            if not (ret) then return 0; endif;
                    
                            ! Purge all object versions related to managed sessions
                            empty VersionToRemove;
                            for sess in sessionRemoveList | IsManaged(sess) do
                                    if(VersionID(sess) <> "") then SetElementAdd(VersionToRemove,PeVersionToRemove,VersionID(sess)); endif;
                                    if(ResponseVersionID(sess) <> "") then SetElementAdd(VersionToRemove,PeVersionToRemove,ResponseVersionID(sess)); endif;
                                    if(MessageLogVersionID(sess) <> "") then SetElementAdd(VersionToRemove,PeVersionToRemove,MessageLogVersionID(sess)); endif;
                            endfor;
                            ret := pro::storage::DeleteObjectVersionFromSet(VersionToRemove);
                            if not pro::HandleError(ret) then return 0; endif;
                    endwhile;
                    
                    ! Update session list
                    ret := UpdateSessionList;
                    if not (ret) then return 0; endif;
                    
                    return 1;
                }
                Set sessionsToRemove {
                    SubsetOf: SessionList;
                }
                Set sessionRemoveList {
                    SubsetOf: SessionList;
                }
                Parameter ret;
                Set VersionToRemove {
                    Parameter: PeVersionToRemove;
                }
            }
            Procedure DownloadAndOpenLog {
                Body: {
                    return SaveAndOpenVersionInTemp(MessageLogVersionID(selectedSession));
                }
            }
            Procedure UpdateSessionList {
                Body: {
                    ! Initialize PRO Framework (if not initialized yet)
                    ret := pro::Initialize();
                    if not (ret) then return 0; endif;
                    
                    for pro::userGroup do
                            if ( val(pro::userGroup) = pro::PROA_ADMIN_GROUP ) then
                                    session::nonAdminUser := 0;
                            break;
                            endif;
                    endfor;
                    
                    ret := pro::session::LoadManagedSessions;
                    if not (ret) then return 0; endif;
                    
                    StatusMessage("");
                    
                    ! Store the currently selected session.
                    storedSelectedSession := selectedSession;
                    
                    if LoadSessionList(DateToList,allUsersRequests) then
                            ! Set selectedSession to the storedSelectedSession if it is still in the SessionList.
                            selectedSession := StringToElement(SessionList, storedSelectedSession);
                            return 1;
                    else
                            return 0;
                    endif;
                }
                Parameter ret;
                StringParameter storedSelectedSession;
            }
            Procedure LoadRequestResponse {
                Body: {
                    if selectedSession = '' then return 0; endif;
                    
                    pro::session::SetSessionData(selectedSession, RequestDescription(selectedSession),
                                                             ClientQueue(selectedSession),
                                                             WorkerQueue(selectedSession),
                                                             RequestProcedure(selectedSession),
                                                             RunTimeOut(selectedSession),
                                                             VersionID(selectedSession),
                                                             ResponseVersionID(selectedSession),
                                                             MessageLogVersionID(selectedSession),
                                                             ErrorMessage(selectedSession),
                                                             RequestTime(selectedSession),
                                                             OriginalCasePath(selectedSession));
                    
                    ret := LoadResponse(selectedSession);
                    if not (ret) then return 0; endif;
                }
                Parameter ret;
            }
            Procedure CloseRequestManager {
                Body: {
                    return PageClose("Managed Requests");
                }
            }
        }
        Section Load_Response_GUI {
            Procedure LoadResponseAction {
                Body: {
                    ! Prepare case to load
                    if OriginalCase <> '' then
                            pro::version::ResetCaseStatus();
                            pro::version::LoadCaseAsCurrent(OriginalCase);
                    else
                            pro::version::NewCase();
                    endif;
                    
                    ! Get the case file and the message log from the Storage Service
                    if MessageLogVersionID(Request) <> "" then
                        ret := pro::LoadLogMessages(MessageLogVersionID(Request), tmpFileLog);
                        if not ret then return 0; endif;
                    endif;
                    
                    ! Load Case file
                    ret := pro::LoadCaseFromObjectVersion(ResponseVersionID(Request));
                    
                    if not ret then
                            DialogMessage("Error during load. File corrupted.", "PRO Framework - Load Solution");
                            ! Maybe the case has problems because of some execution error; check messages.log if it exists
                            if MessageLogVersionID(Request) <> "" then
                                     ShowMessageWindow();
                            endif;
                            return 0;
                    endif;
                    Apply(pro::session::PostLoadResultCaseHook);
                }
                Parameter ret;
                StringParameter tmpFile {
                    InitialData: "";
                }
                StringParameter tmpFileLog {
                    InitialData: "";
                }
            }
            Set LoadOptions {
                Property: NoSave;
            }
            ElementParameter Request {
                Range: SessionList;
                Property: NoSave;
            }
            ElementParameter OriginalCase {
                Range: AllCases;
                Property: NoSave;
                InitialData: '';
            }
            StringParameter WarningNonSavedData {
                Property: NoSave;
            }
        }
    }
    Section Authentication_Data {
        DeclarationSection User_and_Group_Entities {
            Set PROEnv {
                Index: PRO_ENV;
                Parameter: Pe_Env, Pe_GUI_Env;
                Property: NoSave;
                OrderBy: PRO_ENV;
            }
            Set PROEntity {
                Index: PRO_ENT, PRO_ENT_U, PRO_ENT_G;
                Parameter: Pe_Entity;
                Property: NoSave;
            }
            Set PROUser {
                SubsetOf: PROEntity;
                Index: PRO_USER;
                Parameter: Pe_User;
                Property: NoSave;
                OrderBy: PROUserName(PRO_USER);
            }
            Set PROEnvUser {
                IndexDomain: (PRO_ENV);
                SubsetOf: PROUser;
                Property: NoSave;
            }
            Set PROGroup {
                SubsetOf: PROEntity;
                Index: PRO_GRP;
                Parameter: Pe_Group;
                Property: NoSave;
                OrderBy: PROGroupName(PRO_GRP);
            }
            Set PROEnvGroup {
                IndexDomain: (PRO_ENV);
                SubsetOf: PROGroup;
                Property: NoSave;
            }
            StringParameter PROEnvName {
                IndexDomain: (PRO_ENV);
                Property: NoSave;
            }
            StringParameter PROEnvDescr {
                IndexDomain: (PRO_ENV);
                Property: NoSave;
            }
            StringParameter PROEnvAuth {
                IndexDomain: (PRO_ENV);
                Property: NoSave;
            }
            StringParameter PROUserName {
                IndexDomain: (PRO_ENT_U);
                Property: NoSave;
            }
            StringParameter PROGroupName {
                IndexDomain: (PRO_ENT_G);
                Property: NoSave;
            }
            Parameter PROUserGroup {
                IndexDomain: (PRO_ENT_U,PRO_ENT_G);
                Range: binary;
                Property: NoSave;
            }
            Parameter PROEntityIsGroup {
                IndexDomain: PRO_ENT;
                Range: binary;
                Property: NoSave;
            }
            StringParameter PROEntityType {
                IndexDomain: PRO_ENT;
                Property: NoSave;
                Definition: {
                    if PROEntityIsGroup(PRO_ENT) then
                            "group"
                    else
                            "user"
                    endif
                }
            }
            ElementParameter PROEntityEnvironment {
                IndexDomain: PRO_ENT;
                Range: PROEnv;
                Default: '';
                Property: NoSave;
            }
            StringParameter PROEntityEnvironmentName {
                IndexDomain: PRO_ENT;
                Property: NoSave;
                Definition: {
                    if PROEntityEnvironment(PRO_ENT) = '' then
                            if (Val(PRO_ENT) = 16777215 OR Val(PRO_ENT) = 16777087) then
                                    "<<all>>"
                            else
                                    "?"
                            endif
                    else
                            PROEnvName(PROEntityEnvironment(PRO_ENT))
                    endif
                }
            }
            StringParameter PROEntityName {
                IndexDomain: PRO_ENT;
                Property: NoSave;
            }
        }
        Procedure PopulateEntitySets {
            Arguments: (addUniversalSets);
            Body: {
                ! Populate users and groups
                ret := pro::authentication::GetEnvironmentList(PROEnv,PROEnvName,PROEnvDescr,PROEnvAuth);
                for (PRO_ENV) do
                        block
                                empty UserCurrentEnv, GroupCurrentEnv;
                
                                ret := pro::authentication::GetEnvironmentUsersAndGroups(PROEnvName(PRO_ENV),UserCurrentEnv,GroupCurrentEnv,PROUserName,PROGroupName);
                
                                if (addUniversalSets) then
                                        tmpEnt := FormatString("%i",16776960 + Val(PRO_ENV));   ! 0xFFFF00 = 0xFFFF | 0x0 (+ 7 bits to the environment id)
                                        SetElementAdd(PROUser,Pe_User,tmpEnt);
                                        PROUserName(Pe_User) := "<<all>>";
                                        UserCurrentEnv += Pe_User;
                                        tmpEnt := FormatString("%i",16777088 + Val(PRO_ENV));   ! 0xFFFF80 = 0xFFFF | 0x1 (+ 7 bits to the environment id)
                                        SetElementAdd(PROGroup,Pe_Group,tmpEnt);
                                        PROGroupName(Pe_Group) := "<<all>>";
                                        GroupCurrentEnv += Pe_Group;
                                endif;
                
                                PROEnvUser(PRO_ENV) := UserCurrentEnv;
                                PROEnvGroup(PRO_ENV) := GroupCurrentEnv;
                
                                PROEntityEnvironment(PRO_ENT in UserCurrentEnv) := PRO_ENV;
                                PROEntityEnvironment(PRO_ENT in GroupCurrentEnv) := PRO_ENV;
                        onerror err do
                                errh::MarkAsHandled(err);
                        endblock;
                endfor;
                
                ! Retrieve user and group relationships
                empty PROUserGroup;
                for (PRO_ENV) do
                        block
                                ret := pro::authentication::GetEntityList(PROEnvName(PRO_ENV),PROUser,PROGroup,PROUserName,PROGroupName,PROUserGroup);
                        onerror err do
                                errh::MarkAsHandled(err);
                        endblock;
                endfor;
                
                ! Add universal group
                if (addUniversalSets) then
                        empty UserCurrentEnv,GroupCurrentEnv;
                
                        tmpEnt := FormatString("%i", 127);
                        SetElementAdd(PROEnv,Pe_Env,tmpEnt);
                        PROEnvName(Pe_Env) := "<<all>>";
                
                        tmpEnt := FormatString("%i",16776960 + Val(Pe_Env));    ! 0xFFFF00 = 0xFFFF | 0x0 (+ 7 bits to the environment id)
                        SetElementAdd(PROUser,Pe_User,tmpEnt);
                        PROUserName(Pe_User) := "<<all>>";
                        UserCurrentEnv += Pe_User;
                
                        tmpEnt := FormatString("%i",16777088 + Val(Pe_Env));    ! 0xFFFF80 = 0xFFFF | 0x1 (+ 7 bits to the environment id)
                        SetElementAdd(PROGroup,Pe_Group,tmpEnt);
                        PROGroupName(Pe_Group) := "<<all>>";
                        GroupCurrentEnv += Pe_Group;
                
                        PROEnvUser(Pe_Env) := UserCurrentEnv;
                        PROEnvGroup(Pe_Env) := GroupCurrentEnv;
                        PROEntityEnvironment(PRO_ENT in UserCurrentEnv) := Pe_Env;
                        PROEntityEnvironment(PRO_ENT in GroupCurrentEnv) := Pe_Env;
                endif;
                
                empty PROEntityIsGroup;
                PROEntityIsGroup(PRO_GRP) := 1;
                PROEntityName(PRO_USER) := PROUserName(PRO_USER);
                PROEntityName(PRO_GRP) := PROGroupName(PRO_GRP);
            }
            Parameter ret;
            ElementParameter err {
                Range: errh::PendingErrors;
            }
            Set UserCurrentEnv {
                SubsetOf: PROUser;
            }
            Set GroupCurrentEnv {
                SubsetOf: PROGroup;
            }
            StringParameter tmpEnt;
            Parameter addUniversalSets {
                Default: 0;
                Property: Optional;
            }
        }
        Procedure DeconstructAuthorizationString {
            Arguments: (AuthString,AuthEntity,AuthEntityDeny,AuthEntityExec,AuthEntityRead,AuthEntityWrite);
            Body: {
                if SubString(AuthString,1,1) = "#" then
                        tmpLength := StringLength(AuthString);
                        tmpLast := 2;
                        tmpCont := 2;
                        tmpNext := FindNthString(AuthString,"#",tmpCont);
                        while tmpLast < tmpLength do
                                if (tmpNext = 0) then tmpNext := tmpLength + 1; endif;
                
                                tmpAuth := SubString(AuthString,tmpLast,tmpNext - 1);
                
                                tmpEnt := SubString(tmpAuth,3,1000);
                                tmpFlag := Val(SubString(tmpAuth,1,1));
                                if SubString(tmpAuth,2,2) = "-" then
                                        tmpDeny := 1;
                                else
                                        tmpDeny := 0;
                                endif;
                
                                Pe_Entity := StringToElement(PROEntity,tmpEnt);
                                AuthEntity += Pe_Entity;
                                AuthEntityDeny(Pe_Entity) := tmpDeny;
                
                                if Mod(div(tmpFlag,2^0),2)=1 then AuthEntityExec(Pe_Entity) := 1; endif;
                                if Mod(div(tmpFlag,2^1),2)=1 then AuthEntityWrite(Pe_Entity) := 1; endif;
                                if Mod(div(tmpFlag,2^2),2)=1 then AuthEntityRead(Pe_Entity) := 1; endif;
                
                                tmpLast := min(tmpNext + 1,tmpLength);
                                tmpCont += 1;
                                tmpNext := FindNthString(AuthString,"#",tmpCont);
                        endwhile;
                
                endif;
            }
            StringParameter AuthString {
                Property: Input;
            }
            Set AuthEntity {
                SubsetOf: PROEntity;
                Index: auth_ent;
                Property: Output;
            }
            Parameter AuthEntityDeny {
                IndexDomain: auth_ent;
                Property: Output;
            }
            Parameter AuthEntityExec {
                IndexDomain: auth_ent;
                Property: Output;
            }
            Parameter AuthEntityRead {
                IndexDomain: auth_ent;
                Property: Output;
            }
            Parameter AuthEntityWrite {
                IndexDomain: auth_ent;
                Property: Output;
            }
            Parameter tmpLength;
            Parameter tmpLast;
            Parameter tmpNext;
            Parameter tmpCont;
            Parameter tmpFlag {
                Range: integer;
            }
            StringParameter tmpAuth;
            Parameter tmpDeny {
                Range: binary;
            }
            StringParameter tmpEnt;
        }
        Procedure ConstructAuthorizationString {
            Arguments: (AuthEntity,AuthEntityDeny,AuthEntityExec,AuthEntityRead,AuthEntityWrite,AuthString);
            Body: {
                for auth_ent do
                    tmpFlag := 0;
                    if AuthEntityExec(auth_ent) then tmpFlag += 2^0; endif;
                    if AuthEntityWrite(auth_ent) then tmpFlag += 2^1; endif;
                    if AuthEntityRead(auth_ent) then tmpFlag += 2^2; endif;
                    if AuthEntityDeny(auth_ent) then tmpAuth := "-"; else tmpAuth := "+"; endif;
                    AuthString += FormatString("#%i%s%e",tmpFlag,tmpAuth,auth_ent);
                endfor;
            }
            Set AuthEntity {
                SubsetOf: PROEntity;
                Index: auth_ent;
                Property: Input;
            }
            Parameter AuthEntityDeny {
                IndexDomain: auth_ent;
                Property: Input;
            }
            Parameter AuthEntityExec {
                IndexDomain: auth_ent;
                Property: Input;
            }
            Parameter AuthEntityRead {
                IndexDomain: auth_ent;
                Property: Input;
            }
            Parameter AuthEntityWrite {
                IndexDomain: auth_ent;
                Property: Input;
            }
            StringParameter AuthString {
                Property: Output;
            }
            Parameter tmpFlag {
                Range: integer;
            }
            StringParameter tmpAuth;
        }
    }
    Section Authorization_Editor {
        DeclarationSection Entity_Properties_Current_Authorized_Object {
            Set CurrentEntity {
                SubsetOf: PROEntity;
                Index: CUR_ENT;
                Parameter: Pe_CUR_Entity;
                Property: NoSave;
            }
            Parameter CurrentObjectEntityDeny {
                IndexDomain: CUR_ENT;
                Range: binary;
                Property: NoSave;
            }
            Parameter CurrentObjectEntityExec {
                IndexDomain: CUR_ENT;
                Range: binary;
                Property: NoSave;
            }
            Parameter CurrentObjectEntityRead {
                IndexDomain: CUR_ENT;
                Range: binary;
                Property: NoSave;
            }
            Parameter CurrentObjectEntityWrite {
                IndexDomain: CUR_ENT;
                Range: binary;
                Property: NoSave;
            }
            Set CurrentUserSet {
                SubsetOf: PROUser;
                Parameter: Pe_GUI_User;
                Property: NoSave;
                Definition: PROEnvUser(Pe_GUI_Env);
            }
            Set CurrentGroupSet {
                SubsetOf: PROGroup;
                Parameter: Pe_GUI_Group;
                Property: NoSave;
                Definition: PROEnvGroup(Pe_GUI_Env);
            }
            Parameter PROCancelAuth {
                Range: binary;
                Property: NoSave;
            }
        }
        Procedure EditAuthorization {
            Arguments: (AuthString);
            Body: {
                IF NOT SessionHasVisibleGUI THEN
                        return 0;
                ENDIF;
                
                LocalizationInitialize;
                
                ! Initialize PRO Framework (if not initialized yet)
                ret := pro::Initialize();
                if not (ret) then return 0; endif;
                
                if not pro::handleError(ret) then return 0; endif;
                PopulateEntitySets(1);
                
                tmpEnv := pro::GetPROEnvironment;
                Pe_Env := First(PRO_ENV | PROEnvName(PRO_ENV) = tmpEnv);
                
                ! Fill the sets with the authorization string
                Empty CurrentEntity,CurrentObjectEntityDeny, CurrentObjectEntityExec, CurrentObjectEntityRead, CurrentObjectEntityWrite;
                DeconstructAuthorizationString(AuthString, CurrentEntity, CurrentObjectEntityDeny, CurrentObjectEntityExec, CurrentObjectEntityRead, CurrentObjectEntityWrite);
                
                ! Open the edit dialog
                PROCancelAuth := 0;
                PageOpen("Authorization Manager");
                if not PROCancelAuth then
                        ! Encode the string back
                        AuthString := "";
                		ConstructAuthorizationString(CurrentEntity, CurrentObjectEntityDeny, CurrentObjectEntityExec, CurrentObjectEntityRead, CurrentObjectEntityWrite, AuthString);
                else
                        return 0;
                endif;
                
                return 1;
            }
            StringParameter AuthString {
                Property: InOut;
            }
            Parameter ret;
            ElementParameter err {
                Range: errh::PendingErrors;
            }
            Parameter tmpLength;
            Parameter tmpLast;
            Parameter tmpNext;
            Parameter tmpCont;
            StringParameter tmpAuth;
            Parameter tmpFlag {
                Range: integer;
            }
            Parameter tmpDeny {
                Range: binary;
            }
            StringParameter tmpEnt;
            StringParameter tmpEnv;
            ElementParameter tmpEntElem {
                Range: PROEntity;
            }
            Index n {
                Range: Integers;
            }
        }
        Procedure AddUserAuthorization {
            Body: {
                ! Validation
                if Pe_GUI_User = '' then
                        DialogError("Please select a valid user","Add User Authorization");
                        return 0;
                endif;
                
                ! Add to the set
                CurrentEntity += Pe_GUI_User;
                
                return 1;
            }
        }
        Procedure AddGroupAuthorization {
            Body: {
                ! Validation
                if Pe_GUI_Group = '' then
                        DialogError("Please select a valid group","Add Group Authorization");
                        return 0;
                endif;
                
                ! Add to the set
                CurrentEntity += Pe_GUI_Group;
                
                return 1;
            }
        }
        Procedure RemoveEntityAuthorization {
            Body: {
                ! Validation
                if Pe_CUR_Entity = '' then
                        DialogError("Please select a valid entity","Remove Authorization");
                        return 0;
                endif;
                
                ! Add to the set
                CurrentEntity -= Pe_CUR_Entity;
                
                return 1;
            }
        }
    }
    Procedure LibraryInitialization {
        Body: {
            ! General settings
            session::DateToList := CurrentToStringDelta(-24*60*60);        ! Requests for the last 24h
            session::DateToList := Substring(session::DateToList,1,11) + "00:00:00";   ! rounding to days
            session::selectedSession := '';
            
            for pro::userGroup do
                    if ( val(pro::userGroup) = pro::PROA_ADMIN_GROUP ) then
                            session::nonAdminUser := 0;
                            break;
                    endif;
            endfor;
            
            ! Initialize internationalization module
            LocalizationInitialize;
            
            IF StringToElement(AllLanguages,pro::ReadArguments('_pro-language')) <> '' THEN
                    CurrentLanguage := StringToElement(AllLanguages,pro::ReadArguments('_pro-language'));
            ENDIF;
            
            RETURN 1;
        }
        Parameter ret;
    }
    Procedure LibraryTermination {
        Body: {
            return 1 ;
        }
    }
}
