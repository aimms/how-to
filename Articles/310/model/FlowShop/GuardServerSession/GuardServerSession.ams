## ams_version=1.0

LibraryModule Library_GuardServerSession {
	Prefix: gss;
	Interface: Public_Section;
	RequiredUnits: SI_Time_Duration::s, SI_Time_Duration::minute, SI_Time_Duration::hour;
	Comment: {
		"Requirements:
		- Declaration of time, preferably as SI_Time_Duration, including unit s.
		- System library AIMMS PRO
		- Repository library DataExchange
		- AIMMS 4.79 or later
		
		Test WebUI and WinUI apps in Cloud/Prem/Developer"
	}
	Section Public_Section {
		Procedure pr_actionTemplate {
			Body: {
				gss::pr_enter(sp_gssTime, p_gssMiU, ep_messageImportance: 'info');
				block 
					! Call procedure to do the actual work.
				onerror ep_err do
					gss::pr_appendError( ep_err );
					errh::MarkAsHandled( ep_err );
				endblock ;
				gss::pr_leave(sp_gssTime, p_gssMiU, ep_messageImportance: 'info');
			}
			Comment: "Sample action procedure";
			DeclarationSection gss_logging_declarations {
				StringParameter sp_gssTime;
				Parameter p_gssMiU;
			}
			DeclarationSection error_reference_declaration {
				ElementParameter ep_err {
					Range: errh::PendingErrors;
				}
			}
		}
		Section Settings {
			Set s_Settings {
				Index: i_setting;
				Definition: {
					data { 
						DownloadFolder ! Setting for downloads of files (in WinUI only).
					}
				}
			}
			StringParameter sp_settingValue {
				IndexDomain: i_setting;
			}
			Procedure pr_setSetting {
				Arguments: (ep_setting,sp_value);
				Body: {
					gss::pr_enter(sp_gssTime, p_gssMiU, ep_messageImportance: 'debug', 
						sp_logdetail:formatString("(%e, %s)", ep_setting, sp_value));
					switch ep_setting do
						'DownloadFolder': sp_settingValue('DownloadFolder') := sp_value ;
						default:
							raise warning formatString("Setting for %s not implemented",ep_setting) ;
					endswitch ;
					gss::pr_leave(sp_gssTime, p_gssMiU, ep_messageImportance: 'debug');
				}
				DeclarationSection gss_logging_declarations {
					StringParameter sp_gssTime;
					Parameter p_gssMiU;
				}
				ElementParameter ep_setting {
					Range: s_Settings;
					Property: Input;
				}
				StringParameter sp_value {
					Property: Input;
				}
			}
			Procedure pr_getSetting {
				Arguments: (ep_setting,sp_value);
				Body: {
					gss::pr_enter(sp_gssTime, p_gssMiU, ep_messageImportance: 'debug');
					switch ep_setting do
						'DownloadFolder': sp_value := sp_settingValue('DownloadFolder');
						default:
							raise warning formatString("Setting for %s not implemented",ep_setting) ;
					endswitch ;
					gss::pr_leave(sp_gssTime, p_gssMiU, ep_messageImportance: 'debug', 
						sp_logdetail:formatString("(%e, %s)", ep_setting, sp_value));
				}
				ElementParameter ep_setting {
					Range: s_Settings;
					Property: Input;
				}
				StringParameter sp_value {
					Property: Output;
				}
			}
			DeclarationSection gss_logging_declarations {
				StringParameter sp_gssTime;
				Parameter p_gssMiU;
			}
		}
		Section Incident_reporting {
			Property: NoSave;
			Procedure pr_openIncidentSummary {
				Body: {
					gss::pr_enter(sp_gssTime, p_gssMiU, ep_messageImportance: 'info');
					block 
						! Call procedure to do the actual work.
						webui::OpenDialogPage(
							pageId  :  'gss_incident_report', 
							title   :  "Incident report dialog", 
							actions :  s_incidentSummaryActions, 
							onDone  :  'gss::pr_incidentSummaryOndone');
					onerror ep_err do
						gss::pr_appendError( ep_err );
						errh::MarkAsHandled( ep_err );
					endblock ;
					gss::pr_leave(sp_gssTime, p_gssMiU, ep_messageImportance: 'info');
				}
				Comment: "Invoked via status bar. It will open a dialog where a user can write up some details and submit.";
				DeclarationSection gss_logging_declarations {
					StringParameter sp_gssTime;
					Parameter p_gssMiU;
				}
				DeclarationSection error_reference_declaration {
					ElementParameter ep_err {
						Range: errh::PendingErrors;
					}
				}
			}
			Procedure pr_incidentSummaryOndone {
				Arguments: (sp_action);
				Body: {
					gss::pr_enter(sp_gssTime, p_gssMiU, ep_messageImportance: 'info', sp_logDetail: sp_action);
					block 
						! Nothing to do.
					onerror ep_err do
						gss::pr_appendError( ep_err );
						errh::MarkAsHandled( ep_err );
					endblock ;
					gss::pr_leave(sp_gssTime, p_gssMiU, ep_messageImportance: 'info', sp_logDetail: sp_action);
				}
				Comment: "Invoked by OnDone in the WebUI dialog page.";
				DeclarationSection gss_logging_declarations {
					StringParameter sp_gssTime;
					Parameter p_gssMiU;
					StringParameter sp_action {
						Property: Input;
					}
				}
				DeclarationSection error_reference_declaration {
					ElementParameter ep_err {
						Range: errh::PendingErrors;
					}
				}
			}
			Procedure pr_downloadIncidentSummary {
				Arguments: (fileLocation,statusCode,statusDescription);
				Body: {
					gss::pr_enter(sp_gssTime, p_gssMiU, ep_messageImportance: 'info');
					block
					
						gss::pr_initErrorHandlingDownloadUploadButtons( ep_stat, statusCode,  statusDescription, bp_download:1 );
					
						pr_workCreateIncidentSummary(/* output */ fileLocation);
						sp_finalLocation := webui::GetIOFilePath(fileLocation);
						if fileLocation <> sp_finalLocation then
							if not FileCopy( fileLocation, sp_finalLocation ) then
								raise error formatString("downloadIncidentSummary() Error copying file %s: %s",
									fileLocation, CurrentErrorMessage );
							endif ;
						endif ;
					
						! checking if the previous write statement was successful or not
						if not FileExists(sp_finalLocation) then
							raise error FormatString("Error creating error data file %s", sp_finalLocation );
						endif;
					
						! if successful, statusCode is set to 'CREATED' which will trigger the download widget to show the Get button
						StatusCode := webui::ReturnStatusCode('CREATED');
						! displaying the status message as All perfect instead of the default "File ready to download"
						StatusDescription := "Succesfully downloaded error data file to " + fileLocation ;
					
					onerror ep_err do
					
						gss::pr_appendError(ep_err);
						gss::pr_uploadDownloadWidgetErrorHandling( ep_err, ep_stat, statusCode, statusDescription); 
					
						errh::MarkAsHandled(ep_err);
					
					endblock ;
					gss::pr_leave(sp_gssTime, p_gssMiU, ep_messageImportance: 'info');
				}
				Comment: "Download Incident Summary / Session History.";
				StringParameter fileLocation {
					Property: Output;
				}
				Parameter statusCode {
					Property: Output;
				}
				StringParameter statusDescription {
					Property: Output;
				}
				StringParameter sp_finalLocation;
				ElementParameter ep_stat {
					Range: errh::AllErrorSeverities;
				}
				ElementParameter ep_err {
					Range: errh::PendingErrors;
				}
				DeclarationSection gss_logging_declarations {
					StringParameter sp_gssTime;
					Parameter p_gssMiU;
				}
			}
			Procedure pr_downloadIncidentSummaryWinUI {
				Body: {
					gss::pr_enter(sp_gssTime, p_gssMiU, ep_messageImportance: 'info');
					block 
						pr_getDownloadFolder(sp_downloadFolder);
						if not DirectoryExists( sp_downloadFolder ) then
							if not directorySelect( sp_downloadFolder ) then
								raise error 
									formatString("User cancelled or error: %s", CurrentErrorMessage);
							endif ;
						endif ;
						pr_workCreateIncidentSummary(sp_createdFile);
						sp_filename := sp_downloadFolder + "\\" + sp_createdFile ;
						sp_filename := fnc_nonExistingFilename( sp_filename );
						FileCopy( sp_createdFile, sp_filename );
					onerror ep_err do
						gss::pr_appendError( ep_err );
						errh::MarkAsHandled( ep_err );
					endblock ;
					gss::pr_leave(sp_gssTime, p_gssMiU, ep_messageImportance: 'info');
				}
				DeclarationSection local_declarations {
					StringParameter sp_downloadFolder;
					StringParameter sp_createdFile;
					StringParameter sp_filename;
				}
				DeclarationSection gss_logging_declarations {
					StringParameter sp_gssTime;
					Parameter p_gssMiU;
				}
				DeclarationSection error_reference_declaration {
					ElementParameter ep_err {
						Range: errh::PendingErrors;
					}
				}
			}
			Procedure pr_buttonSessionHistoryManagementWinUI {
				Body: {
					if ProjectDeveloperMode() then
						PageOpen("GSS Session History Management");
					else
						PageOpen("GSS Incident Summary");
					endif ;
				}
			}
			Procedure pr_clearDataSessionErrors {
				Body: {
					empty sp_dataSessionErrorMessages, sp_dataSessionErrorMoments,
						ep_dataSessionErrorSeverity, ep_dataSessionErrorNodes,
						ep_dataSessionErrorAttributes, p_dataSessionErrorLines ;
					ep_dataSessionIncident := '' ;
				}
			}
			Set s_incidentSummaryActions {
				Definition: data { Cancel, Submit };
				Comment: "helper set for WebUI Incident summary dialog";
			}
			StringParameter sp_incidentSummaryTitle {
				Definition: "Please summarize the incident below";
				Comment: "Title for scalar widget in WebUI Incident Summary dialog.";
			}
			StringParameter sp_incidentSummarySuppliedByEndUser {
				InitialData: {
					"You can replace this text with a summary of the actual problem.\n" 
					"Tip: be explicit about what you did not expect."
				}
				Comment: {
					"Text entered by end-user about what was unexpected.
					Used in the incident summary dialog."
				}
			}
			StringParameter sp_titleDowloadIncidentSummary {
				Definition: "Download incident summary";
			}
			StringParameter sp_titleClearDataSessionErrors {
				Definition: "Clear all these errors and warnings";
			}
		}
		Section WebUI_Support {
			Property: NoSave;
			StringParameter sp_widgetActionMessageList {
				IndexDomain: (webui::indexPageExtension, webui::indexWidgetActionSpec);
				Property: NoSave;
				Definition: {
					{
						('1', 'displaytext' ) : "Model explorer",  
						('1', 'icon'        ) : "aimms-glasses",  
						('1', 'procedure'   ) : "gss::pr_OpenIdentifierOnMessageList",  
						('1', 'state'       ) : "Active"  
					}
				}
				Comment: "Definition of the menu for table ErrorWarningMessageTable on page \"GSS Session History Management\".";
			}
			StringParameter sp_itemActionMessageList {
				IndexDomain: (webui::indexWidgetItemActionSpec, webui::indexPageExtension, webui::indexWidgetActionSpec);
				Definition: {
					{
						('gss::ep_shownJobErrorSeverity', '1', 'displaytext' ) : "Model explorer",  
						('gss::ep_shownJobErrorSeverity', '1', 'icon'        ) : "aimms-glasses",  
						('gss::ep_shownJobErrorSeverity', '1', 'procedure'   ) : "gss::pr_OpenIdentifierOnStack",  
						('gss::ep_shownJobErrorSeverity', '1', 'state'       ) : "Active" ,
					
						('gss::sp_shownJobErrorMoments',  '1', 'displaytext' ) : "Model explorer",  
						('gss::sp_shownJobErrorMoments',  '1', 'icon'        ) : "aimms-glasses",  
						('gss::sp_shownJobErrorMoments',  '1', 'procedure'   ) : "gss::pr_OpenIdentifierOnStack",  
						('gss::sp_shownJobErrorMoments',  '1', 'state'       ) : "Active" ,
					
						('gss::sp_shownJobErrorMessages',  '1', 'displaytext' ) : "Model explorer",  
						('gss::sp_shownJobErrorMessages',  '1', 'icon'        ) : "aimms-glasses",  
						('gss::sp_shownJobErrorMessages',  '1', 'procedure'   ) : "gss::pr_OpenIdentifierOnStack",  
						('gss::sp_shownJobErrorMessages',  '1', 'state'       ) : "Active" 
					
					}
				}
				Comment: "Defines the item actions on the table ErrorWarningMessageTable on page \"GSS Session History Management\"";
			}
			StringParameter sp_widgetActionMessageStack {
				IndexDomain: (webui::indexPageExtension, webui::indexWidgetActionSpec);
				Definition: {
					{
						('1', 'displaytext' ) : "Model explorer",  
						('1', 'icon'        ) : "aimms-glasses",  
						('1', 'procedure'   ) : "gss::pr_OpenIdentifierOnStack",  
						('1', 'state'       ) : "Active"  
					}
				}
				Comment: "Defines the menu of the table ErrorWarningStack on the \"GSS Session History Management\" page.";
			}
			StringParameter sp_itemActionMessageStack {
				IndexDomain: (webui::indexWidgetItemActionSpec, webui::indexPageExtension, webui::indexWidgetActionSpec);
				Definition: {
					
					
					{
						('gss::ep_shownJobErrorNodes',     '1', 'displaytext' ) : "Model explorer",  
						('gss::ep_shownJobErrorNodes',     '1', 'icon'        ) : "aimms-glasses",  
						('gss::ep_shownJobErrorNodes',     '1', 'procedure'   ) : "gss::pr_OpenIdentifierOnMessageList",  
						('gss::ep_shownJobErrorNodes',     '1', 'state'       ) : "Active",
					
						('gss::ep_shownJobErrorAttributes', '1', 'displaytext' ) : "Model explorer",  
						('gss::ep_shownJobErrorAttributes', '1', 'icon'        ) : "aimms-glasses",  
						('gss::ep_shownJobErrorAttributes', '1', 'procedure'   ) : "gss::pr_OpenIdentifierOnMessageList",  
						('gss::ep_shownJobErrorAttributes', '1', 'state'       ) : "Active",
					
						('gss::p_shownJobErrorLines',       '1', 'displaytext' ) : "Model explorer",  
						('gss::p_shownJobErrorLines',       '1', 'icon'        ) : "aimms-glasses",  
						('gss::p_shownJobErrorLines',       '1', 'procedure'   ) : "gss::pr_OpenIdentifierOnMessageList",  
						('gss::p_shownJobErrorLines',       '1', 'state'       ) : "Active"  
					}
				}
				Comment: "Defines the item actions for the table ErrorWarningStack on the \"GSS Session History Management\" page";
			}
			StringParameter sp_widgetActionIdentifierProfiler {
				IndexDomain: (webui::indexPageExtension, webui::indexWidgetActionSpec);
				Definition: {
					{
						('1', 'displaytext' ) : "Model explorer",  
						('1', 'icon'        ) : "aimms-glasses",  
						('1', 'procedure'   ) : "gss::pr_OpenProfiledIdentifier",  
						('1', 'state'       ) : "Active"  
					}
				}
				Comment: "Defines the widget actions for table JobProfilerData";
			}
			StringParameter sp_itemActionIdentifierProfiler {
				IndexDomain: (webui::indexWidgetItemActionSpec, webui::indexPageExtension, webui::indexWidgetActionSpec);
				Definition: {
					{
						('gss::p_shownJobProfilerHits', '1', 'displaytext' ) : "Model explorer",  
						('gss::p_shownJobProfilerHits', '1', 'icon'        ) : "aimms-glasses",  
						('gss::p_shownJobProfilerHits', '1', 'procedure'   ) : "gss::pr_OpenProfiledIdentifier",  
						('gss::p_shownJobProfilerHits', '1', 'state'       ) : "Active" ,
					
						('gss::p_shownJobProfilerGross', '1', 'displaytext' ) : "Model explorer",  
						('gss::p_shownJobProfilerGross', '1', 'icon'        ) : "aimms-glasses",  
						('gss::p_shownJobProfilerGross', '1', 'procedure'   ) : "gss::pr_OpenProfiledIdentifier",  
						('gss::p_shownJobProfilerGross', '1', 'state'       ) : "Active" ,
					
						('gss::p_shownJobProfilerNetto', '1', 'displaytext' ) : "Model explorer",  
						('gss::p_shownJobProfilerNetto', '1', 'icon'        ) : "aimms-glasses",  
						('gss::p_shownJobProfilerNetto', '1', 'procedure'   ) : "gss::pr_OpenProfiledIdentifier",  
						('gss::p_shownJobProfilerNetto', '1', 'state'       ) : "Active" 
					
					
					
					}
				}
				Comment: "Defines the item actions for the table JobProfilerData on page \"GSS Session History Management\"";
			}
			StringParameter sp_messageStatusBar {
				IndexDomain: (webui::indexApplicationExtension,webui::indexStatusBarSpec);
				Definition: {
					{
					
						('3', 'header'    ) : "",  
						('3', 'icon'      ) : "",  
						('3', 'color'     ) : "",  
						('3', 'text'      ) : sp_lastSessionNotification,  
						('3', 'tooltip'   ) : "",  
						('3', 'procedure' ) : "",  
						('3', 'state'     ) : 
							if sp_lastSessionNotification = "-" then "Hidden" else "Active" endif,
					
						( '4', 'header'    ) : "",  
						( '4', 'icon'      ) : "",
						( '4', 'color'     ) : "",
						( '4', 'text'      ) : "Paths" , 
						( '4', 'tooltip'   ) : 
							"<table>" +
								"<TR>" +
									"<TD>" + "Current: " + "</TD>"  +
									"<TD>" + sp_currentFolder + "</TD>"  +
								"</TR>" +
								"<TR>" +
									"<TD>" + "Startup: " + "</TD>"  +
									"<TD>" + sp_startupFolder + "</TD>"  +
								"</TR>" +
								"<TR>" +
									"<TD>" + "PRO_TEMP: " + "</TD>"  +
									"<TD>" + pro::GetPROTempFolder  + "</TD>"  +
								"</TR>" +
								"<TR>" +
									"<TD>" + "BucketBasePath: " + "</TD>"  +
									"<TD>" + pro::session::BucketBasePath  + "</TD>"  +
								"</TR>" +
							"</table>",
						( '4', 'procedure' ) : "gss::pr_getCurDir",
						( '4', 'state'     ) : "Inactive" , 
					
						( '5', 'header'    ) : "",  
						( '5', 'icon'      ) : "aimms-chip" ,
						( '5', 'color'     ) :  
							if p_memoryInUse > 3500 then "red"  
							elseif p_memoryInUse > 3000  then "orange"   
							else "green" 
							endif,
						( '5', 'text'      ) : 
							FormatString("There is %n Mb in use (peak: %n Mb)", 
								p_memoryInUse, p_peakMemoryInUse ), 
						( '5', 'tooltip'   ) : "",
						( '5', 'procedure' ) : "",
						( '5', 'state'     ) : "Active" , 
					
						( '6', 'header'    ) : "",  
						( '6', 'icon'      ) :  
							if gss::p_noErrors then "aimms-sad"   
							elseif gss::p_noWarnings then "aimms-wondering" 
							else "aimms-smile" 
							endif, 
						( '6', 'color'     ) :  
							if gss::p_noErrors  then "red"  
							elseif gss::p_noWarnings then "orange"   
							else "green" 
							endif,
						( '6', 'text'      ) :  
							FormatString("%i warnings and %i errors", 
								gss::p_noWarnings, gss::p_noErrors ), 
						( '6', 'tooltip'   ) :  
							if gss::p_noSignificantMessages then "Please visit the page \"GSS Session History Management\" for details on the warnings and errors" 
							else "Don't worry, be happy" 
							endif,                
						( '6', 'procedure' ) :  
							if bp_isConnectedToPro then
								"gss::pr_openIncidentSummary"
							else
								"gss::pr_openErrorHandlingPage"
							endif,
						( '6', 'state'     ) : "Active"  
					
					
					
					}
				}
				Comment: "The message";
			}
			StringParameter sp_titleErrorWarningMessagesTable {
				Definition: {
					formatString("Error and warning messages for %s: %e", sp_shownSessionDescription,
					gss::ep_shownSession)
				}
				Comment: "The title of the table \"ErrorWarningMessageTable\" on page \"GSS Session History Management\".";
			}
			StringParameter sp_titleStackMessage {
				Definition: FormatString("Stack of \"%s\"", sp_shownJobErrorMessages( ep_errorWarningSelectedMessage ) );
				Comment: "Title for the table \"ErrorWarningStack\" on page \"GSS Session History Management\"";
			}
			StringParameter sp_titleProfilerDetail {
				Definition: FormatString("Profiler data for %e", ep_profilerDataSelectedIdentifier);
				Comment: "The title for the table LineBasedProfilerData on page \"GSS Session History Management\".";
			}
			StringParameter sp_titleProfilerOverview {
				Definition: "Identifier based Profiler Data [s]";
			}
			StringParameter sp_titleDownloadActionLog {
				Definition: formatString("Download model log file of selected session: %e", gss::ep_shownSession);
			}
			StringParameter sp_titleDownloadErrorReport {
				Definition: formatString("Download error report of selected session:%e", gss::ep_shownSession);
			}
			ElementParameter ep_profilerDataSelectedIdentifier {
				Range: AllIdentifiers;
				InitialData: '';
				Comment: {
					"Links the tables JobProfilerData and LineBasedProfilerData
					Via store focus in table JobProfilerData ep_profilerSelectedData is set
					Via identifier settings in table LineBasedProfilerData the profiler details of that procedure are shown."
				}
			}
			ElementParameter ep_errorWarningSelectedMessage {
				Range: s_jobErrorMessageNumbers;
				InitialData: '';
				Comment: {
					"Links the tables ErrorWarningMessageTable and ErrorWarningStack on page \"GSS Session History Management\"
					- In table ErrorWarningMessageTable it is a store focus on the message selected.
					- In table ErrorWarningStack it is used to slice on the selected message."
				}
			}
			StringParameter sp_sidePanel {
				IndexDomain: (webui::indexPageExtension, webui::indexSidePanelSpec);
				Definition: {
					{ 
						( '1', 'displayText' ) : "Settings",
					  	( '1', 'pageId'      ) : "sp_controls_1",
					  	( '1', 'tooltip'     ) : "Control displayed session",
					  	( '1', 'state'       ) : "active" 
					}
				}
			}
			ElementParameter ep_stackPos {
				Range: s_stackPositions;
				InitialData: '';
				Comment: {
					"In table \"ErrorWarningStack\" on page \"GSS Session History Management\", it is used to store the selected position on the stack.
					In procedure gss::pr_openIdentifierOnStack it is used to select the attribute window to open."
				}
			}
			Set s_messageLevels {
				Index: i_messageLevel;
				Definition: {
					data { trace, debug, info, warn, error, fatal } ;
				}
				Comment: "The message levels for tracing";
			}
			Set s_lineNumbers {
				SubsetOf: Integers;
				Index: i_lineNumber;
				Definition: ElementRange(0,10000);
				Comment: "Used for profiler data, line number index.";
			}
			Set s_positiveLineNumbers {
				SubsetOf: s_lineNumbers;
				Index: i_positiveLineNumber;
				Definition: ElementRange(1,1000);
				Comment: "Used for profiling data, see";
			}
			Set s_actualLinenumbers {
				SubsetOf: s_lineNumbers;
				Index: i_actualLineNumber;
				Definition: ElementRange(1,if ep_lastHitLine then ep_lastHitLine else 1 endif);
			}
			Set s_stackPositions {
				SubsetOf: Integers;
				Index: i_stackPosition;
				Definition: ElementRange(1,255);
			}
			Procedure pr_openErrorHandlingPage {
				Body: {
					block 
						webui::OpenPage(pageId : 'gss_session_history_management' );
					onerror ep_err do
						pr_appendError( ep_err );
						errh::MarkAsHandled( ep_err );
					endblock ;
				}
				Comment: "Opens the page \"GSS Session History Management\" upon clicking the GSS notification/status bar (at the bottom of the screen).";
				ElementParameter ep_err {
					Range: errh::PendingErrors;
				}
			}
			Procedure pr_openPageErrorWarningProfiler {
				Body: {
					pr_enter(sp_gssTime, p_gssMiU, ep_messageImportance: 'info');
					
					ep_shownSession := first( s_trackedSessions );
					pr_storeErrorProfilerDataFromDataSessionInTrackedSessions();
					pr_showSelectedSessionInUI();
					
					pr_leave(sp_gssTime, p_gssMiU, ep_messageImportance: 'info');
				}
				Comment: "The procedure that is run upon opening the page \"GSS Session History Management\"";
				DeclarationSection gss_logging_declarations {
					StringParameter sp_gssTime;
					Parameter p_gssMiU;
				}
				DeclarationSection error_reference_declaration {
					ElementParameter ep_err {
						Range: errh::PendingErrors;
					}
				}
			}
		}
		Section PRO_Support {
			Set s_inputCaseIdentifiers {
				SubsetOf: AllIdentifiers;
				Definition: controlServerSessionData;
				Comment: {
					"The set of identifiers in the GSS library that should be part of an \"input case\". 
					The \"input case\" is the case transferred from the client session to the solver session upon start of the solver session.
					Please ensure that pro::ManagedSessionInputCaseIdentifierSet contains the data from s_inputCaseIdentifiers"
				}
			}
			Set s_outputCaseIdentifiers {
				SubsetOf: AllIdentifiers;
				Definition: serverSessionErrorData;
				Comment: {
					"The data in the GSS library that is to be added to the output case.
					The output case is the case transferred from a solver session to the data session upon completion of that solver session.
					Please ensure that the set pro::ManagedSessionOutputCaseIdentifierSet contains the elements from 
					s_outputCaseIdentifiers before the delegated procedure returns in each solver session."
				}
			}
		}
		Section Guarding {
			Comment: "This section is about guarding server sessions and managing error data.";
			Section GSS_Error_WebUI_Support {
				Property: NoSave;
				DeclarationSection Declaration_selection_shown_session {
					ElementParameter ep_shownSession {
						Range: s_trackedSessions;
						InitialData: '';
						Comment: "By convention, if the shown session is the first then the running data session is selected.";
						webui::UponChangeProcedure: pr_uponChangeShownSession;
					}
				}
				Procedure pr_uponChangeShownSession {
					Body: {
						gss::pr_enter(sp_gssTime, p_gssMiU, ep_messageImportance: 'info', 
							formatString("Going to show %e", 
								ep_shownSession));
						block 
							pr_showSelectedSessionInUI();
						onerror ep_err do
							pr_appendError( ep_err );
							errh::MarkAsHandled( ep_err );
						endblock ;
						gss::pr_leave(sp_gssTime, p_gssMiU, ep_messageImportance: 'info', 
							formatString("Now the error and profiler tables show %e with description %s", 
								ep_shownSession, sp_shownSessionDescription));
					}
					Comment: {
						"This procedure takes care of the following:
						When the element parameter ep_shownSession is modified in the dropdown, 
						the contents of all tables on page \"GSS Session History Management\" should be adapted accordingly."
					}
					DeclarationSection gss_logging_declarations {
						StringParameter sp_gssTime;
						Parameter p_gssMiU;
					}
					ElementParameter ep_err {
						Range: errh::PendingErrors;
					}
				}
				DeclarationSection Shown_session_data_exchange {
					StringParameter sp_shownSessionDescription {
						InitialData: "";
						Comment: {
							"- When the shown session is the data session, then the phrase \"data session\"
							- When the shown session is a solver session, then the description (if any) of that solver session.
							This string parameter is used in titles and so on."
						}
					}
					Parameter p_shownJobProfilerData {
						IndexDomain: (IndexIdentifiers,i_lineNumber,IndexProfilerTypes );
						InitialData: data {};
						Comment: "The profiler data shown on the \"GSS Session History Management\" page in the tables JobProfilerData and LineBasedProfilerData.";
					}
					StringParameter sp_shownJobErrorMessages {
						IndexDomain: i_jobErrorMessageNumber;
						Comment: "The error messages shown in the table ErrorWarningMessageTable on page \"GSS Session History Management\"";
					}
					StringParameter sp_shownJobErrorMoments {
						IndexDomain: i_jobErrorMessageNumber;
						Comment: "The moment the error was recorded for each of the errors in the table ErrorWarningMessageTable on the page \"GSS Session History Management\"";
					}
					ElementParameter ep_shownJobErrorSeverity {
						IndexDomain: i_jobErrorMessageNumber;
						Range: s_messageLevels;
						Comment: "The severity of the error for each of the errors in the table \"ErrorWarningMessageTable\" on the page \"GSS Session History Management\".";
					}
					ElementParameter ep_shownJobErrorNodes {
						IndexDomain: (i_jobErrorMessageNumber,i_stackPosition);
						Range: AllSymbols;
						Comment: "For the selected error / warning the identifiers on the execution stack in the table \"ErrorWarningStack\" on page \"GSS Session History Management\"";
					}
					ElementParameter ep_shownJobErrorAttributes {
						IndexDomain: (i_jobErrorMessageNumber,i_stackPosition);
						Range: AllAttributeNames;
						Comment: {
							"The active attribute of the identifiers that are on the execution stack shown 
							in the table \"ErrorWarningStack\" on the page \"GSS Session History Management\""
						}
					}
					Parameter p_shownJobErrorLines {
						IndexDomain: (i_jobErrorMessageNumber,i_stackPosition);
						Comment: {
							"The active line of the identifiers that are on the execution stack shown 
							in the table \"ErrorWarningStack\" on the page \"GSS Session History Management\""
						}
					}
				}
				DeclarationSection Shown_profiler_columns {
					Parameter p_shownJobProfilerHits {
						IndexDomain: (IndexIdentifiers,i_lineNumber );
						Definition: p_shownJobProfilerData(IndexIdentifiers, gss::i_lineNumber, 'hits');
						Comment: "The profiler data shown on the \"GSS Session History Management\" page in the tables JobProfilerData and LineBasedProfilerData.";
					}
					Parameter p_shownJobProfilerNetto {
						IndexDomain: (IndexIdentifiers,i_lineNumber );
						Definition: p_shownJobProfilerData(IndexIdentifiers, gss::i_lineNumber, 'net time');
						Comment: "The profiler data shown on the \"GSS Session History Management\" page in the tables JobProfilerData and LineBasedProfilerData.";
					}
					Parameter p_shownJobProfilerGross {
						IndexDomain: (IndexIdentifiers,i_lineNumber );
						Definition: p_shownJobProfilerData(IndexIdentifiers, gss::i_lineNumber, 'gross time');
						Comment: "The profiler data shown on the \"GSS Session History Management\" page in the tables JobProfilerData and LineBasedProfilerData.";
					}
				}
			}
			Section Tracked_sessions {
				Property: NoSave;
				Comment: {
					"This section collects the error and profiler data coming from 
					data session, solver sessions and from uploaded sessions."
				}
				DeclarationSection tracked_sessions_error_and_profiler_data {
					Set s_trackedSessions {
						Index: i_trackedSession;
						Comment: "The names of all sessions tracked.";
					}
					StringParameter sp_trackedSessionDescription {
						IndexDomain: i_trackedSession;
						Definition: {
							if i_trackedSession = first( s_trackedSessions ) then
								formatString("%e : data session", i_trackedSession )
							else
								formatString("%e : %s",
									i_trackedSession, 
									sp_sessionGivenDescriptions( i_trackedSession ) )
							endif
						}
						Comment: {
							"The element description is the name of the sessio ( a guid ) extended with the description of the job given 
							by the call to pro::DelegateServer"
						}
					}
					StringParameter sp_sessionGivenDescriptions {
						IndexDomain: i_trackedSession;
						InitialData: data {};
						Comment: "Maintain the description given of the sessions collected.";
					}
					Parameter p_trackedJobProfilerData {
						IndexDomain: (i_trackedSession,IndexIdentifiers,i_lineNumber,IndexProfilerTypes );
						InitialData: data{};
						Comment: "Jobprofiler data, now per tracked session";
					}
					StringParameter sp_trackedJobErrorMessages {
						IndexDomain: (i_trackedSession,i_jobErrorMessageNumber);
						InitialData: data {};
						Comment: "Error messages, per tracked session";
					}
					StringParameter sp_trackedJobErrorMoments {
						IndexDomain: (i_trackedSession,i_jobErrorMessageNumber);
						InitialData: data {};
						Comment: "tracked per session, the moments the error occurred";
					}
					ElementParameter ep_trackedJobErrorSeverity {
						IndexDomain: (i_trackedSession,i_jobErrorMessageNumber);
						Range: s_messageLevels;
						InitialData: data {};
						Comment: "Tracked per session, the severity of each error";
					}
					ElementParameter ep_trackedJobErrorNodes {
						IndexDomain: (i_trackedSession,i_jobErrorMessageNumber,i_stackPosition);
						Range: AllSymbols;
						InitialData: data{};
						Comment: "Tracked per session, the stack of identifiers";
					}
					ElementParameter ep_trackedJobErrorAttributes {
						IndexDomain: (i_trackedSession,i_jobErrorMessageNumber,i_stackPosition);
						Range: AllAttributeNames;
						InitialData: data {};
						Comment: "Tracked per session, the stack of attribes per error";
					}
					Parameter p_trackedJobErrorLines {
						IndexDomain: (i_trackedSession,i_jobErrorMessageNumber,i_stackPosition);
						InitialData: data {};
						Comment: "Tracked per session, per error, the stack of line numbers";
					}
				}
				Procedure pr_saveTrackedSessionData {
					Arguments: (sp_sessionID);
					Body: {
						if not sp_sessionID then
							raise error "pr_saveTrackedSessionData() unable to store session data without identification" ;
						endif ;
						ep_trackedSession := stringToElement( s_trackedSessions, sp_sessionID, create:1);
						if not ep_trackedSession then
							raise error "pr_saveTrackedSessionData() unable to create effective session id";
						endif ;
						pr_logMsg("s_trackedSessions = "+s_trackedSessions);
						
						p_trackedJobProfilerData(ep_trackedSession, IndexIdentifiers, i_lineNumber, IndexProfilerTypes) := p_jobProfilerData(IndexIdentifiers, i_lineNumber, IndexProfilerTypes);
						
						sp_trackedJobErrorMessages(ep_trackedSession, i_jobErrorMessageNumber) := sp_jobErrorMessages(i_jobErrorMessageNumber);
						sp_trackedJobErrorMoments( ep_trackedSession, i_jobErrorMessageNumber) := sp_jobErrorMoments( i_jobErrorMessageNumber);
						ep_trackedJobErrorSeverity(ep_trackedSession, i_jobErrorMessageNumber) := ep_jobErrorSeverity(i_jobErrorMessageNumber);
						
						ep_trackedJobErrorNodes(     ep_trackedSession, i_jobErrorMessageNumber, i_stackPosition) := ep_jobErrorNodes(     i_jobErrorMessageNumber, i_stackPosition);
						ep_trackedJobErrorAttributes(ep_trackedSession, i_jobErrorMessageNumber, i_stackPosition) := ep_jobErrorAttributes(i_jobErrorMessageNumber, i_stackPosition);
						p_trackedJobErrorLines(      ep_trackedSession, i_jobErrorMessageNumber, i_stackPosition) := p_jobErrorLines(      i_jobErrorMessageNumber, i_stackPosition);
					}
					StringParameter sp_sessionID {
						Property: Input;
					}
					ElementParameter ep_trackedSession {
						Range: s_trackedSessions;
					}
				}
				Procedure pr_uploadErrorData {
					Arguments: (fileLocation,statusCode,statusDescription);
					Body: {
						gss::pr_enter(sp_gssTime, p_gssMiU, ep_messageImportance: 'info');
						block
							pr_logMsg(formatString("Uploading file %s", fileLocation),'info');
							sp_fileUploadLocation := webui::GetIOFilePath(fileLocation);
							! The file is uploaded to the process specific temporary folder. 
						
							pr_uploadErrorDataWork( sp_fileUploadLocation );
						
							statusCode := webui::ReturnStatusCode('OK');
							statusDescription := "Succesfully uploaded file "+fileLocation;
						onerror ep_err do
							gss::pr_appendError(ep_err);
							errh::MarkAsHandled(ep_err);
							if errh::Severity(ep_err) <> 'warning' then
								statusCode := webui::ReturnStatusCode('ERROR');
								statusDescription := "Failed to upload file " + fileLocation ;
							endif ;
						endblock ;
						gss::pr_leave(sp_gssTime, p_gssMiU, ep_messageImportance: 'info');
					}
					DeclarationSection gss_logging_declarations {
						StringParameter sp_gssTime;
						Parameter p_gssMiU;
					}
					DeclarationSection error_reference_declaration {
						ElementParameter ep_err {
							Range: errh::PendingErrors;
						}
					}
					StringParameter fileLocation {
						Property: Input;
					}
					Parameter statusCode {
						Property: Output;
					}
					StringParameter statusDescription {
						Property: Output;
					}
					StringParameter sp_fileUploadLocation;
				}
				Procedure pr_uploadErrorDataWinUI {
					Body: {
						pr_enter(sp_gssTime, p_gssMiU, ep_messageImportance: 'info');
						block 
							p_retFileSelect := FileSelect(
								filename  :  sp_filename, 
								directory :  "", 
								extension :  ".errors", 
								title     :  "Please select error and profiler file");
							if p_retFileSelect then
								pr_uploadErrorDataWork( sp_filename);
							else
								raise warning "No file selected for uploading error and profiler data";
							endif ;
						onerror ep_err do
							gss::pr_appendError( ep_err );
							errh::MarkAsHandled( ep_err );
						endblock ;
						pr_leave(sp_gssTime, p_gssMiU, ep_messageImportance: 'info');
					}
					Comment: "Upload error and profiler data procedure Used in WinUI GSS Session History Management page";
					DeclarationSection gss_logging_declarations {
						StringParameter sp_gssTime;
						Parameter p_gssMiU;
					}
					DeclarationSection error_reference_declaration {
						ElementParameter ep_err {
							Range: errh::PendingErrors;
						}
					}
					StringParameter sp_fileName;
					Parameter p_retFileSelect;
				}
				Procedure pr_downloadErrorData {
					Arguments: (fileLocation,statusCode,statusDescription);
					Body: {
						gss::pr_enter(sp_gssTime, p_gssMiU, ep_messageImportance: 'info');
						block
						
							gss::pr_initErrorHandlingDownloadUploadButtons( ep_stat, statusCode,  statusDescription, bp_download:1 );
						
							fileLocation := formatString("%e.errors", ep_shownSession );
						
							! we store the location of the file in string parameter sp_FinalLocation
							sp_finalLocation := webui::GetIOFilePath(fileLocation);
						
							! writing the string parameter FinalLocation to a text file
							sp_shownSessionDescription := sp_sessionGivenDescriptions( ep_shownSession );
							pr_downloadErrorDataWork( sp_finalLocation );
						
							! checking if the previous write statement was successful or not
							if not FileExists(sp_finalLocation) then
								raise error FormatString("Error creating error data file %s", sp_finalLocation );
							endif;
						
							! if successful, statusCode is set to 'CREATED' which will trigger the download widget to show the Get button
							StatusCode := webui::ReturnStatusCode('CREATED');
							! displaying the status message as All perfect instead of the default "File ready to download"
							StatusDescription := "Succesfully downloaded error data file to " + fileLocation ;
						
						onerror ep_err do
						
							gss::pr_appendError(ep_err);
							gss::pr_uploadDownloadWidgetErrorHandling( ep_err, ep_stat, statusCode, statusDescription); 
						
							errh::MarkAsHandled(ep_err);
						
						endblock ;
						gss::pr_leave(sp_gssTime, p_gssMiU, ep_messageImportance: 'info');
					}
					Comment: "Download profiler and error data of the selected data or solver session to file.";
					StringParameter fileLocation {
						Property: Output;
					}
					Parameter statusCode {
						Property: Output;
					}
					StringParameter statusDescription {
						Property: Output;
					}
					StringParameter sp_finalLocation;
					ElementParameter ep_stat {
						Range: errh::AllErrorSeverities;
					}
					ElementParameter ep_err {
						Range: errh::PendingErrors;
					}
					DeclarationSection gss_logging_declarations {
						StringParameter sp_gssTime;
						Parameter p_gssMiU;
					}
				}
				Procedure pr_downloadErrorDataFileWinUI {
					Body: {
						pr_enter(sp_gssTime, p_gssMiU, ep_messageImportance: 'info');
						block 
							pr_getDownloadFolder( /* output */ sp_downloadFolder );
							sp_outfn := 
								if ep_shownSession then 
									formatString("%e.errors", ep_shownSession ) 
								else 
									"usage.errors" 
								endif ;
							sp_filename := sp_downloadFolder + "\\" + sp_outfn ;
							pr_downloadErrorDataWork( sp_filename );
						onerror ep_err do
							gss::pr_appendError( ep_err );
							errh::MarkAsHandled( ep_err );
						endblock ;
						pr_leave(sp_gssTime, p_gssMiU, ep_messageImportance: 'info');
					}
					Comment: "Download error and profiler data procedure Used in WinUI GSS Session History Management page";
					DeclarationSection local_Declarations {
						StringParameter sp_filename;
						StringParameter sp_downloadFolder;
						StringParameter sp_outfn;
					}
					DeclarationSection gss_logging_declarations {
						StringParameter sp_gssTime;
						Parameter p_gssMiU;
					}
					DeclarationSection error_reference_declaration {
						ElementParameter ep_err {
							Range: errh::PendingErrors;
						}
					}
				}
				Procedure pr_downloadErrorReport {
					Arguments: (fileLocation,statusCode,statusDescription);
					Body: {
						gss::pr_enter(sp_gssTime, p_gssMiU, ep_messageImportance: 'info');
						block 
							gss::pr_initErrorHandlingDownloadUploadButtons( ep_stat, statusCode,  statusDescription, bp_download:1 );
						
							fileLocation := if ep_shownSession then formatString("%e.errorLogging", ep_shownSession ) else "usage.errorLogging" endif ;
						
							! we store the location of the file in string parameter FinalLocation
							sp_finalLocation := webui::GetIOFilePath(fileLocation);
						
							! writing the string parameter FinalLocation to a text file
							pr_reportCurrentErrorsToTextFile( sp_finalLocation );
						
							! checking if the previous write statement was successful or not
							if not FileExists(sp_finalLocation) then
								raise error FormatString("Error creating error report to file %s", sp_finalLocation );
							endif;
						
							! if successful, statusCode is set to 'CREATED' which will trigger the download widget to show the Get button
							StatusCode := webui::ReturnStatusCode('CREATED');
						
							! displaying the status message as All perfect instead of the default "File ready to download"
							StatusDescription := "Succesfully downloaded error report of data session to " + fileLocation ;
						
						onerror ep_err do
						
							gss::pr_appendError(ep_err);
							gss::pr_uploadDownloadWidgetErrorHandling( ep_err, ep_stat, statusCode, statusDescription); 
						
							errh::MarkAsHandled(ep_err);
						
						endblock ;
						gss::pr_leave(sp_gssTime, p_gssMiU, ep_messageImportance: 'info');
					}
					Comment: "Download the error data in a readable report, invoked via the WebUI GSS Session History Management page";
					DeclarationSection gss_logging_declarations {
						StringParameter sp_gssTime;
						Parameter p_gssMiU;
					}
					StringParameter fileLocation {
						Property: Output;
					}
					Parameter statusCode {
						Property: Output;
					}
					StringParameter statusDescription {
						Property: Output;
					}
					StringParameter sp_finalLocation;
					ElementParameter ep_err {
						Range: errh::PendingErrors;
					}
					ElementParameter ep_stat {
						Range: errh::AllErrorSeverities;
					}
				}
				Procedure pr_downloadErrorReportSidePanel {
					Arguments: (fileLocation,statusCode,statusDescription);
					Body: {
						gss::pr_enter(sp_gssTime, p_gssMiU, ep_messageImportance: 'info');
						block 
							gss::pr_initErrorHandlingDownloadUploadButtons( ep_stat, statusCode,  statusDescription, bp_download:1 );
						
							fileLocation := "usage.errorLogging";
						
							! we store the location of the file in string parameter FinalLocation
							sp_finalLocation := webui::GetIOFilePath(fileLocation);
						
							! writing the string parameter FinalLocation to a text file
							pr_openPageErrorWarningProfiler();
							pr_reportCurrentErrorsToTextFile( sp_finalLocation );
						
							! checking if the previous write statement was successful or not
							if not FileExists(sp_finalLocation) then
								raise error FormatString("Error creating error report to file %s", sp_finalLocation );
							endif;
						
							! if successful, statusCode is set to 'CREATED' which will trigger the download widget to show the Get button
							StatusCode := webui::ReturnStatusCode('CREATED');
							! displaying the status message as All perfect instead of the default "File ready to download"
							StatusDescription := "Succesfully downloaded error report of data session to " + fileLocation ;
						
						onerror ep_err do
						
							gss::pr_appendError(ep_err);
							gss::pr_uploadDownloadWidgetErrorHandling( ep_err, ep_stat, statusCode, statusDescription); 
						
							errh::MarkAsHandled(ep_err);
						
						endblock ;
						gss::pr_leave(sp_gssTime, p_gssMiU, ep_messageImportance: 'info');
					}
					Comment: {
						"Download the error data in a readable report.
						Invoked via sidepanel."
					}
					DeclarationSection gss_logging_declarations {
						StringParameter sp_gssTime;
						Parameter p_gssMiU;
					}
					StringParameter fileLocation {
						Property: Output;
					}
					Parameter statusCode {
						Property: Output;
					}
					StringParameter statusDescription {
						Property: Output;
					}
					StringParameter sp_finalLocation;
					ElementParameter ep_err {
						Range: errh::PendingErrors;
					}
					ElementParameter ep_stat {
						Range: errh::AllErrorSeverities;
					}
				}
				Procedure pr_downloadErrorReportWinUI {
					Body: {
						pr_enter(sp_gssTime, p_gssMiU, ep_messageImportance: 'info');
						block 
							pr_getDownloadFolder( /* output */ sp_downloadFolder );
							sp_outfn := if ep_shownSession then formatString("%e.errorLogging", ep_shownSession ) else "usage.errorLogging" endif ;
							sp_filename := sp_downloadFolder + "\\" + sp_outfn ;
						
							pr_reportCurrentErrorsToTextFile( sp_filename );
						
						onerror ep_err do
							gss::pr_appendError( ep_err );
							errh::MarkAsHandled( ep_err );
						endblock ;
						pr_leave(sp_gssTime, p_gssMiU, ep_messageImportance: 'info');
					}
					Comment: "Download the error dat as a readable report, invoked via WinUI GSS Session History Management page";
					DeclarationSection local_Declarations {
						StringParameter sp_filename;
						StringParameter sp_downloadFolder;
						StringParameter sp_outfn;
					}
					DeclarationSection gss_logging_declarations {
						StringParameter sp_gssTime;
						Parameter p_gssMiU;
					}
					DeclarationSection error_reference_declaration {
						ElementParameter ep_err {
							Range: errh::PendingErrors;
						}
					}
				}
			}
			Section Data_session {
				Property: NoSave;
				DeclarationSection dataSessionProfilerErrorData {
					ElementParameter ep_dataSessionIncident {
						Range: s_jobErrorMessageNumbers;
					}
					Parameter p_dataSessionProfilerData {
						IndexDomain: (IndexIdentifiers,i_lineNumber,IndexProfilerTypes );
						InitialData: data{};
					}
					StringParameter sp_dataSessionErrorMessages {
						IndexDomain: i_dataSessionErrorMessageNumber;
						InitialData: data{};
					}
					StringParameter sp_dataSessionErrorMoments {
						IndexDomain: i_dataSessionErrorMessageNumber;
						InitialData: data{};
					}
					ElementParameter ep_dataSessionErrorSeverity {
						IndexDomain: i_dataSessionErrorMessageNumber;
						Range: s_messageLevels;
						InitialData: data{};
					}
					ElementParameter ep_dataSessionErrorNodes {
						IndexDomain: (i_dataSessionErrorMessageNumber,i_stackPosition);
						Range: AllSymbols;
						InitialData: data {};
					}
					ElementParameter ep_dataSessionErrorAttributes {
						IndexDomain: (i_dataSessionErrorMessageNumber,i_stackPosition);
						Range: AllAttributeNames;
						InitialData: data {};
					}
					Parameter p_dataSessionErrorLines {
						IndexDomain: (i_dataSessionErrorMessageNumber,i_stackPosition);
						InitialData: data {};
					}
				}
				DeclarationSection data_session_summary {
					Parameter p_noLogMessages {
						InitialData: 0;
					}
					Parameter p_noWarnings {
						InitialData: 0;
					}
					Parameter p_noErrors {
						InitialData: 0;
					}
				}
				Procedure pr_collectProfilerData {
					Body: {
						ProfilerCollectAllData(
							ProfilerData       :  p_dataSessionProfilerData, 
							GrossTimeThreshold :  0, 
							NetTimeThreshold   :  0);
					}
					Comment: "collect the profiler data of";
				}
				Procedure pr_dataSessionClearErrors {
					Body: {
						empty dataSessionProfilerErrorData;
						p_noLogMessages := 0 ;
						p_noWarnings := 0 ;
						p_noErrors := 0 ;
					}
				}
				Procedure pr_appendErrorDataSession {
					Arguments: (ep_err,sp_prefix);
					Body: {
						! Increase the number of recorded error messages.
						pr_newIncidentDataSession();
						
						ep_jobErrorMessageNumber := ep_dataSessionIncident ;
						
						sp_msg := sp_prefix + errh::Message( ep_err);
						
						! Record the message and severity.
						sp_dataSessionErrorMessages(ep_JobErrorMessageNumber) := sp_msg;
						sp_dataSessionErrorMoments( ep_jobErrorMessageNumber) := errh::CreationTime(ep_err,"%c%y-%m-%d %H:%M:%S:%T%TZ('local')");
						ep_dataSessionErrorSeverity(ep_jobErrorMessageNumber) := ep_errorToMessageLevelMap(errh::Severity(ep_err));
						
						! Record the entire stack of error positions
						p_errStackHeight := errh::NumberOfLocations(ep_err);
						p_errStackPos := 1 ;
						while p_errStackPos <= p_errStackHeight do
							ep_stackPosition := p_errStackPos;
							ep_dataSessionErrorNodes(ep_jobErrorMessageNumber,ep_stackPosition) := errh::Node(ep_err,ep_stackPosition);
							ep_dataSessionErrorAttributes(ep_jobErrorMessageNumber,ep_stackPosition) := errh::attribute(ep_err,ep_stackPosition);
							p_dataSessionErrorLines( ep_jobErrorMessageNumber,ep_stackPosition) := errh::Line(ep_err,ep_stackPosition);
							p_errStackPos += 1 ;
						endwhile ;
						
						if errh::Severity(ep_err) = 'warning' then
							p_noWarnings += 1 ;
						else
							p_NoErrors += 1 ;
						endif ;
					}
					Comment: "Store the error in the data structures of the library.";
					ElementParameter ep_err {
						Range: errh::PendingErrors;
						Property: Input;
					}
					Parameter p_errStackHeight;
					Parameter p_errStackPos;
					ElementParameter ep_stackPosition {
						Range: s_stackPositions;
					}
					ElementParameter ep_jobErrorMessageNumber {
						Range: s_jobErrorMessageNumbers;
					}
					StringParameter sp_prefix {
						Property: Optional;
					}
					StringParameter sp_msg;
				}
				Procedure pr_appendMessageDataSession {
					Arguments: (sp_msg,ep_lev);
					Body: {
						! Increase the number of recorded error messages.
						pr_newIncidentDataSession();
						ep_jobErrorMessageNumber := ep_dataSessionIncident;
						
						! Record the message and severity.
						sp_dataSessionErrorMessages(ep_jobErrorMessageNumber) := sp_msg;
						sp_dataSessionErrorMoments( ep_jobErrorMessageNumber) := CurrentToString("%c%y-%m-%d %H:%M:%S:%T");
						ep_dataSessionErrorSeverity(ep_jobErrorMessageNumber) := ep_lev;
						
						! Record the entire stack of error positions
						p_errStackHeight := callerNumberOfLocations();
						p_errStackPos := 1 ;
						while p_errStackPos <= p_errStackHeight do
							ep_stackPosition := p_errStackPos;
							ep_dataSessionErrorNodes(     ep_jobErrorMessageNumber,ep_stackPosition) := callerNode(     ep_stackPosition);
							ep_dataSessionErrorAttributes(ep_jobErrorMessageNumber,ep_stackPosition) := callerAttribute(ep_stackPosition);
							p_dataSessionErrorLines(      ep_jobErrorMessageNumber,ep_stackPosition) := callerLine(     ep_stackPosition);
							p_errStackPos += 1 ;
						endwhile ;
						
						p_noLogMessages += 1 ;
					}
					Comment: "Store the error in the data structures of the library.";
					Parameter p_errStackHeight;
					Parameter p_errStackPos;
					ElementParameter ep_stackPosition {
						Range: s_stackPositions;
					}
					ElementParameter ep_jobErrorMessageNumber {
						Range: s_jobErrorMessageNumbers;
					}
					StringParameter sp_msg {
						Property: Input;
					}
					ElementParameter ep_lev {
						Range: s_messageLevels;
						Default: 'info';
						Property: Optional;
					}
				}
			}
			Section Guard_server_session {
				DeclarationSection controlServerSessionData {
					Comment: {
						"Contains parameters that are used to control GSS library in server sessions.
						They are passed along in the input case."
					}
					ElementParameter ep_tracingFilterlevel {
						Range: s_messageLevels;
						InitialData: 'info';
						Comment: "The tracing level used during the session.";
					}
				}
				DeclarationSection serverSessionErrorData {
					StringParameter sp_serverSessionId {
						Comment: {
							"The session id of the server session. Also known as requestID.
							Often obtained by calling pro::session::CurrentSession directly after pro::delegate."
						}
					}
					Parameter p_jobProfilerData {
						IndexDomain: (IndexIdentifiers,i_lineNumber,IndexProfilerTypes );
						InitialData: data {};
						Comment: "The profiler data of the job just ran.";
					}
					StringParameter sp_jobErrorMessages {
						IndexDomain: i_jobErrorMessageNumber;
						Comment: "The error messages of the job just ran";
					}
					StringParameter sp_jobErrorMoments {
						IndexDomain: i_jobErrorMessageNumber;
						Comment: "The moments the errors occurred  of the job just ran";
					}
					ElementParameter ep_jobErrorSeverity {
						IndexDomain: i_jobErrorMessageNumber;
						Range: s_messageLevels;
						Comment: "The severities of the errors  of the job just ran";
					}
					ElementParameter ep_jobErrorNodes {
						IndexDomain: (i_jobErrorMessageNumber,i_stackPosition);
						Range: AllSymbols;
						Comment: "The identifiers on the execution stack of the errors  of the job just ran";
					}
					ElementParameter ep_jobErrorAttributes {
						IndexDomain: (i_jobErrorMessageNumber,i_stackPosition);
						Range: AllAttributeNames;
						Comment: "The attributes on the execution stack of the errors  of the job just ran";
					}
					Parameter p_jobErrorLines {
						IndexDomain: (i_jobErrorMessageNumber,i_stackPosition);
						Comment: "The line numbers on the execution stack of the errors  of the job just ran";
					}
				}
				Procedure pr_guardAndProfileServerJob {
					Arguments: (ep_work);
					Body: {
						if pro::GetPROEndPoint() then
							if pro::IsRunningAtServer() then
								pr_doGuardAndProfileServerJob( ep_work);
							else
								apply( ep_work);
							endif ;
						else
							apply( ep_work);
						endif ;
					}
					Comment: {
						"To be called when a job is delegated; it will ensure that :
						1) Errors and warnings issued during the execution of the actual work in procedure ep_work are collected.
						2) That profiling information during the execution of the procedure ep_work is collected
						3) That the logging is saved and stored in AIMMS PRO Storage."
					}
					ElementParameter ep_err {
						Range: errh::PendingErrors;
					}
					ElementParameter ep_work {
						Range: AllProcedures;
						Default: 'gss::pr_sampleProc';
						Property: Input;
					}
				}
				Procedure pr_appendErrorJob {
					Arguments: (ep_err,sp_prefix);
					Body: {
						! Increase the number of recorded error messages.
						pr_newIncidentJob();
						ep_jobErrorMessageNumber := ep_jobIncident;
						
						sp_msg := sp_prefix + errh::Message( ep_err);
						
						! Record the message and severity.
						sp_jobErrorMessages(ep_JobErrorMessageNumber) := sp_msg;
						sp_jobErrorMoments( ep_jobErrorMessageNumber) := errh::CreationTime(ep_err,"%c%y-%m-%d %H:%M:%S:%T%TZ('local')");
						ep_jobErrorSeverity(ep_jobErrorMessageNumber) := ep_errorToMessageLevelMap(errh::Severity(ep_err));
						
						! Record the entire stack of error positions
						p_errStackHeight := errh::NumberOfLocations(ep_err);
						p_errStackPos := 1 ;
						while p_errStackPos <= p_errStackHeight do
							ep_stackPosition := p_errStackPos;
							ep_jobErrorNodes(ep_jobErrorMessageNumber,ep_stackPosition) := errh::Node(ep_err,ep_stackPosition);
							ep_JobErrorAttributes(ep_jobErrorMessageNumber,ep_stackPosition) := errh::attribute(ep_err,ep_stackPosition);
							p_jobErrorLines( ep_jobErrorMessageNumber,ep_stackPosition) := errh::Line(ep_err,ep_stackPosition);
							p_errStackPos += 1 ;
						endwhile ;
						
						if errh::Severity(ep_err) = 'warning' then
							p_noWarnings += 1 ;
						else
							p_NoErrors += 1 ;
						endif ;
					}
					Comment: "Store the error in the data structures of the library.";
					ElementParameter ep_err {
						Range: errh::PendingErrors;
						Property: Input;
					}
					Parameter p_errStackHeight;
					Parameter p_errStackPos;
					ElementParameter ep_stackPosition {
						Range: s_stackPositions;
					}
					ElementParameter ep_jobErrorMessageNumber {
						Range: s_jobErrorMessageNumbers;
					}
					StringParameter sp_prefix {
						Property: Optional;
					}
					StringParameter sp_msg;
				}
				Procedure pr_appendMessageJob {
					Arguments: (sp_msg,ep_lev);
					Body: {
						! Increase the number of recorded error messages.
						pr_newIncidentJob();
						ep_jobErrorMessageNumber := ep_jobIncident ;
						
						! Record the message and severity.
						sp_jobErrorMessages(ep_jobErrorMessageNumber) := sp_msg;
						sp_jobErrorMoments( ep_jobErrorMessageNumber) := CurrentToString("%c%y-%m-%d %H:%M:%S:%T");
						ep_jobErrorSeverity(ep_jobErrorMessageNumber) := ep_lev;
						
						! Record the entire stack of error positions
						p_errStackHeight := callerNumberOfLocations();
						p_errStackPos := 1 ;
						while p_errStackPos <= p_errStackHeight do
							ep_stackPosition := p_errStackPos;
							ep_jobErrorNodes(     ep_jobErrorMessageNumber,ep_stackPosition) := callerNode(     ep_stackPosition);
							ep_JobErrorAttributes(ep_jobErrorMessageNumber,ep_stackPosition) := callerAttribute(ep_stackPosition);
							p_jobErrorLines(      ep_jobErrorMessageNumber,ep_stackPosition) := callerLine(     ep_stackPosition);
							p_errStackPos += 1 ;
						endwhile ;
						
						p_noLogMessages += 1 ;
					}
					Comment: "Store the error in the data structures of the library.";
					Parameter p_errStackHeight;
					Parameter p_errStackPos;
					ElementParameter ep_stackPosition {
						Range: s_stackPositions;
					}
					ElementParameter ep_jobErrorMessageNumber {
						Range: s_jobErrorMessageNumbers;
					}
					StringParameter sp_msg {
						Property: Input;
					}
					ElementParameter ep_lev {
						Range: s_messageLevels;
						Default: 'info';
						Property: Optional;
					}
				}
				Procedure LoadResultsCallBack {
					Arguments: (sp_requestID);
					Body: {
						gss::pr_enter(sp_gssTime, p_gssMiU );
						block
							pro::session::LoadResultsCallBack(sp_requestID);
							gss::pr_saveTrackedSessionData( sp_requestID );
						onerror ep_err do
							pr_appendError( ep_err );
							errh::MarkAsHandled( ep_err );
						endblock ;
						gss::pr_leave(sp_gssTime, p_gssMiU );
					}
					Comment: {
						"The normal load results callback and store error and profiler data of the solver session
						in the Tracked sessions container."
					}
					DeclarationSection gss_logging_declarations {
						StringParameter sp_gssTime;
						Parameter p_gssMiU;
					}
					StringParameter sp_requestID {
						Property: Input;
					}
					ElementParameter ep_err {
						Range: errh::PendingErrors;
					}
				}
			}
			Section Utility_section {
				Property: NoSave;
				Comment: "Catchall section.";
				Parameter p_maxNoErrorsPerSession {
					InitialData: 10000;
					Comment: "Max number of informational messages, warnings, and errors stored per job.";
				}
				Set s_jobErrorMessageNumbers {
					SubsetOf: Integers;
					Index: i_jobErrorMessageNumber, i_dataSessionErrorMessageNumber;
					Property: ElementsAreNumerical;
					Definition: ElementRange(1,p_maxNoErrorsPerSession);
				}
				Procedure pr_openProfiledIdentifier {
					Body: {
						block
							if ep_profilerDataSelectedIdentifier then
								IdentifierShowAttributes( ep_profilerDataSelectedIdentifier );
							endif ;
						onerror ep_err do
							pr_appendError( ep_err );
							errh::MarkAsHandled( ep_err );
						endblock ;
					}
					Comment: {
						"Open the attribute window of an identifier i
						Used in widget action and item action of the table JobProfilerData on page \"GSS Session History Management\""
					}
					ElementParameter ep_err {
						Range: errh::PendingErrors;
					}
				}
				Procedure pr_openIdentifierOnStack {
					Body: {
						block 
							if card(s_jobErrorMessageNumbers) then
								if not ep_errorWarningSelectedMessage then
									ep_errorWarningSelectedMessage := last( s_jobErrorMessageNumbers );
								endif ;
								if not ep_StackPos then
									ep_StackPos := first( s_stackPositions );
								endif ;
								if ep_errorWarningSelectedMessage and ep_StackPos then
									IdentifierShowAttributes(  
										ep_shownJobErrorNodes( ep_errorWarningSelectedMessage, ep_stackPos ));
								endif ;
							endif ;
						onerror ep_err do
							pr_appendError( ep_err );
							errh::MarkAsHandled( ep_err );
						endblock ;
					}
					ElementParameter ep_err {
						Range: errh::PendingErrors;
					}
				}
				Procedure pr_openIdentifierOnMessageList {
					Body: {
						block 
							if ep_errorWarningSelectedMessage and ep_shownJobErrorNodes( ep_errorWarningSelectedMessage, 1 ) then
								IdentifierShowAttributes(  
									ep_shownJobErrorNodes( ep_errorWarningSelectedMessage, ep_stackPos ));
							endif ;
						onerror ep_err do
							pr_appendError( ep_err );
							errh::MarkAsHandled( ep_err );
						endblock ;
					}
					ElementParameter ep_err {
						Range: errh::PendingErrors;
					}
				}
				Procedure pr_initErrorHandlingDownloadUploadButtons {
					Arguments: (ep_stat,statusCode,statusDescription,bp_download);
					Body: {
						ep_stat := '';
						statusCode := if bp_download then webui::ReturnStatusCode('CREATED') else webui::ReturnStatusCode('OK') endif ;
						statusDescription := "Nice.";
						
						! Best practice: declare ep_stat inside the calling procedure.
					}
					ElementParameter ep_stat {
						Range: errh::AllErrorSeverities;
						Property: Output;
					}
					Parameter statusCode {
						Property: Output;
					}
					StringParameter statusDescription {
						Property: Output;
					}
					Parameter bp_download {
						Property: Optional;
					}
				}
				Procedure pr_uploadDownloadWidgetErrorHandling {
					Arguments: (ep_err, ep_stat, statusCode, statusDescription);
					Body: {
						! Ensure that the single message shown to the user is the first error, and if there is none: the first warning.
						if errh::Severity(ep_err) = 'warning' then
							if ep_stat = '' then
								statusDescription := "OK, but note: " + errh::Message( ep_err );
								ep_stat := 'warning';
							endif ;
						else
							statusCode := webui::ReturnStatusCode('ERROR');
							if ep_stat <> 'error' then
								statusDescription := "Better luck next time: " + errh::Message( ep_err );
								ep_stat := 'error';
							endif;
						endif ;
						
						! Best practice: declare ep_err and ep_stat inside the calling procedure.
					}
					ElementParameter ep_err {
						Range: errh::PendingErrors;
						Property: Input;
					}
					ElementParameter ep_stat {
						Range: errh::AllErrorSeverities;
						Property: InOut;
					}
					Parameter statusCode {
						Property: InOut;
					}
					StringParameter statusDescription {
						Property: InOut;
					}
				}
				Procedure pr_appendError {
					Arguments: (ep_err,sp_prefix);
					Body: {
						ep_messageImportance := if errh::Severity(ep_err) = 'warning' then 'warn' else 'error' endif;
						pr_logMsg( 
							formatString("%s: %s", 
								errh::CreationTime( ep_err, "%c%y-%m-%d %H:%M:%S:%t%TZ(gss::ep_traceTimezone)" ), 
								errh::Message(ep_err)), 
							ep_messageImportance );
						if pro::GetPROEndPoint() then
							if pro::IsRunningAtServer() then
								pr_appendErrorJob(ep_err,sp_prefix);
							else
								pr_appendErrorDataSession(ep_err,sp_prefix);
							endif ;
						else
							pr_appendErrorDataSession(ep_err,sp_prefix);
						endif ;
					}
					Comment: "Store the error in the data structures of the library.";
					ElementParameter ep_err {
						Range: errh::PendingErrors;
						Property: Input;
					}
					Parameter p_errStackHeight;
					Parameter p_errStackPos;
					ElementParameter ep_stackPosition {
						Range: s_stackPositions;
					}
					ElementParameter ep_jobErrorMessageNumber {
						Range: s_jobErrorMessageNumbers;
					}
					StringParameter sp_prefix {
						Property: Optional;
					}
					StringParameter sp_msg;
					ElementParameter ep_messageImportance {
						Range: s_messageLevels;
					}
					DeclarationSection gss_logging_declarations {
						StringParameter sp_gssTime;
						Parameter p_gssMiU;
					}
				}
				Procedure pr_appendMessage {
					Arguments: (sp_message,ep_messageImportance);
					Body: {
						if pro::GetPROEndPoint() then
							if pro::IsRunningAtServer() then
								pr_appendMessageJob(sp_message,ep_messageImportance);
							else
								pr_appendMessageDataSession(sp_message,ep_messageImportance);
							endif ;
						else
							pr_appendMessageDataSession(sp_message,ep_messageImportance);
						endif ;
					}
					Comment: "Store the error in the data structures of the library.";
					Parameter p_errStackHeight;
					Parameter p_errStackPos;
					ElementParameter ep_stackPosition {
						Range: s_stackPositions;
					}
					ElementParameter ep_jobErrorMessageNumber {
						Range: s_jobErrorMessageNumbers;
					}
					StringParameter sp_message {
						Property: Input;
					}
					ElementParameter ep_messageImportance {
						Range: s_messageLevels;
						Default: 'info';
						Property: Optional;
						Comment: "Importance level of message.";
					}
				}
				Procedure pr_globalErrorHandler {
					Arguments: (ep_err);
					Body: {
						pr_appendError(ep_err );
						
						if bp_locSeenErrorsAreHandled then
							errh::MarkAsHandled( ep_err );
						endif ;
					}
					ElementParameter ep_err {
						Range: errh::PendingErrors;
						Property: Input;
					}
					ElementParameter ep_jobErrorMessageNumber {
						Range: s_jobErrorMessageNumbers;
					}
					Parameter p_errStackHeight;
					Parameter p_errStackPos;
					ElementParameter ep_stackPosition {
						Range: s_stackPositions;
					}
				}
				Procedure pr_seenErrorsAreHandled {
					Arguments: (bp_areHandled);
					Body: {
						bp_locSeenErrorsAreHandled := bp_areHandled ;
					}
					Parameter bp_areHandled {
						Range: binary;
						Default: 1;
						Property: Input;
					}
				}
			}
		}
		Section Inspect_state_session {
			Procedure pr_saveState {
				Arguments: (sp_label,s_selectedIdentifiers);
				Body: {
					
					Block ! Determine the subset of identifiers that actually have data to be written to file.
						s_selectedIdentifiersWithData := { i_someId |
							( i_someId in AllSets ) or
							( i_someId in AllParameters ) or
							( i_someId in AllVariables ) or
							( i_someId in AllConstraints ) };
						if not card( s_selectedIdentifiersWithData ) then
							raise warning "No data output from gss::SaveState, as no identifier contains data" ;
							return 0;
						endif ;
					endblock ;
					
					Block ! Materials will be written first to a subfolder of the project folder.  Ensure this intermediate folder exists.
						if  not directoryExists( sp_label ) then
							directoryCreate( sp_label );
						endif ;
					endblock ;
					
					block ! Ensure PRO is connected, initialized, and the PRO Storage folder exists that will contain all text output files
						if pro::GetPROEndPoint() then
							pro::Initialize();
							sp_slash := "/" ;
							sp_proStorageFolderName := "/Userdata/" + 
								pro::GetPROEnvironment() + sp_slash + 
								pro::GetPROUserName()    + sp_slash + 
								pro::ModelName           + sp_slash + 
								pro::modelversion        + sp_slash + 
								sp_label ;
							pr_ensurePath( sp_proStorageFolderName );
						endif ;
					endblock ;
					
					block ! Each data identifier to be written to file is written to a separate file.
						where single_column_display := 1, listing_number_precision := 12, listing_number_width := 20 ;
						for i_someIdWithData do
							s_singleTonSet := {};
							s_singleTonSet += i_someIdWithData ;
							sp_filename := fnc_fileFriendlyName( i_someIdWithData );
							sp_fullFilename := sp_label + "\\" + sp_filename;
							write s_singleTonSet to file sp_fullFilename ;
							if pro::GetPROEndPoint() then
								sp_proStorageFileName := sp_proStorageFolderName + sp_slash + sp_filename ;
								pro::SaveFileToCentralStorage(
									localPath     :  sp_fullFilename, 
									storagePath   :  sp_proStorageFileName);
							endif ;
						endfor ;
					endblock ;
				}
				StringParameter sp_proStorageFolderName;
				StringParameter sp_proStorageFileName;
				StringParameter sp_slash;
				Set s_selectedIdentifiers {
					SubsetOf: AllSymbols;
					Index: i_someId;
					Property: Input;
				}
				Set s_selectedIdentifiersWithData {
					SubsetOf: AllIdentifiers;
					Index: i_someIdWithData;
				}
				Set s_singleTonSet {
					SubsetOf: AllIdentifiers;
				}
				StringParameter sp_label {
					Property: Input;
				}
				StringParameter sp_filename;
				StringParameter sp_fullFilename;
			}
		}
		Section Logging {
			Property: NoSave;
			StringParameter sp_traceFilename {
				InitialData: "logging.txt";
			}
			Procedure pr_logMsg {
				Arguments: (sp_message,ep_messageImportance);
				Body: {
					if ep_messageImportance >= ep_tracingFilterlevel then
						pr_logMsgTraceFile(formatString("%s [%5e] %s", 
							CurrentToString("%c%y-%m-%d %H:%M:%S:%t%TZ(gss::ep_traceTimezone)"),
							ep_messageImportance, sp_message), ep_messageImportance);
					endif ;
				}
				Comment: {
					"Trace to the log file; this procedure should not be called before LibraryInitialization finished."
				}
				StringParameter sp_message {
					Property: Input;
				}
				ElementParameter ep_messageImportance {
					Range: s_messageLevels;
					Default: 'trace';
					Property: Optional;
				}
			}
			Procedure pr_enter {
				Arguments: (sp_procEnterTimestamp,p_procEnterMemoryInUse,ep_messageImportance,sp_logDetail);
				Body: {
					sp_procEnterTimestamp := CurrentToString("%c%y-%m-%d %H:%M:%S:%t%TZ('UTC')");
					p_procEnterMemoryInUse := MemoryInUse();
					pr_setMemoryInUse( p_procEnterMemoryInUse ); 
					sp_node := formatString("%e",CallerNode(1));
					sp_fullMsg := formatString("%s [%5e] Enter %s(%s) [%.3n Mb] in use", 
					!	MomentToString(
					!		Format        :  "%c%y-%m-%d %H:%M:%S:%t%TZ(gss::ep_traceTimezone)", 
					!		unit          :  [s], 
					!		ReferenceDate :  sp_procEnterTimestamp, 
					!		Elapsed       :  0[s]), 
						CurrentToString("%c%y-%m-%d %H:%M:%S:%t"),
						ep_messageImportance,
						sp_node, sp_logDetail, 
						p_procEnterMemoryInUse );
					pr_logMsgTraceFile( sp_fullMsg, ep_messageImportance );
					
					pr_checkCurrentFolder();
				}
				Comment: {
					"Trace entry of procedure to the log file; this procedure should not be called before LibraryInitialization finished."
				}
				StringParameter sp_procEnterTimestamp {
					Property: Output;
				}
				Parameter p_procEnterMemoryInUse {
					Property: Output;
				}
				StringParameter sp_logDetail {
					Property: Optional;
					Comment: {
						"If the traced procedure contains arguments, 
						you may want to summarize these arguments here."
					}
				}
				StringParameter sp_node;
				StringParameter sp_fullMsg;
				StringParameter sp_proc;
				ElementParameter ep_messageImportance {
					Range: s_messageLevels;
					Default: 'debug';
					Property: Optional;
				}
			}
			Procedure pr_leave {
				Arguments: (sp_procEnterTimestamp,p_procEnterMemoryInUse,ep_messageImportance,sp_logDetail);
				Body: {
					sp_leavingTime := CurrentToString("%c%y-%m-%d %H:%M:%S:%t%TZ('UTC')");
					p_duration := StringToMoment(
						Format        :  "%c%y-%m-%d %H:%M:%S:%t%TZ('UTC')", 
						Unit          :  [s], 
						ReferenceDate :  sp_procEnterTimestamp, 
						Timeslot      :  sp_leavingTime);
					sp_node := formatString("%e",CallerNode(1));
					p_leaveMemoryInUse := MemoryInUse();
					pr_setMemoryInUse( p_leaveMemoryInUse );
					sp_fullMsg := 
						formatString( "%s [%5e] Leave %s(%s) [%.3n Mb] in use. ",
					!		MomentToString(
					!			Format        :  "%c%y-%m-%d %H:%M:%S:%t%TZ(gss::ep_traceTimezone)", 
					!			unit          :  [s], 
					!			ReferenceDate :  sp_leavingTime, 
					!			Elapsed       :  0[s]), 
							CurrentToString("%c%y-%m-%d %H:%M:%S:%t"),
							ep_messageImportance, sp_node, sp_logDetail, 
							p_leaveMemoryInUse ) +
						formatString( "Duration is %.3n [seconds] and memory %s is %n Mb.", 
							p_duration,
							if p_leaveMemoryInUse >= p_procEnterMemoryInUse then "increase" else "decrease" endif, 
							abs( p_leaveMemoryInUse - p_procEnterMemoryInUse ) );
					pr_logMsgTraceFile( sp_fullMsg, ep_messageImportance );
					
					pr_checkCurrentFolder();
				}
				Comment: {
					"Trace leaving of procedure to the log file; this procedure should not be called before LibraryInitialization finished."
				}
				Parameter p_procEnterMemoryInUse {
					Property: Input;
				}
				StringParameter sp_procEnterTimestamp {
					Property: Input;
				}
				StringParameter sp_leavingTime;
				Parameter p_duration {
					Unit: s;
				}
				Parameter p_leaveMemoryInUse;
				StringParameter sp_logDetail {
					Property: Optional;
				}
				StringParameter sp_node;
				StringParameter sp_fullMsg;
				ElementParameter ep_messageImportance {
					Range: s_messageLevels;
					Default: 'debug';
					Property: Optional;
				}
			}
			Procedure pr_saveActionLogFile {
				Body: {
					if pro::GetPROEndPoint() then
						sp_slash := "/" ;
						sp_proStorageFolderName := sp_slash + "Userdata" + sp_slash + 
							pro::GetPROEnvironment() + sp_slash + 
							pro::GetPROUserName()    + sp_slash + 
							pro::ModelName           ;
						pr_ensurePath( sp_proStorageFolderName );
					
						pr_actuallySaveActionLogFile( sp_traceFilename, sp_proStorageFolderName );
					
						pr_saveLogfilesProTempfolder();
					endif ;
				}
				Comment: "Save the log file in AIMMS PRO storage.";
				StringParameter sp_proStorageFileName;
				StringParameter sp_proStorageFolderName;
				StringParameter sp_slash;
			}
			Procedure pr_setTracingLevel {
				Arguments: (ep_newTracingFilterLevel);
				Body: {
					if ep_newTracingFilterLevel then
						ep_tracingFilterlevel := ep_newTracingFilterLevel;
					else
						raise error "pr_setTracingLevel(): no actual level supplied.";
					endif ;
				}
				Comment: "Filter all tracing messages with a level lower than the argument value.";
				ElementParameter ep_newTracingFilterLevel {
					Range: s_messageLevels;
					Property: Input;
				}
			}
			Procedure pr_setReplicationSessionLog {
				Arguments: (bp_doReplicate);
				Body: {
					bp_replicateInSessionLog := bp_doReplicate;
				}
				Comment: "Use this function to turn on replication of the contents of the action log to the session log.";
				Parameter bp_doReplicate {
					Range: binary;
					Property: Input;
				}
			}
			Procedure pr_downloadActionLog {
				Arguments: (FileLocation,StatusCode,StatusDescription);
				Body: {
					block
						pr_downloadActionLogWork( /* inout */ fileLocation );
					
						sp_fullFileLocation := webui::GetIOFilePath(FileLocation);
						if FileLocation <> sp_fullFileLocation then
							FileCopy( FileLocation, sp_fullFileLocation );
						endif ;
					
						StatusCode := webui::ReturnStatusCode('CREATED');
						StatusDescription := formatString( "Succesfully downloaded action log %s", fileLocation);
					onerror ep_err Do
						if errh::Severity( ep_err ) <> 'warning' then
							StatusCode := webui::ReturnStatusCode('ERROR');
							StatusDescription := "Oops: " + errh::Message(ep_err) ;
							errh::MarkAsHandled(ep_err);
							break ; ! Trick to reporting one error.
						endif ;
					endblock ;
				}
				Comment: "Download action log WebUI button GSS Session History Management page.";
				StringParameter FileLocation {
					Property: Output;
				}
				Parameter StatusCode {
					Property: Output;
				}
				StringParameter StatusDescription {
					Property: Output;
				}
				StringParameter sp_fullFileLocation;
				ElementParameter ep_err {
					Range: errh::PendingErrors;
				}
			}
			Procedure pr_downloadActionLogWinUI {
				Body: {
					pr_enter(sp_gssTime, p_gssMiU, ep_messageImportance: 'info');
					block 
						pr_downloadActionLogWork(sp_outfn);
						pr_getDownloadFolder( /* output */ sp_downloadFolder );
					
						if not FileCopy( sp_outfn, sp_downloadFolder + "\\" + sp_outfn ) then
							raise error FormatString( 
								"Unable to copy %s to download folder : %s", 
								sp_outfn, CurrentErrorMessage );
						endif ;
					onerror ep_err do
						gss::pr_appendError( ep_err );
						errh::MarkAsHandled( ep_err );
					endblock ;
					pr_leave(sp_gssTime, p_gssMiU, ep_messageImportance: 'info');
				}
				Comment: "Download action log procedure Used in WinUI GSS Session History Management page";
				DeclarationSection gss_logging_declarations {
					StringParameter sp_gssTime;
					Parameter p_gssMiU;
				}
				DeclarationSection error_reference_declaration {
					ElementParameter ep_err {
						Range: errh::PendingErrors;
					}
				}
				StringParameter sp_downloadFolder;
				Parameter p_retFSN;
				StringParameter sp_outfn;
			}
		}
		Section Tracking_memory_in_use {
			Property: NoSave;
			Procedure pr_setMemoryInUse {
				Arguments: (p_argNewmemoryInUse);
				Body: {
					p_memoryInUse := p_argNewmemoryInUse;
					if p_peakMemoryInUse < p_argNewmemoryInUse then
						p_peakMemoryInUse := p_argNewmemoryInUse ;
					endif ;
				}
				Parameter p_argNewmemoryInUse {
					Property: Input;
				}
			}
		}
		Section Request_management {
			Property: NoSave;
			Procedure pr_openRequestManagement {
				Body: {
					pr_enter(sp_gssTime, p_gssMiU, ep_messageImportance: 'info');
					block 
						pr_updateSessionList();
						webui::OpenDialogPage(
							pageId  :  'gss_request_manager', 
							title   :  "Request manager", 
							Actions :  s_justOK, 
							onDone  :  'gss::pr_onDoneRequestManager');
					onerror ep_err do
						pr_appendError( ep_err );
						errh::MarkAsHandled( ep_err );
					endblock ;
					pr_leave(sp_gssTime, p_gssMiU, ep_messageImportance: 'info');
				}
				Comment: "Open the WebUI Request manager.";
				DeclarationSection gss_logging_declarations {
					StringParameter sp_gssTime;
					Parameter p_gssMiU;
				}
				DeclarationSection error_reference_declaration {
					ElementParameter ep_err {
						Range: errh::PendingErrors;
					}
				}
			}
			Set s_sessionList {
				Index: i_sess;
				Parameter: ep_selectedSession;
			}
			StringParameter sp_clientQueue {
				IndexDomain: (i_sess);
				InitialData: "";
			}
			StringParameter sp_workerQueue {
				IndexDomain: (i_sess);
				InitialData: "";
			}
			Parameter p_currentStatus {
				IndexDomain: (i_sess);
				InitialData: 0;
			}
			ElementParameter ep_currentStatus {
				IndexDomain: i_sess;
				Range: Integers;
				Definition: p_currentStatus(i_sess);
			}
			StringParameter sp_currentStatus {
				IndexDomain: i_sess;
				Definition: fnc_statusDescription( p_currentStatus(i_sess) );
				webui::TooltipIdentifier: gss::sp_sessionTooltip(gss::i_sess);
			}
			StringParameter sp_createTime {
				IndexDomain: (i_sess);
				InitialData: "";
				webui::TooltipIdentifier: gss::sp_sessionTooltip(gss::i_sess);
			}
			StringParameter sp_userEnv {
				IndexDomain: (i_sess);
				InitialData: "";
				webui::TooltipIdentifier: gss::sp_sessionTooltip(gss::i_sess);
			}
			StringParameter sp_userName {
				IndexDomain: (i_sess);
				InitialData: "";
				webui::TooltipIdentifier: gss::sp_sessionTooltip(gss::i_sess);
			}
			StringParameter sp_application {
				IndexDomain: (i_sess);
				InitialData: "";
				webui::TooltipIdentifier: gss::sp_sessionTooltip(gss::i_sess);
			}
			Parameter bp_isManaged {
				IndexDomain: i_sess;
				Range: binary;
				InitialData: 0;
			}
			StringParameter sp_requestDescription {
				IndexDomain: i_sess;
				InitialData: "";
				webui::TooltipIdentifier: gss::sp_sessionTooltip(gss::i_sess);
			}
			StringParameter sp_requestProcedure {
				IndexDomain: i_sess;
				InitialData: "";
				webui::TooltipIdentifier: gss::sp_sessionTooltip(gss::i_sess);
			}
			Parameter p_runTimeOut {
				IndexDomain: i_sess;
				InitialData: 0;
			}
			Parameter p_runTimeOutHour {
				IndexDomain: i_sess;
				Definition: p_runTimeOut(i_sess)/(3600*1000);
				webui::TooltipIdentifier: gss::sp_sessionTooltip(gss::i_sess);
			}
			StringParameter sp_versionID {
				IndexDomain: i_sess;
				InitialData: "";
			}
			StringParameter sp_responseVersionID {
				IndexDomain: i_sess;
				InitialData: "";
			}
			StringParameter sp_messageLogVersionID {
				IndexDomain: i_sess;
				InitialData: "";
			}
			StringParameter sp_errorMessage {
				IndexDomain: i_sess;
				InitialData: "";
			}
			StringParameter sp_requestTime {
				IndexDomain: i_sess;
				InitialData: "";
			}
			StringParameter sp_originalCasePath {
				IndexDomain: i_sess;
				InitialData: "";
			}
			Parameter p_activeStatus {
				IndexDomain: i_sess;
				InitialData: 0;
			}
			Parameter p_errorCode {
				IndexDomain: i_sess;
				InitialData: 0;
			}
			StringParameter sp_summary {
				Definition: {
					if ( ep_selectedSession ) then
						"Selected request\t: " + sp_requestDescription(ep_selectedSession) + "\n" +
						"Request time\t: " + sp_createTime(ep_selectedSession) + "\n" +
						"Current status\t: " + p_currentStatus(ep_selectedSession) + "\n" +
						"Case path\t\t: " + sp_originalCasePath(ep_selectedSession) + "\n" +
						"Error message\t: " + sp_errorMessage(ep_selectedSession)
					else
						"Selected request\t: \n" +
						"Request time\t: \n" +
						"Current status\t: \n" +
						"Case path\t\t: \n" +
						"Error message\t: "
					endif
				}
				Comment: "Used in WinUI only.";
			}
			StringParameter sp_sessionTooltip {
				IndexDomain: i_sess;
				Definition: {
					"<div align=\"left\">"  +
					"<Table>" +
					        "<TR>"  +
					                "<TD>"  +
					                                "<B> Selected request : </B>" +
					                "</TD>" +
					                "<TD>"  +
					                                sp_requestDescription(i_sess) +
					                "</TD>" +
					        "</TR>" +
					        "<TR>"  +
					                "<TD>"  +
					                                "<B> Request time : </B>" +
					                "</TD>" +
					                "<TD>"  +
					                                sp_createTime(i_sess) +
					                "</TD>" +
					        "</TR>" +
					        "<TR>"  +
					                "<TD>"  +
					                                "<B> Current status : </B>" +
					                "</TD>" +
					                "<TD>"  +
					                                sp_currentStatus(i_sess) +
					                "</TD>" +
					        "</TR>" +
					        "<TR>"  +
					                "<TD>"  +
					                                "<B> Case path : </B>" +
					                "</TD>" +
					                "<TD>"  +
					                                sp_originalCasePath(i_sess) +
					                "</TD>" +
					        "</TR>" +
					        "<TR>"  +
					                "<TD>"  +
					                                "<B> Error message : </B>" +
					                "</TD>" +
					                "<TD>"  +
					                                sp_errorMessage(i_sess) +
					                "</TD>" +
					        "</TR>" +
					"</Table>"
				}
			}
			Parameter bp_allUsers {
				Range: binary;
				InitialData: 1;
				webui::UponChangeProcedure: gss::pr_updateSessionList;
			}
			Parameter bp_allVersions {
				Range: binary;
				InitialData: 1;
				webui::UponChangeProcedure: gss::pr_updateSessionList;
			}
			Parameter bp_allModels {
				Range: binary;
				InitialData: 0;
				webui::UponChangeProcedure: gss::pr_updateSessionList;
			}
			ElementParameter ep_listSessionsSince {
				Range: cal_HoursLastThreeMonths;
				Comment: "Used when requesting a list of sessions in the request manager";
				webui::UponChangeProcedure: gss::pr_updateSessionList;
			}
			Calendar cal_HoursLastThreeMonths {
				Index: i_hourLastThreeMonth;
				Unit: hour;
				BeginDate: sp_beginHoursLastThreeMonths;
				EndDate: sp_endHoursLastThreeMonths;
				TimeslotFormat: "%c%y-%m-%d %H";
			}
			Procedure pr_loadSessionList {
				Arguments: (sp_sinceDate,bp_allPeople,bp_allApps,bp_allVers);
				Body: {
					! Initialize PRO Framework (if not initialized yet)
					p_ret := pro::Initialize();
					if not (p_ret) then return 0; endif;
					
					empty s_sessionList;
					
					! Load raw session list from PROT
					p_ret := pro::sessionmanager::ListSessionSinceDate(
						dateStr           :  sp_sinceDate, 
						sessionList       :  s_sessionList, 
						clientQueue       :  sp_clientQueue, 
						workerQueue       :  sp_workerQueue, 
						currentStatus     :  p_currentStatus, 
						createTime        :  sp_createTime, 
						userEnvironment   :  sp_userEnv, 
						userName          :  sp_userName, 
						proj              :  sp_application, 
						clientRef         :  sp_originalCasePath, 
						descr             :  sp_requestDescription, 
						proc              :  sp_requestProcedure, 
						timeOut           :  p_runTimeOut, 
						inputDataVersion  :  sp_versionID, 
						outputDataVersion :  sp_responseVersionID, 
						logFileVersion    :  sp_messageLogVersionID, 
						errorMessage      :  sp_errorMessage, 
						modelStatus       :  p_activeStatus, 
						errorCode         :  p_errorCode, 
						allUsers          :  bp_allPeople, 
						projectID         :  if bp_allApps then "" else pro::ModelName endif, 
						projectVersion    :  if bp_allVers then "" else pro::ModelVersion endif);
					if not pro::HandleError(p_ret) then return 0; endif;
					
					! Update session list data with managed session info, if available
					bp_isManaged(i_sess) := 1;
					
					return 1;
				}
				Parameter p_ret;
				StringParameter sp_contList;
				Set s_containers {
					Index: i_cont;
					Parameter: ep_container;
				}
				Set s_items {
					Index: i_item;
					Parameter: ep_item;
				}
				StringParameter sp_value {
					IndexDomain: (i_cont,i_item);
				}
				ElementParameter ep_ref {
					IndexDomain: (i_cont,i_item);
					Range: s_containers;
				}
				StringParameter sp_sinceDate {
					Property: Input;
				}
				Parameter bp_allApps {
					Range: binary;
					Default: 0;
					Property: Optional;
				}
				StringParameter sp_sessionModelID;
				StringParameter sp_sessionModelVersion;
				Parameter bp_allVers {
					Range: binary;
					Property: Optional;
				}
				Parameter bp_allPeople {
					Property: Optional;
				}
			}
			Procedure pr_purgeSessionList {
				Arguments: (s_list);
				Body: {
					if Card(s_list) = 0 then return 0; endif;
					
					! prevent incoming messages for sessions that are to be deleted from being handled
					for i_sessList do
					        pro::session::RemoveManagedSession(i_sessList);
					endfor;
					
					! Request to remove sessions in PROT, this includes clearing out the message database
					sp_warnStr := "";
					p_ret := pro::sessionmanager::ClearSessionDatabase(s_list,sp_warnStr);
					if not pro::HandleError(p_ret) then return 0; endif;
					
					if (sp_warnStr <> "") then
					        pro::DialogMessage(sp_warnStr,"Warnings");
					endif;
					
					return 1;
				}
				Set s_list {
					Index: i_sessList;
					Property: Input;
				}
				Parameter p_ret;
				StringParameter sp_warnStr;
				StringParameter sp_contList;
				Set s_queueList {
					Index: i_sessQueueList;
					Parameter: ep_sessionListElement;
				}
			}
			Procedure pr_exportSessionList {
				Arguments: (s_list);
				Body: {
					if Card(s_list) = 0 then return 0; endif;
					
					if (pro::IsNewDataManagementStyle) then
					        if not DirectorySelect(sp_caseFolder, title: "Select case folder") then return 0; endif;
					else
					        sp_PackFileName := "PRORequests.dat";
					        if not FileSelectNew(sp_PackFileName, title : "Select file to pack") then return 0; endif;
					
					    	if not FileExists("StgConv.exe") then
					            FileCopy("<lib:pro>:StgConv.exe","StgConv.exe");
					        endif;
					
					        sp_caseFolder := pro::PROTempFolder + pro::FileSeparator + "Empty.dat";
					        ! Generate the empty case structure
					        if DirectoryExists(sp_caseFolder) then
					                DirectoryDelete(sp_caseFolder);
					        endif;
					        FileCopy("<lib:pro>:Empty.dat",sp_caseFolder,0);
					        pro::management::UnpackIStorage(sp_caseFolder);
					
					        ! Fill index
					        sp_caseTree := sp_caseFolder + pro::FileSeparator + "{CASETREE}";
					        PUT f_content;
					endif;
					
					ip_fileCont := 0;
					for i_sessList do
					        ep_sessionElement := StringToElement(s_sessionList,i_sessList);
					        if bp_isManaged(ep_sessionElement) and sp_responseVersionID(ep_sessionElement) <> "" then
					                if (pro::IsNewDataManagementStyle) then
					                    sp_caseFilename := sp_caseFolder + pro::FileSeparator + FindReplaceStrings(FormatString("%s (%i).data",sp_requestDescription(ep_sessionElement),ip_fileCont), ":", "-");
					                else
					                    sp_caseFilename := sp_caseFolder + FormatString("%s%>08i",pro::FileSeparator, ip_fileCont);
					                endif;
					
					                pro::GetObjectVersionDirect(sp_responseVersionID(ep_sessionElement),sp_caseFilename);
					
					                if (not pro::IsNewDataManagementStyle) then
					                        ! Index entry
					                        if ip_fileCont = 1 then PUT "c"; else PUT "n"; endif;
					                        PUT FormatString(" %i 0 0 0 00022626 -1 1 5", ip_fileCont), /;
					                        PUT "GE113CC98-C66F-4DDC-9830-D3C2ECBFF825", /;
					                        PUT FormatString("N%s (%i)",sp_requestDescription(ep_sessionElement),ip_fileCont), /;
					                endif;
					        endif;
					endfor;
					
					if (not pro::IsNewDataManagementStyle) then
					        PUT "p";
					        PUTCLOSE f_content;
					
					        ! Pack the content into a single file
					        pro::management::PackIStorage(pro::PROTempFolder + "//Empty.dat");
					        FileMove(pro::PROTempFolder + "//Empty.dat",sp_PackFileName,0);
					        pro::DialogMessage("Selected cases downloaded to file \"" + sp_PackFileName + "\". You can now import all cases to your project through menu \"Edit\"/\"Import\" in the Data Manager page");
					endif;
					
					return 1;
				}
				StringParameter sp_caseFilename;
				Set s_list {
					Index: i_sessList;
					Property: Input;
				}
				ElementParameter ep_sessionElement {
					Range: s_sessionList;
				}
				StringParameter sp_PackFileName;
				StringParameter sp_caseFolder;
				Parameter p_ret;
				StringParameter sp_caseTree;
				File f_content {
					Name: sp_caseTree;
					Encoding: 'UTF8';
					Mode: replace;
				}
				StringParameter sp_getFileName;
				Parameter ip_fileCont {
					Range: integer;
					InitialData: 0;
				}
			}
			Procedure pr_loadResponse {
				Arguments: (ep_argRequest);
				Body: {
					pr_enter(sp_gssTime, p_gssMiU);
					
					! Basic validation
					if ep_argRequest = '' then
					        raise error "Invalid request reference" code 'PRO-Invalid-request-reference' ;
					        return 0;
					endif;
					
					p_changedStatus := pro::version::GetCaseStatus();
					
					! Either error state or not available state
					if (sp_responseVersionID(ep_argRequest) = "") then
					        ! Collect error information
					        if (p_errorCode(ep_argRequest)) then
							p_ret := 2;
							if sp_messageLogVersionID(ep_argRequest) <> "" then
								pr_saveAndOpenVersionInTemp(sp_messageLogVersionID(ep_argRequest));
								sp_logFileContents := fileRead( sp_sessionLogFile );
							endif;
					
							if p_ret = 2 AND sp_errorMessage(ep_argRequest) <> "" then
								raise warning "Execution finished with error message: " + sp_errorMessage(ep_argRequest);
								return 0;
							endif;
					        endif;
					
					        if (sp_messageLogVersionID(ep_argRequest) = "") and (p_errorCode(ep_argRequest) = 0) then
							raise warning "No output case was generated by the application";
					                return 0;
					        endif;
					
					        return 1;
					else
					        ! Open options page
					        ep_request := ep_argRequest;
					
					        pro::version::FindCase(sp_originalCasePath(ep_request),ep_originalCase);
					
					        if (p_changedStatus) then
					                sp_warningNonSavedData := "Attention: the current case contains unsaved data; loading a new case will overwrite this!";
					        else
					                empty sp_warningNonSavedData;
					                pro::version::ResetCaseStatus();
					        endif;
					
					        pr_loadResponseAction();
					
					
					        return 1;
					endif;
					
					pr_leave(sp_gssTime, p_gssMiU);
				}
				DeclarationSection gss_logging_declarations {
					StringParameter sp_gssTime;
					Parameter p_gssMiU;
				}
				ElementParameter ep_argRequest {
					Range: s_sessionList;
					Property: Input;
				}
				Parameter p_ret;
				StringParameter sp_tmpFile {
					InitialData: "";
				}
				StringParameter sp_tmpFileLog {
					InitialData: "";
				}
				StringParameter sp_tmpStr {
					InitialData: "";
				}
				Parameter p_changedStatus {
					Range: binary;
				}
				StringParameter sp_logFolder;
				StringParameter sp_wuipTime;
			}
			Section User_Session_List_GUI {
				Parameter p_noSessions {
					Definition: card( s_sessionList );
				}
				Parameter p_noQueuedSessions {
					Definition: count( i_sess | ep_currentStatus( i_sess ) in s_queuedSessions );
				}
				Parameter p_noRunningSessions {
					Definition: count( i_sess | ep_currentStatus( i_sess ) in s_runningSessionStates  );
				}
				Parameter p_noClosedSessions {
					Definition: count( i_sess | ep_currentStatus( i_sess ) in  s_closedStatus  );
				}
				Parameter p_noSessionsWithResults {
					Definition: count( i_sess | ep_currentStatus( i_sess ) in s_resultLoadableStatus  );
				}
				Set s_resultLoadableStatus {
					SubsetOf: Integers;
					Definition: {
						data { 
						6 ! finished.
						}
					}
				}
				Set s_queuedSessions {
					SubsetOf: Integers;
					Definition: {
						data { 
						0, 1, 2, 3
						}
					}
					Comment: {
						"Queued is used here slightly differently; sessions not yet running."
					}
				}
				Set s_closedStatus {
					SubsetOf: Integers;
					Definition: {
						data { 
						5,6,7,8,9 ! finished.
						}
					}
				}
				Set s_runningSessionStates {
					SubsetOf: Integers;
					Definition: {
						data {
						4 ! Running
						}
					}
				}
				Set s_terminatableStatus {
					SubsetOf: Integers;
					Definition: {
						data {
						0, ! created
						1, ! queued
						2, ! init
						3, ! ready 
						4, ! running
						5  ! Closing
						}
					}
				}
				Set s_statusCompleted {
					SubsetOf: Integers;
					Definition: {
						data {
						5,  ! Closing
						6,  ! Finished
						7,  ! Terminated
						8   ! Error
						}
					}
				}
				Set s_selectedActionSpecIdentifiers {
					SubsetOf: webui::WidgetItemActionSpecification;
					Index: i_WidgetActionId;
					Definition: {
						data { 
							'gss::sp_application',
							'gss::sp_createTime',
							'gss::sp_userEnv',
							'gss::sp_userName',
							'gss::sp_currentStatus',
							'gss::p_currentStatus',
							'gss::bp_gotResults',
							'gss::bp_mark',
							'gss::sp_requestDescription',
							'gss::sp_requestProcedure',
							'gss::p_runTimeOutHour'
						}
					}
				}
				StringParameter sp_itemActionsRequestManagerBase {
					IndexDomain: (webui::indexPageExtension,webui::indexWidgetActionSpec);
					Definition: {
						{
						
							(  '1', 'displaytext') : "Load result case for this session", 
							(  '1', 'icon'       ) : "aimms-file-download2",  
							(  '1', 'procedure'  ) : "gss::pr_loadRequestResponse", 
							(  '1', 'state'      ) : "Active", 
						
							(  '2', 'displaytext') : "Interrupt solver of this session", 
							(  '2', 'icon'       ) : "aimms-alarm", 
							(  '2', 'procedure'  ) : "gss::pr_interruptSelected",  
							(  '2', 'state'      ) : "Active",  
						
							(  '3', 'displaytext') : "Terminate this session",  
							(  '3', 'icon'       ) : "aimms-stop",  
							(  '3', 'procedure'  ) : "gss::pr_terminateSelected",  
							(  '3', 'state'      ) : "Active",
						
							(  '4', 'displaytext') : "Delete this session", 
							(  '4', 'icon'       ) : "aimms-bin", 
							(  '4', 'procedure'  ) : "gss::pr_removeSelected", 
							(  '4', 'state'      ) : "Active" 
						
						}
					}
				}
				StringParameter sp_itemActionsRequestManager {
					IndexDomain: (webui::indexWidgetItemActionSpec,webui::indexPageExtension,webui::indexWidgetActionSpec);
					Definition: {
						if webui::indexWidgetItemActionSpec in s_selectedActionSpecIdentifiers then
							if webui::indexWidgetActionSpec = 'state' then
								if webui::indexPageExtension = '1' then ! Loading results
									if ep_currentStatus( ep_selectedSession ) in s_resultLoadableStatus then
										"Active"
									else
										"Inactive"
									endif
								elseif webui::indexPageExtension = '2' then ! Interrupting sessions
									if ep_currentStatus( ep_selectedSession ) in s_runningSessionStates then
										"Active"
									else
										"Inactive"
									endif
								elseif webui::indexPageExtension = '3' then ! Halting sessions
									if ep_currentStatus( ep_selectedSession ) in s_terminatableStatus then
										"Active"
									else
										"Inactive"
									endif
								elseif webui::indexPageExtension = '4' then ! Removing/deleting sessions
									if ep_currentStatus( ep_selectedSession ) in s_closedStatus then
										"Active"
									else
										"Inactive"
									endif
								else
									""
								endif
							else
								sp_itemActionsRequestManagerBase(webui::indexPageExtension, webui::indexWidgetActionSpec) 
							endif 
						else
							""
						endif
					}
					Comment: "ensure ep_selectedSession is set in the request manager using Store Focus.";
				}
				StringParameter sp_widgetActionsRequestManager {
					IndexDomain: (webui::indexWidgetExtension, webui::indexWidgetActionSpec);
					Definition: {
						{
							('1', 'displaytext') : "Progress window", 
							('1', 'icon'       ) : "aimms-eye4",  
							('1', 'procedure'  ) : "gss::pr_updateProgressWindow", 
							('1', 'state'      ) : "Hidden",  ! not implemented yet - Nested dialogs not yet supported.
						
							('2', 'displaytext') : "Interrupt marked",  
							('2', 'icon'       ) : "aimms-alarm", 
							('2', 'procedure'  ) : "gss::pr_interruptMarked", 
							('2', 'state'      ) : "Active", 
						
							('3', 'displaytext') : "Terminate marked",  
							('3', 'icon'       ) : "aimms-stop", 
							('3', 'procedure'  ) : "gss::pr_terminateMarked",  
							('3', 'state'      ) : "Active", 
						
							('4', 'displaytext') : "Delete marked",  
							('4', 'icon'       ) : "aimms-bin", 
							('4', 'procedure'  ) : "gss::pr_removeMarked", 
							('4', 'state'      ) : "Active", 
						
							('5', 'displaytext') : "mark all",  
							('5', 'icon'       ) : "aimms-cart-add2",  
							('5', 'procedure'  ) : "gss::pr_markAll", 
							('5', 'state'      ) : "Active",   
						
							('6', 'displaytext') : "mark none",  
							('6', 'icon'       ) : "aimms-cart-remove",  
							('6', 'procedure'  ) : "gss::pr_markNone",  
							('6', 'state'      ) : "Active"  
						
						}
					}
				}
				StringParameter sp_titleRequestManager {
					Definition: {
						formatString("Presenting %i sessions, of which %i are queued, %i running, and %i finished (%i have results) - %i marked",
							p_noSessions,  p_noQueuedSessions, p_noRunningSessions, p_noClosedSessions, p_noSessionsWithResults, card(s_sessionMarked) )
					}
				}
				StringParameter sp_logFileContents;
				StringParameter sp_dateToList {
					Definition: {
						formatSTring("%e:00:00",ep_listSessionsSince);
					}
				}
				StringParameter sp_persistentSelectedFolder {
					InitialData: "";
				}
				Parameter bp_mark {
					IndexDomain: i_sess;
					Range: binary;
					InitialData: 0;
					webui::TooltipIdentifier: gss::sp_sessionTooltip(gss::i_sess);
				}
				StringParameter sp_sessionName {
					IndexDomain: i_sess;
					Definition: {
						if bp_isManaged(i_sess) then
						        sp_requestDescription(i_sess)
						else
						        "<<not managed>>"
						endif
					}
				}
				StringParameter sp_currentStatusDescr {
					IndexDomain: i_sess;
					Definition: {
						if(p_currentStatus(i_sess) = 0) then
						"Created"
						elseif(p_currentStatus(i_sess) = 1) then
						"Queued"
						elseif(p_currentStatus(i_sess) = 2) then
						"Starting server session"
						elseif(p_currentStatus(i_sess) = 3) then
						"Waiting for tasks"
						elseif(p_currentStatus(i_sess) = 4) then
						"Running"
						elseif(p_currentStatus(i_sess) = 5) then
						"Closing server session"
						elseif(p_currentStatus(i_sess) = 6) then
						"Finished"
						elseif(p_currentStatus(i_sess) = 7) then
						"Terminated"
						elseif(p_currentStatus(i_sess) = 8) then
						"Finished with errors"
						elseif(p_currentStatus(i_sess) = 9) then
						"Deleted"
						else
						"Unknown"
						endif
					}
				}
				Parameter bp_gotResults {
					IndexDomain: i_sess;
					Range: binary;
					Definition: sp_responseVersionID(i_sess) <> "";
				}
				Set s_sessionMarked {
					SubsetOf: s_sessionList;
					Index: sessMark;
					Definition: {
						{i_sess | bp_mark(i_sess)}
					}
				}
				Parameter p_nonAdminUser {
					InitialData: 1;
					Comment: "See also bp_isAnAdmin";
				}
				Parameter bp_allUsersRequests {
					Range: binary;
					InitialData: 0;
				}
				Parameter bp_markAllRequests {
					Range: binary;
				}
				StringParameter sp_sessionLogFile;
				ElementParameter ep_sessionColor {
					IndexDomain: i_sess;
					Range: AllColors;
					Definition: if i_sess = ep_selectedSession then 'blue' endif;
				}
				Parameter bp_downloadSessionLogFile {
					Definition: {
						if ep_selectedSession then
							if bp_isRunningOnCloud then
								0
							else
								if ep_currentStatus(ep_selectedSession) in s_statusCompleted then
									1
								else
									0
								endif
							endif
						else
							0
						endif
					}
				}
				Procedure pr_markAll {
					Body: {
						bp_mark(i_sess) := 1;
						return 1;
					}
				}
				Procedure pr_markNone {
					Body: {
						bp_mark(i_sess) :=0;
						return 1;
					}
				}
				Procedure pr_seeActions {
					Body: {
						PageOpen("Actions");
						return 1;
					}
				}
				Procedure pr_downloadMarked {
					Body: {
						if Card(s_sessionMarked) = 0 then return 0; endif;
						
						p_ret := pr_exportSessionList(s_sessionMarked);
						if not (p_ret) then return 0; endif;
						
						return 1;
					}
					Parameter p_ret;
				}
				Procedure pr_terminateMarked {
					Body: {
						if Card(s_sessionMarked) = 0 then return 0; endif;
						
						! Remove in batches to prevent call timeouts
						s_sessionsToTerminate := s_sessionMarked;
						for i_sess in s_sessionsToTerminate | bp_isManaged(i_sess) do
						        p_ret := pro::sessionmanager::TerminateSession(i_sess);
						endfor;
						
						! Update session list
						p_ret := pr_updateSessionList;
						if not (p_ret) then return 0; endif;
						
						return 1;
					}
					Set s_sessionsToTerminate {
						SubsetOf: s_sessionList;
					}
					Set s_sessionTerminateList {
						SubsetOf: s_sessionList;
					}
					Parameter p_ret;
					Set s_versionToRemove {
						Parameter: ep_VersionToRemove;
					}
				}
				Procedure pr_interruptMarked {
					Body: {
						if Card(s_sessionMarked) = 0 then return 0; endif;
						
						! Remove in batches to prevent call timeouts
						s_sessionsToTerminate := s_sessionMarked;
						for i_sess in s_sessionsToTerminate | bp_isManaged(i_sess) do
						        p_ret := pr_solveInterrupt(i_sess);
						endfor;
						
						! Update session list
						p_ret := pr_updateSessionList;
						if not (p_ret) then return 0; endif;
						
						return 1;
					}
					Set s_sessionsToTerminate {
						SubsetOf: s_sessionList;
					}
					Set s_sessionTerminateList {
						SubsetOf: s_sessionList;
					}
					Parameter p_ret;
					Set s_versionToRemove {
						Parameter: ep_VersionToRemove;
					}
				}
				Procedure pr_terminateSelected {
					Body: {
						if not ep_selectedSession then return 0; endif;
						
						! Remove in batches to prevent call timeouts
						p_ret := pro::sessionmanager::TerminateSession(ep_selectedSession);
						
						! Update session list
						p_ret := pr_updateSessionList;
						if not (p_ret) then return 0; endif;
						
						return 1;
					}
					Parameter p_ret;
				}
				Procedure pr_interruptSelected {
					Body: {
						if not ep_selectedSession then return 0; endif;
						
						! Remove in batches to prevent call timeouts
						p_ret := pr_solveInterrupt(ep_selectedSession);
						
						! Update session list
						p_ret := pr_updateSessionList;
						if not p_ret then return 0; endif;
						
						return 1;
					}
					Parameter p_ret;
				}
				Procedure pr_removeMarked {
					Body: {
						if Card(s_sessionMarked) = 0 then return 0; endif;
						
						! Remove in batches to prevent call timeouts
						s_sessionsToRemove := s_sessionMarked;
						while (card(s_sessionsToRemove) > 0) do
						        s_sessionRemoveList := SubRange(s_sessionsToRemove, Element(s_sessionsToRemove,1),
						                                                        Element(s_sessionsToRemove,Min(10,Card(s_sessionsToRemove))));
						        s_sessionsToRemove -= s_sessionRemoveList;
						
						        p_ret := pr_purgeSessionList(s_sessionRemoveList);
						        if not (p_ret) then return 0; endif;
						
						        ! Purge all object versions related to managed sessions
						        empty s_versionToRemove;
						        for i_sess in s_sessionRemoveList | bp_isManaged(i_sess) do
						                if(sp_versionID(i_sess) <> "") then SetElementAdd(s_versionToRemove,ep_versionToRemove,sp_versionID(i_sess)); endif;
						                if(sp_responseVersionID(i_sess) <> "") then SetElementAdd(s_versionToRemove,ep_versionToRemove,sp_responseVersionID(i_sess)); endif;
						                if(sp_messageLogVersionID(i_sess) <> "") then SetElementAdd(s_versionToRemove,ep_versionToRemove,sp_messageLogVersionID(i_sess)); endif;
						        endfor;
						        p_ret := pro::storage::DeleteObjectVersionFromSet(s_versionToRemove);
						        if not pro::HandleError(p_ret) then return 0; endif;
						endwhile;
						
						! Update session list
						p_ret := pr_updateSessionList;
						if not (p_ret) then return 0; endif;
						
						return 1;
					}
					Set s_sessionsToRemove {
						SubsetOf: s_sessionList;
					}
					Set s_sessionRemoveList {
						SubsetOf: s_sessionList;
					}
					Parameter p_ret;
					Set s_versionToRemove {
						Parameter: ep_versionToRemove;
					}
				}
				Procedure pr_removeSelected {
					Body: {
						if not ep_selectedSession then return 0; endif ;
						
						! Remove in batches to prevent call timeouts
						s_sessionsToRemove := ep_selectedSession ;
						while (card(s_sessionsToRemove) > 0) do
						        s_sessionRemoveList := s_sessionsToRemove ;
						        s_sessionsToRemove := {};
						
						        p_ret := pr_purgeSessionList(s_sessionRemoveList);
						        if not (p_ret) then return 0; endif;
						
						        ! Purge all object versions related to managed sessions
						        empty s_versionToRemove;
						        for i_sess in s_sessionRemoveList | bp_isManaged(i_sess) do
						                if(sp_versionID(i_sess) <> "") then SetElementAdd(s_versionToRemove,ep_versionToRemove,sp_versionID(i_sess)); endif;
						                if(sp_responseVersionID(i_sess) <> "") then SetElementAdd(s_versionToRemove,ep_versionToRemove,sp_responseVersionID(i_sess)); endif;
						                if(sp_messageLogVersionID(i_sess) <> "") then SetElementAdd(s_versionToRemove,ep_versionToRemove,sp_messageLogVersionID(i_sess)); endif;
						        endfor;
						        p_ret := pro::storage::DeleteObjectVersionFromSet(s_versionToRemove);
						        if not pro::HandleError(p_ret) then return 0; endif;
						endwhile;
						
						! Update session list
						p_ret := pr_updateSessionList;
						if not (p_ret) then return 0; endif;
						
						return 1;
					}
					Set s_sessionsToRemove {
						SubsetOf: s_sessionList;
					}
					Set s_sessionRemoveList {
						SubsetOf: s_sessionList;
					}
					Parameter p_ret;
					Set s_versionToRemove {
						Parameter: ep_versionToRemove;
					}
				}
				Procedure pr_downloadAndOpenLog {
					Body: {
						return pr_saveAndOpenVersionInTemp(sp_messageLogVersionID(ep_selectedSession));
					}
				}
				Procedure pr_updateSessionList {
					Body: {
						! Initialize PRO Framework (if not initialized yet)
						p_ret := pro::Initialize();
						if not (p_ret) then return 0; endif;
						
						p_nonAdminUser := 1 - bp_isAnAdmin ; ! Initialied in PostLibraryInitialization.
						
						p_ret := pro::session::LoadManagedSessions;
						if not (p_ret) then return 0; endif;
						
						pro::StatusMessage("");
						
						! Store the currently selected session.
						sp_storedSelectedSession := ep_selectedSession;
						if pr_loadSessionList(sp_dateToList, bp_allUsers, bp_allModels, bp_allVersions) then
						        ! Set selectedSession to the storedSelectedSession if it is still in the SessionList.
						        ep_selectedSession := StringToElement(s_sessionList, sp_storedSelectedSession);
						        return 1;
						else
						        return 0;
						endif;
					}
					Parameter p_ret;
					StringParameter sp_storedSelectedSession;
				}
				Procedure pr_loadRequestResponse {
					Body: {
						!DebuggerBreakpoint();
						
						if ep_selectedSession = '' then return 0; endif;
						
						pro::session::SetSessionData(ep_selectedSession, 
							sp_requestDescription(ep_selectedSession),
						        sp_clientQueue(ep_selectedSession),
						        sp_workerQueue(ep_selectedSession),
						        sp_requestProcedure(ep_selectedSession),
						        p_runTimeOut(ep_selectedSession),
						        sp_versionID(ep_selectedSession),
						        sp_responseVersionID(ep_selectedSession),
						        sp_messageLogVersionID(ep_selectedSession),
						        sp_errorMessage(ep_selectedSession),
						        sp_requestTime(ep_selectedSession),
						        sp_originalCasePath(ep_selectedSession));
						
						p_ret := pr_loadResponse(ep_selectedSession);
						if not (p_ret) then return 0; endif;
						
						gss::pr_saveTrackedSessionData( ep_selectedSession );
						
						if ep_loadResponseCallbackHook then
							sp_requestId := sp_responseVersionID(ep_selectedSession);
							apply( ep_loadResponseCallbackHook, sp_requestId );
						endif ;
					}
					Parameter p_ret;
					StringParameter sp_requestId;
				}
				Procedure pr_closeRequestManager {
					Body: {
						return PageClose("Managed Requests");
					}
				}
				Section Download_Session_Log {
					Procedure pr_downloadSessionLog {
						Arguments: (FileLocation,StatusCode,StatusDescription);
						Body: {
							Block
								!FileLocation := "circle.png";
								pr_getSessionLogFile(ep_selectedSession, sp_originalSessionLogfileLocation);
								if sp_originalSessionLogfileLocation then
									p_slashFwd := FindNthString( sp_originalSessionLogfileLocation, "/", -1 );
									p_slashBwd := FindNthString( sp_originalSessionLogfileLocation, "\\", -1 );
									p_slash := max( p_slashFwd, p_slashBwd);
									if p_slash then
										p_len := StringLength( sp_originalSessionLogfileLocation );
										fileLocation := SubString( sp_originalSessionLogfileLocation, p_slash+1, p_len); 
										pr_logMsg(formatString("sp_originalSessionLogfileLocation = \"%s\", fileLocation = \"%s\"", 
											sp_originalSessionLogfileLocation, fileLocation ));		
										FileCopy( sp_originalSessionLogfileLocation, fileLocation );
									else
										fileLocation := sp_originalSessionLogfileLocation;
									endif ;
							
									sp_FileProcessSpecificFileName := webui::GetIOFilePath(FileLocation);
									if fileLocation <> sp_FileProcessSpecificFileName then
										fileCopy( fileLocation, sp_FileProcessSpecificFileName );
									endif ;
							
									StatusCode := webui::ReturnStatusCode('CREATED');
									StatusDescription := "Nice.";
								else	
									raise warning "session log file not found for session: " + ep_selectedSession;
									StatusCode := webui::ReturnStatusCode('ERROR');
									StatusDescription := "Oops, " + "session log file not found for session: " + ep_selectedSession;
								endif ;
							OnError ep_err Do
								if errh::Severity( ep_err ) <> 'warning' then
									StatusCode := webui::ReturnStatusCode('ERROR');
									StatusDescription := "Oops: " + errh::Message(ep_err) ;
									errh::MarkAsHandled(ep_err);
									break ; ! Trick to reporting one error.
								endif ;
							EndBlock ;
						}
						StringParameter FileLocation {
							Property: Output;
						}
						Parameter StatusCode {
							Property: Output;
						}
						StringParameter StatusDescription {
							Property: Output;
						}
						StringParameter sp_FileProcessSpecificFileName;
						ElementParameter ep_err {
							Range: errh::PendingErrors;
						}
						StringParameter sp_originalSessionLogfileLocation;
						Parameter p_slashFwd;
						Parameter p_slashBwd;
						Parameter p_slash;
						Parameter p_len;
					}
					Procedure pr_getSessionLogFile {
						Arguments: (ep_selectedSession,sp_originalSessionLogfileLocation);
						Body: {
							!DebuggerBreakpoint();
							pr_logMsg("Starting pr_getSessionLogFile();");
							EnvironmentGetString(
								Key   :  "AIMMSPRO_DATADIR", 
								Value :  sp_proDataDir);
							sp_sessionLogDir := sp_proDataDir + "\\Log\\Sessions";
							pr_logMsg(formatString("sp_sessionLogDir = %s", sp_sessionLogDir ));
							
							DirectoryGetFiles(
								directory       :  sp_sessionLogDir, 
								filter          :  "*.log", 
								filenames       :  sp_filenames(i_fileNumber), 
								recursive       :  0);
							for i_fileNumber do
								pr_logMsg(formatSTring("    log session file: %e : %s", i_filenumber, sp_filenames(i_filenumber)));
							endfor ;
							ep_logFileNo := first( i_fileNumber | findString(sp_filenames(i_fileNumber), ep_selectedSession ) );
							pr_logMsg(formatString("ep_logFileNo = %e", ep_logFileNo ));
							if ep_logFileNo then
								sp_originalSessionLogfileLocation := sp_sessionLogDir + "\\" + sp_filenames(ep_logFileNo);
							else
								sp_originalSessionLogfileLocation := "" ;
								raise warning "session log file for " + ep_selectedSession + " not found." ;
							endif ;
							pr_logMsg(formatString("finished pr_getSessionLogFile(); sp_originalSessionLogfileLocation = %s ", 
								sp_originalSessionLogfileLocation));
						}
						Comment: {
							"find the location on the current 
							AIMMS PRO on prem server of the session log file 
							of session ep_selectedSession."
						}
						StringParameter ep_selectedSession {
							Property: Input;
						}
						StringParameter sp_originalSessionLogfileLocation {
							Property: Output;
						}
						StringParameter sp_proDataDir;
						StringParameter sp_sessionLogDir;
						Set s_fileNumbers {
							SubsetOf: Integers;
							Index: i_fileNumber;
						}
						StringParameter sp_filenames {
							IndexDomain: i_filenumber;
						}
						ElementParameter ep_logFileNo {
							Range: s_fileNumbers;
						}
					}
				}
			}
			Section Inspect_running_sessions {
				Set s_runningSessions {
					SubsetOf: s_sessionList;
					Index: i_runningSess;
					Definition: {
						{ i_sess | ep_currentStatus( i_sess ) in s_runningSessionStates }
					}
				}
				StringParameter sp_itemActionsRunningSessions {
					IndexDomain: (webui::indexWidgetItemActionSpec,webui::indexPageExtension,webui::indexWidgetActionSpec);
					Definition: {
						if webui::indexWidgetItemActionSpec in s_selectedActionSpecIdentifiers then
							sp_itemActionsRunningSessionsBase(webui::indexPageExtension, webui::indexWidgetActionSpec) 
						else
							""
						endif
					}
				}
				StringParameter sp_widgetActionsRunningSessions {
					IndexDomain: (webui::indexWidgetExtension, webui::indexWidgetActionSpec);
					Definition: {
						{
							('1', 'displaytext') : "Progress window", 
							('1', 'icon'       ) : "aimms-eye4",  
							('1', 'procedure'  ) : "gss::pr_updateProgressWindow", 
							('1', 'state'      ) : "Hidden",                                  ! not implemented - nested dialogs not (yet) supported. 
						
							('2', 'displaytext') : "Refresh list", 
							('2', 'icon'       ) : "aimms-eye-plus",  
							('2', 'procedure'  ) : "gss::pr_refreshRunningList", 
							('2', 'state'      ) : "Active", 
						
							('3', 'displaytext') : "Interrupt marked", 
							('3', 'icon'       ) : "aimms-alarm",  
							('3', 'procedure'  ) : "gss::pr_interruptMarked", 
							('3', 'state'      ) : "Active",  
						
							('4', 'displaytext') : "Terminate marked",  
							('4', 'icon'       ) : "aimms-stop", 
							('4', 'procedure'  ) : "gss::pr_terminateMarked", 
							('4', 'state'      ) : "Active", 
						
							('5', 'displaytext') : "Delete marked",  
							('5', 'icon'       ) : "aimms-bin", 
							('5', 'procedure'  ) : "gss::pr_removeMarked", 
							('5', 'state'      ) : "Active", 
						
							('6', 'displaytext') : "mark all",  
							('6', 'icon'       ) : "aimms-cart-add2", 
							('6', 'procedure'  ) : "gss::pr_markAll", 
							('6', 'state'      ) : "Active", 
						
							('7', 'displaytext') : "mark none", 
							('7', 'icon'       ) : "aimms-cart-remove", 
							('7', 'procedure'  ) : "gss::pr_markNone", 
							('7', 'state'      ) : "Active"  
						
						}
					}
				}
				StringParameter sp_itemActionsRunningSessionsBase {
					IndexDomain: (webui::indexPageExtension,webui::indexWidgetActionSpec);
					Definition: {
						{
							(  '1', 'displaytext') : "Show progress", 
							(  '1', 'icon'       ) : "aimms-file-download2", 
							(  '1', 'procedure'  ) : "gss::pr_showProgress", 
							(  '1', 'state'      ) : "Active",
						
							(  '2', 'displaytext') : "Interrupt solver of this session",
							(  '2', 'icon'       ) : "aimms-alarm",
							(  '2', 'procedure'  ) : "gss::pr_interruptSelected",
							(  '2', 'state'      ) : "Active",
						
							(  '3', 'displaytext') : "Terminate this session",
							(  '3', 'icon'       ) : "aimms-stop",
							(  '3', 'procedure'  ) : "gss::pr_terminateSelected",
							(  '3', 'state'      ) : "Active"
						
						
						}
					}
				}
				StringParameter sp_titleRunningSessionList {
					Definition: "Running session list";
				}
				Procedure pr_refreshRunningList {
					Body: {
						pr_enter(sp_gssTime, p_gssMiU);
						
						if pro::GetPROEndPoint() then
							pr_updateSessionList();
						endif ;
						
						pr_leave(sp_gssTime, p_gssMiU);
					}
					DeclarationSection gss_logging_declarations {
						StringParameter sp_gssTime;
						Parameter p_gssMiU;
					}
				}
			}
			Section Load_Response_GUI {
				Procedure DefaultCallBack {
					Arguments: (RequestID);
					Body: {
						! Notify the user discretely
						SessionElement := StringToElement(pro::session::ManagedSessions,RequestID);
						tmpStr := "*** " + CurrentToString("%H:%M:%S") + " - New request result available: '" + pro::session::RequestDescription(SessionElement) + "'! Check Request Manager! ***";
						!pro::StatusMessage(tmpStr);
						sp_lastSessionNotification := tmpStr ;
					}
					ElementParameter SessionElement {
						Range: pro::session::ManagedSessions;
					}
					StringParameter tmpStr {
						InitialData: "";
					}
					StringParameter RequestID {
						Property: Input;
					}
				}
				Procedure pr_loadResponseAction {
					Body: {
						! Prepare case to load
						if ep_originalCase <> '' then
						        pro::version::ResetCaseStatus();
						        pro::version::LoadCaseAsCurrent(ep_originalCase);
						else
						        pro::version::NewCase();
						endif;
						
						! Get the case file and the message log from the Storage Service
						if sp_messageLogVersionID(ep_request) <> "" then
							p_ret := pro::LoadLogMessages(sp_messageLogVersionID(ep_request), sp_tmpFileLog);
							if p_ret then 
								sp_logFileContents := FileRead( sp_tmpFileLog );
							else
								raise warning "unable to load log messages" ;
							endif ;
						endif;
						
						! Load Case file
						p_ret := pro::LoadCaseFromObjectVersion(sp_responseVersionID(ep_request));
						if p_ret then
							Apply(pro::session::PostLoadResultCaseHook);
						else
							raise error "Error during load. File corrupted." ;
						        pro::DialogMessage("Error during load. File corrupted.", "PRO Framework - Load Solution");
						        ! Maybe the case has problems because of some execution error; check messages.log if it exists
						!        if MessageLogVersionID(Request) <> "" then
						!                 ShowMessageWindow();
						!        endif;
						endif;
					}
					Parameter p_ret;
					StringParameter sp_tmpFile {
						InitialData: "";
					}
					StringParameter sp_tmpFileLog {
						InitialData: "";
					}
				}
				Set s_loadOptions;
				ElementParameter ep_request {
					Range: s_sessionList;
				}
				ElementParameter ep_originalCase {
					Range: AllCases;
					InitialData: '';
				}
				StringParameter sp_warningNonSavedData;
				StringParameter sp_lastSessionNotification {
					InitialData: "-";
				}
				ElementParameter ep_loadResponseCallbackHook {
					Range: AllIdentifiers;
					Default: 'gss::pr_responseProtocol';
				}
			}
		}
		Section progress_Window {
			Property: NoSave;
			Parameter p_progressColWidth {
				InitialData: 40;
			}
			ElementParameter ep_watchedSession {
				Range: s_sessionList;
				InitialData: '';
			}
			Parameter p_updateDelay {
				Range: integer;
				InitialData: 2000;
				Comment: "Number of milliseconds between progress calls.";
			}
			ElementParameter ep_updateSession {
				Range: s_sessionList;
			}
			Parameter p_updateRequested {
				Range: binary;
				InitialData: 0;
				Comment: "Set to 1 by";
			}
			Set s_timeSlots {
				Index: i_timeSlot;
				Parameter: ep_timeElement;
				OrderBy: i_timeSlot;
			}
			Parameter p_noTimeSlots {
				Definition: card( s_timeSlots );
			}
			Parameter p_noProgressShownTimeSlotsTarget {
				InitialData: 3;
			}
			Parameter p_progressShowTimeSlotsDivisor {
				Definition: Max(1, ceil( p_noTimeSlots / p_noProgressShownTimeSlotsTarget ) );
			}
			Parameter p_progressShowTimeSlotsRemainder {
				Definition: {
					if p_progressShowTimeSlotsDivisor > 1 then
						mod( p_noTimeSlots, p_progressShowTimeSlotsDivisor )
					else
						0
					endif
				}
			}
			Set s_progressTimeSlots {
				SubsetOf: s_timeSlots;
				Index: i_progressTimeslot;
				Definition: {
					{ i_timeSlot | mod( ord(i_timeSlot), p_progressShowTimeSlotsDivisor ) = p_progressShowTimeSlotsRemainder }
				}
			}
			StringParameter sp_progressTitle {
				Definition: {
					"Progress data of " 
					+
					if sp_requestDescription(ep_selectedSession) then
						sp_requestDescription(ep_selectedSession)
					else
						ep_selectedSession
					endif
					+
					formatString(" showing %i out of %i progress snapshots", 
						card( s_progressTimeSlots ), p_noTimeSlots )
				}
			}
			Set s_items {
				Index: i_item;
				Parameter: ep_ItemElement;
				OrderBy: p_itemOrder(i_item);
			}
			Set s_shownItemsRunningSession {
				SubsetOf: s_items;
				Index: i_shownItem;
				Definition: {
					s_items 
						- StringToElement(s_items,"LastUpdate") 
						- StringToElement(s_items,"Request") 
						- StringToElement(s_items,"UserName")
				}
			}
			Parameter p_noGapObjDevShownTimeSlotsTarget {
				InitialData: 20;
			}
			Parameter p_gapObjDevShowTimeSlotsDivisor {
				Definition: Max(1, ceil( p_noTimeSlots / p_noGapObjDevShownTimeSlotsTarget ) );
			}
			Parameter p_gapObjDevShowTimeSlotsRemainder {
				Definition: {
					if p_gapObjDevShowTimeSlotsDivisor > 1 then
						mod( p_noTimeSlots, p_gapObjDevShowTimeSlotsDivisor )
					else
						0
					endif
				}
			}
			Set s_gapObjDevTimeSlots {
				SubsetOf: s_timeSlots;
				Index: i_gapObDevTimeslot;
				Definition: {
					{ i_timeSlot | mod( ord(i_timeSlot), p_gapObjDevShowTimeSlotsDivisor ) = p_gapObjDevShowTimeSlotsRemainder }
				}
			}
			Parameter p_itemOrder {
				IndexDomain: i_item;
				Range: integer;
				Default: 0;
				InitialData: 0;
			}
			StringParameter sp_value {
				IndexDomain: (i_timeSlot,i_item);
			}
			StringParameter sp_workerValue {
				IndexDomain: (i_item);
				Definition: sp_value('worker',i_item);
			}
			Parameter p_GAP {
				IndexDomain: (i_timeSlot);
			}
			Parameter p_Incumbent {
				IndexDomain: i_timeSlot;
			}
			Parameter p_Bestbound {
				IndexDomain: i_timeSlot;
			}
			Parameter p_progressLinechartLower;
			Parameter p_progressLinechartUpper;
			StringParameter sp_beginTime;
			StringParameter sp_endTime;
			Parameter p_watchedSessionNotRunning {
				Range: binary;
				Definition: if (ep_watchedSession and pro::session::ActiveSessionRunning) then 0 else 1 endif;
			}
			Parameter p_pausedSessionNotRunning {
				Range: binary;
				Definition: if ((ep_watchedSession or ep_pausedSession) and pro::session::ActiveSessionRunning) then 0 else 1 endif;
			}
			Procedure pr_updateCallBack {
				Arguments: (ep_gmp);
				Body: {
					gss::pr_enter(sp_gssTime, p_gssMiU, ep_messageImportance: 'info');
					! If requested, collect and send data
					p_retval := 1;
					if p_updateRequested then
					        empty s_items, sp_value;
					        s_timeSlots := {'worker'};
					
					        ! Session basic data
					        SetElementAdd(s_items,ep_ItemElement,"Username");
					        sp_value('worker',ep_ItemElement) := pro::GetPROUserName + "@" + pro::GetPROEnvironment;
					
					        ! Mathematical program data
					        if (ep_gmp <> '') then
					                ep_mpType := GMP::Instance::GetMathematicalProgrammingType(ep_gmp);
					
					                SetElementAdd(s_items,ep_ItemElement,"# Rows");
					                sp_value('worker',ep_ItemElement) := FormatString("%i",GMP::Instance::GetNumberOfRows(ep_gmp));
					
					                SetElementAdd(s_items,ep_ItemElement,"# Cols");
					                if (ep_mpType='MIP' or ep_mpType='MIQP' or ep_mpType='MIQCP' or ep_mpType='COP' or ep_mpType='CSP') then
					                	sp_value('worker',ep_ItemElement) := FormatString("%i (%i int)", GMP::Instance::GetNumberOfColumns(ep_gmp),
					                	                                                     GMP::Instance::GetNumberOfIntegerColumns(ep_gmp));
					                else
					                	sp_value('worker',ep_ItemElement) := FormatString("%i",GMP::Instance::GetNumberOfColumns(ep_gmp));
					                endif;
					
					                SetElementAdd(s_items,ep_ItemElement,"# NZ");
					                sp_value('worker',ep_ItemElement) := FormatString("%i",GMP::Instance::GetNumberOfNonzeros(ep_gmp));
					
					                SetElementAdd(s_items,ep_ItemElement,"Solver");
					                sp_value('worker',ep_ItemElement) := GMP::Instance::GetSolver(ep_gmp);
					
					                if (ep_mpType='LP' or ep_mpType='NLP' or ep_mpType='QP' or ep_mpType='QCP' or ep_mpType='COP' or ep_mpType='CSP') then
					                        SetElementAdd(s_items,ep_ItemElement,"Objective");
					                        sp_value('worker',ep_ItemElement) := GMP::Solution::GetObjective(ep_gmp,1);
					
					                elseif (ep_mpType='MIP' or ep_mpType='MIQP' or ep_mpType='MIQCP') then
					        		p_bestBnd := GMP::Solution::GetBestBound(ep_gmp,1);
					        		if ( MapVal( p_bestBnd ) ) then
					        			p_bestBnd := na;
					        		elseif ( Abs( p_bestBnd ) >= 1e50 ) then
					        			p_bestBnd := na;
					        		endif;
					
					                        SetElementAdd(s_items,ep_ItemElement,"Best Bound");
					                        sp_value('worker',ep_ItemElement) := FormatString("%<4.2f",p_bestBnd);
					
					                        SetElementAdd(s_items,ep_ItemElement,"Incumbent");
					                        sp_value('worker',ep_ItemElement) := FormatString("%<4.2f",GMP::Solution::GetObjective(ep_gmp,1)); ! May need to use p_incumbent.
					
					                        SetElementAdd(s_items,ep_ItemElement,"Gap");
					                        sp_value('worker',ep_ItemElement) := FormatString("%<3.1f",100*Abs((GMP::Solution::GetObjective(ep_gmp,1) - p_bestBnd)
					                                                /$
					                                                GMP::Solution::GetObjective(ep_gmp,1)));
					
					                        SetElementAdd(s_items,ep_ItemElement,"Nodes");
					                        sp_value('worker',ep_ItemElement) := FormatString("%i",GMP::Solution::GetNodesUsed(ep_gmp,1));
					                endif;
					
					                SetElementAdd(s_items,ep_ItemElement,"Memory");
					                sp_value('worker',ep_ItemElement) := FormatString("%3.2f Mb",GMP::Solution::GetMemoryUsed(ep_gmp,1));
					
					                SetElementAdd(s_items,ep_ItemElement,"Program Status");
					                sp_value('worker',ep_ItemElement) := GMP::Solution::GetProgramStatus(ep_gmp,1);
					
							if ( ep_mpType='COP' or ep_mpType='CSP') then
								ep_currentMathematicalProgram := GMP::Instance::GetSymbolicMathematicalProgram(ep_gmp);
					
								SetElementAdd(s_items,ep_ItemElement,"Branches");
					                	if pro::management::GetScalarSuffixValue(ep_currentMathematicalProgram,"NumberOfBranches",sp_tmpStr) then sp_value('worker',ep_ItemElement) := FormatString("%i",Val(sp_tmpStr)); endif;
					
					                	SetElementAdd(s_items,ep_ItemElement,"Failures");
					                	if pro::management::GetScalarSuffixValue(ep_currentMathematicalProgram,"NumberOfFails",sp_tmpStr) then sp_value('worker',ep_ItemElement) := FormatString("%i",Val(sp_tmpStr)); endif;
							else
					                	SetElementAdd(s_items,ep_ItemElement,"Iterations");
					                	sp_value('worker',ep_ItemElement) := FormatString("%i",GMP::Solution::GetIterationsUsed(ep_gmp,1));
					                endif;
					
					                SetElementAdd(s_items,ep_ItemElement,"Solution Time");
					                sp_value('worker',ep_ItemElement) := FormatString("%4.2f",GMP::Solution::GetCPUSecondsUsed(ep_gmp,1)/100);
					        endif;
					
					        p_updateRequested := 0;
					        pr_updateWindowAction(ep_updateSession,CurrentToString("%H:%M:%S"),s_items,sp_workerValue);
					endif;
					
					gss::pr_leave(sp_gssTime, p_gssMiU, ep_messageImportance: 'info');
					
					
					! When this callback gets executed through GMP, the return value 1 indicates that the solve should continue.
					! Without it, the solve will aborted. When solving via the SOLVE statement, aborting the solve is arranged via
					! .CallbackReturnStatus suffix of the math program.
					return p_retval;
				}
				Comment: "Collect execution information and send to be shown in Progress Window client-side";
				DeclarationSection gss_logging_declarations {
					StringParameter sp_gssTime;
					Parameter p_gssMiU;
				}
				Parameter p_retval;
				ElementParameter ep_mpType {
					Range: AllMathematicalProgrammingTypes;
				}
				ElementParameter ep_currentMathematicalProgram {
					Range: AllMathematicalPrograms;
				}
				StringParameter sp_tmpStr;
				Parameter p_bestBnd;
				ElementParameter ep_gmp {
					Range: AllGeneratedMathematicalPrograms;
					Property: Input;
				}
			}
			Procedure pr_activate {
				Arguments: (ep_sessionElement);
				Body: {
					gss::pr_enter(sp_gssTime, p_gssMiU, ep_messageImportance: 'info', 
						sp_logdetail:formatString("(%e) watched=%e",ep_sessionElement,ep_watchedSession));
					if ep_sessionElement = '' then
					        ! Deactivate updates
					        ep_watchedSession := '';
					        pro::session::SetActiveSession(ep_watchedSession);
					
					elseif ep_sessionElement <> ep_watchedSession then
					        empty s_timeSlots, s_items, sp_value;
					
					        if ep_watchedSession = '' then
					                ! Activate updates
					                ep_watchedSession := ep_sessionElement;
					                pro::session::SetActiveSession(ep_watchedSession);
					
					                sp_nextCheck := CurrentToString("%c%y-%m-%d %H:%M:%S");
					                s_items := {'Connecting to session...'};
					                pr_repeatUpdate;
					        else
					                ! Redefines session to be updated
					                ep_watchedSession := ep_sessionElement;
					                pro::session::SetActiveSession(ep_watchedSession);
					        endif;
					
					        !PageOpen("Progress Window");
					else
					        ! Deactivate updates
					        ep_watchedSession := '';
					        pro::session::SetActiveSession(ep_watchedSession);
					endif;
					gss::pr_leave(sp_gssTime, p_gssMiU, ep_messageImportance: 'info', 
						sp_logdetail:formatString("(Watched session is now %e)",ep_watchedSession));
					return 1;
				}
				DeclarationSection gss_logging_declarations {
					StringParameter sp_gssTime;
					Parameter p_gssMiU;
				}
				ElementParameter ep_sessionElement {
					Range: s_sessionList;
					Property: Input;
				}
			}
			Procedure pr_repeatUpdate {
				Body: {
					gss::pr_enter(sp_gssTime, p_gssMiU, ep_messageImportance: 'info');
					if p_watchedSessionNotRunning then 
						gss::pr_leave(sp_gssTime, p_gssMiU, ep_messageImportance: 'info',
							sp_logDetail:"reason: p_watchedSessionNotRunning");
						return 0;
					
					! Run update and schedule nex check
					elseif pr_updateWindow(ep_watchedSession) then
					        if pro::GetPROLastErrorMessage = "" then
					        	pr_scheduleOver( (p_updateDelay/1000)[s], 'gss::pr_repeatUpdate' );
					        else
					                ep_watchedSession := '';
					                pro::session::SetActiveSession(ep_watchedSession);
					        endif;
					endif;
					gss::pr_leave(sp_gssTime, p_gssMiU, ep_messageImportance: 'info');
					return 1;
				}
				DeclarationSection gss_logging_declarations {
					StringParameter sp_gssTime;
					Parameter p_gssMiU;
				}
			}
			Procedure pr_updateWindow {
				Arguments: (ep_sessionToUpdate,p_updateDelay);
				Body: {
					! Basic validation
					if ep_sessionToUpdate = '' then
					        raise error "Invalid request reference" code 'PRO-Invalid-request-reference-update-progress' ;
					        return 0;
					elseif p_updateDelay < 1000 then
					        raise error "The update frequency must be greater than 1 second" code 'PRO-invalid-update-frequency' ;
					        return 0;
					endif;
					
					! If the PRO library has not been finalized do not call the server.
					if (not pro::management::IsInitialized()) then return 0; endif;
					
					! Delegate the remainder of the execution to the server side
					return pr_updateWindowServer(ep_sessionToUpdate, p_updateDelay);
				}
				Comment: "Collect execution information and send to be shown in Progress Window client-side";
				ElementParameter ep_sessionToUpdate {
					Range: s_sessionList;
					Property: Input;
				}
				Parameter p_updateDelay {
					Range: integer;
					Default: 5000;
					Property: Optional;
				}
			}
			Procedure pr_updateWindowServer {
				Arguments: (ep_sessionToUpdate,p_updateDelay);
				Body: {
					! Execution at the server side
					if pro::DelegateToServer(
					        RequestQueue : sp_workerQueue(ep_sessionToUpdate),
					        flags : pro::PROMFLAG_PRIORITY + pro::PROMFLAG_LIVE
					) then return 1; endif;
					
					! Request data to be collect during next callback
					ep_updateSession  := ep_sessionToUpdate;
					p_updateRequested := 1;
					
					return 1;
				}
				Comment: "Collect execution information and send to be shown in Progress Window client-side";
				ElementParameter ep_sessionToUpdate {
					Range: s_sessionList;
					Property: Input;
				}
				Parameter p_updateDelay {
					Range: integer;
					Default: 5000;
					Property: Optional;
				}
			}
			Procedure pr_updateWindowAction {
				Arguments: (ep_sessionToUpdate,sp_argTime,s_argItems,sp_argValue);
				Body: {
					gss::pr_enter(sp_gssTime, p_gssMiU, ep_messageImportance: 'info',
						sp_logdetail: formatString("(%e,%s,%i items,*)",ep_sessionToUpdate,sp_argTime,card(s_argItems)));
					
					! Execution at the client side
					if pro::DelegateToClient(
					        procedureName : 'gss::pr_updateWindowAction',
					        flags : pro::PROMFLAG_LIVE
							) then 
						gss::pr_leave(sp_gssTime, p_gssMiU, ep_messageImportance: 'info', sp_logDetail:"reason: in server session");
						return 1; 
					endif;
					
					! Only update the progress window if the update message coming in is actually for the session
					! we're watching. This situation may occur if the same user has multiple PRO clients opened
					! simultaneously.
					if (ep_sessionToUpdate <> ep_watchedSession) then
						gss::pr_leave(sp_gssTime, p_gssMiU, ep_messageImportance: 'info', sp_logDetail:formatString("reason: ep_sessionToUpdate = %e, ep_watchedSession = %e", ep_sessionToUpdate, ep_watchedSession));
					        return;
					endif;
					
					if StringToElement(s_items,"connecting to session...") then
					        s_items -= 'connecting to session...';
					endif;
					
					! Add the new values and update current PW_Time_Element
					ep_timeElement := StringToElement(s_timeSlots,sp_argTime,create:1);
					
					SetElementAdd(s_items,ep_ItemElement,"LastUpdate");
					sp_value(ep_timeElement,ep_ItemElement) := sp_argTime;
					SetElementAdd(s_items,ep_ItemElement,"Request");
					sp_value(ep_timeElement,ep_ItemElement) := sp_requestDescription(ep_selectedSession);
					
					for i_argItem do
					        SetElementAdd(s_items,ep_ItemElement,i_argItem);
					        sp_value(ep_timeElement,ep_ItemElement) := sp_argValue(i_argItem);
					endfor;
					
					! GAP or objective value for graphics
					if StringToElement(s_argItems,"Gap") <> '' then
					        p_GAP(ep_timeElement) := Val(sp_value(ep_timeElement,'Gap'));
					        p_Incumbent(ep_timeElement) := Val(sp_value(ep_timeElement,'Incumbent'));
					        p_BestBound(ep_timeElement) := Val(sp_value(ep_timeElement,'Best Bound'));
					        pr_logMsg(formatString("for %e: gap=%n, inc=%n, bb=%n", ep_timeElement, p_GAP(ep_timeElement), p_Incumbent(ep_timeElement), p_BestBound(ep_timeElement)),'debug');
					        sp_chartLabel := "GAP Evolution:";
					        if card( s_items ) = 1 then
					        	if p_Incumbent(ep_timeElement) > p_BestBound(ep_timeElement) then
					        	else
					        	endif ;
					        endif ;
					else
					        p_GAP(ep_timeElement) := Val(sp_value(ep_timeElement,'Objective'));
					        sp_chartLabel := "Objective:";
					endif;
					
					!! Limit number of points
					!While Card(s_timeSlots) > 100 do 
					!	s_timeSlots -= First(s_timeSlots); 
					!endwhile;
					
					! GUI: Correct ordening of items.
					pr_updateProgressWindowOrdening;
					!PageRefreshAll;
					gss::pr_leave(sp_gssTime, p_gssMiU, ep_messageImportance: 'info', sp_logDetail:"reason: end of proc");
					
					return 1;
				}
				Comment: "Receives a vector of elements to be displayed in Progress Window";
				DeclarationSection gss_logging_declarations {
					StringParameter sp_gssTime;
					Parameter p_gssMiU;
				}
				ElementParameter ep_sessionToUpdate {
					Range: s_sessionList;
					Property: Input;
				}
				StringParameter sp_argTime {
					Property: Input;
				}
				Set s_argItems {
					Index: i_argItem;
					Property: Input;
				}
				StringParameter sp_argValue {
					IndexDomain: i_argItem;
					Property: Input;
				}
				Parameter p_linechartLow;
				Parameter p_linechartUpp;
			}
			Procedure pr_showProgress {
				Body: {
					pr_enter(sp_gssTime, p_gssMiU, ep_messageImportance: 'info');
					
					pr_activate(ep_selectedSession);
					
					pr_leave(sp_gssTime, p_gssMiU, ep_messageImportance: 'info');
				}
				DeclarationSection gss_logging_declarations {
					StringParameter sp_gssTime;
					Parameter p_gssMiU;
				}
			}
			Section Progress_Windows_GUI {
				StringParameter sp_nextCheck {
					Default: "";
				}
				ElementParameter ep_pausedSession {
					Range: s_sessionList;
					InitialData: '';
				}
				StringParameter sp_label {
					Definition: {
						if ep_watchedSession = "" or ep_selectedSession <> ep_watchedSession then
						        "Progress Window"
						else
						        "Stop Progress Window"
						endif
					}
				}
				StringParameter sp_chartLabel {
					InitialData: "";
				}
				StringParameter sp_titleGapEvolutionWidget {
					Definition: {
						formatString("%s showing %i data points out of %i", 
							sp_chartLabel, card(s_gapObjDevTimeSlots), card(s_timeSlots) )
					}
				}
				StringParameter sp_pauseResumeLabel {
					Definition: {
						if ep_watchedSession = "" then
						        "Resume Updates"
						else
						        "Pause Updates"
						endif
					}
				}
				ElementParameter ep_pauseResumeColor {
					Range: AllColors;
					Definition: {
						if ep_watchedSession = "" then
						        'light grey'
						else
						        'white'
						endif
					}
				}
				ElementParameter ep_lineColor {
					IndexDomain: i_item;
					Range: AllColors;
					Definition: {
						if p_itemOrder(i_item) > 0 and Mod(p_itemOrder(i_item),100) = 0 then 'blue'
						else 'black' endif
					}
				}
				Set s_frequency {
					Index: i_freq;
					Parameter: ep_freqElement;
					Definition: data { '5 seconds', '15 seconds', '1 minute', '5 minutes' };
				}
				Parameter p_freqValue {
					IndexDomain: (i_freq);
					Range: integer;
					Definition: data { '5 seconds' : 5000,  '15 seconds' : 15000,  '1 minute' : 60000,  '5 minutes' : 300000 };
				}
				Parameter bp_showDetails {
					Range: binary;
					InitialData: 0;
				}
				Parameter p_resume {
					IndexDomain: i_item;
					Range: binary;
					Definition: {
						if      i_item = "PRO SESSION" or
						        i_item = "Request" or
						        i_item = "LastUpdate" or
						        i_item = "SOLVER SESSION" or
						        i_item = "Best Bound" or
						        i_item = "Incumbent" or
						        i_item = "Gap" or
						        i_item = "Solver" or
						        i_item = "Solution Time" or
						        i_item = "Connecting to session..." then 1
						else 0
						endif
					}
				}
				Set s_GUIItems {
					SubsetOf: s_items;
					Index: i_guiItem;
					OrderBy: p_itemOrder(i_guiItem);
					Definition: {
						if bp_showDetails then
						        {i_item}
						else
						        {i_item | p_resume(i_item)}
						endif
					}
				}
				Parameter p_noTerminationConfirmation {
					InitialData: 1;
				}
				Procedure pr_updateProgressWindow {
					Body: {
						! Default update frequency
						if ep_freqElement = '' then
						        ep_freqElement := '5 seconds';
						endif;
						
						! Clear data from old updates
						empty s_timeSlots, s_items, p_itemOrder;
						cleandependents s_timeSlots, s_items;
						
						return pr_activate(ep_selectedSession);
					}
				}
				Procedure pr_updateProgressWindowFreq {
					Body: {
						! Default update frequency
						if ep_freqElement = '' then
						        ep_freqElement := '5 seconds';
						endif;
						p_updateDelay := p_freqValue(ep_freqElement);
						
						return 1;
					}
				}
				Procedure pr_updateProgressWindowPause {
					Body: {
						ep_pausedSession := ep_watchedSession;
						ep_watchedSession := '';
					}
				}
				Procedure pr_updateProgressWindowPauseResume {
					Body: {
						if p_watchedSessionNotRunning then
						        ep_watchedSession := ep_pausedSession;
						        pr_repeatUpdate;
						else
						        ep_pausedSession := ep_watchedSession;
						        ep_watchedSession := '';
						endif;
					}
				}
				Procedure pr_updateProgressWindowOrdening {
					Body: {
						SetElementAdd(s_items,ep_ItemElement,"PRO SESSION");
						SetElementAdd(s_items,ep_ItemElement,"SOLVER SESSION");
						
						! Line ordening
						if Exists(i_item | p_itemOrder(i_item)=0) then 
							for i_item do
								! PRO Session
								if i_item='PRO SESSION' then p_itemOrder(i_item):=100;
								elseif i_item='Request' then p_itemOrder(i_item):=101;
								elseif i_item='ServerURL' then p_itemOrder(i_item):=102;
								elseif i_item='Username' then p_itemOrder(i_item):=103;
								elseif i_item='LastUpdate' then p_itemOrder(i_item):=104;
						
								! PRO Session
								elseif i_item='SOLVER SESSION' then p_itemOrder(i_item):=200;
								elseif i_item='EndPoint' then p_itemOrder(i_item):=201;
								elseif i_item='# Rows' then p_itemOrder(i_item):=202;
								elseif i_item='# Cols' then p_itemOrder(i_item):=203;
								elseif i_item='# NZ' then p_itemOrder(i_item):=204;
								elseif i_item='Solver' then p_itemOrder(i_item):=205;
								elseif i_item='Iterations' then p_itemOrder(i_item):=206;
								elseif i_item='Nodes' then p_itemOrder(i_item):=207;
								elseif i_item='Branches' then p_itemOrder(i_item):=208;
								elseif i_item='Failures' then p_itemOrder(i_item):=209;
								elseif i_item='Objective' then p_itemOrder(i_item):=210;
								elseif i_item='Best Bound' then p_itemOrder(i_item):=211;
								elseif i_item='Incumbent' then p_itemOrder(i_item):=212;
								elseif i_item='Gap' then p_itemOrder(i_item):=213;
								elseif i_item='Solution Time' then p_itemOrder(i_item):=214;
								elseif i_item='Memory' then p_itemOrder(i_item):=215;
								elseif i_item='Program Status' then p_itemOrder(i_item):=216;
						
								else p_itemOrder(i_item):=1001; endif;
							endfor; 
						endif;
						
						update ep_lineColor;
						
						return 1;
					}
				}
				Procedure pr_solveInterruptSession {
					Body: {
						if (p_noTerminationConfirmation) then
						        p_ret := 1;
						else
						        p_ret := pro::DialogAsk("Do you want to interrupt the current solve? The execution will continue in the next statement.","Yes","No",title:"PRO Framework");
						endif;
						
						if (p_ret = 1) then
							return pr_solveInterrupt( ep_selectedSession );
						endif;
						
						return p_ret;
					}
					Parameter p_ret;
				}
				Procedure pr_solveInterrupt {
					Arguments: (ep_sess);
					Body: {
						return pro::client::StopExecution(sp_workerQueue(ep_sess),pro::AIMMSAPI_INTERRUPT_SOLVE);
					}
					ElementParameter ep_sess {
						Range: s_sessionList;
						Property: Input;
					}
				}
				Procedure pr_procedureInterruptSession {
					Body: {
						if (p_noTerminationConfirmation) then
						        p_ret := 1;
						else
						        p_ret := pro::DialogAsk("Do you want to interrupt the current procedure? The request will be finished.","Yes","No",title:"PRO Framework");
						endif;
						if (p_ret = 1) then
						        return pro::client::StopExecution(sp_workerQueue(ep_selectedSession),pro::AIMMSAPI_INTERRUPT_EXECUTE);
						endif;
					}
					Parameter p_ret;
				}
				Procedure pr_terminateSession {
					Body: {
						if (p_noTerminationConfirmation) then
						        p_ret := 1;
						else
						        p_ret := pro::DialogAsk("Do you want to terminate the request? No data will be retrieved.","Yes","No",title:"PRO Framework");
						endif;
						
						if (p_ret = 1) then
						        ! Finish progress window, if activated
						        if(ep_watchedSession = ep_selectedSession) then
						                ep_watchedSession := '';
						        endif;
						        return pro::sessionmanager::TerminateSession(ep_selectedSession);
						endif;
					}
					Parameter p_ret;
				}
			}
		}
		Section authorization {
			DeclarationSection Entity_Properties_Current_Authorized_Object {
				Set s_currentEntity {
					SubsetOf: s_PROEntity;
					Index: CUR_ENT;
					Parameter: Pe_CUR_Entity;
				}
				Parameter bp_currentObjectEntityDeny {
					IndexDomain: CUR_ENT;
					Range: binary;
				}
				Parameter p_currentObjectEntityExec {
					IndexDomain: CUR_ENT;
					Range: binary;
				}
				Parameter p_currentObjectEntityRead {
					IndexDomain: CUR_ENT;
					Range: binary;
				}
				Parameter bp_currentObjectEntityWrite {
					IndexDomain: CUR_ENT;
					Range: binary;
				}
				Set s_currentUserSet {
					SubsetOf: s_PROUser;
					Parameter: ep_GUI_User;
					Definition: s_PROEnvUser(ep_GUI_Env);
				}
				Set s_currentGroupSet {
					SubsetOf: s_PROGroup;
					Parameter: Pe_GUI_Group;
					Definition: s_PROEnvGroup(ep_GUI_Env);
				}
				Parameter bp_PROCancelAuth {
					Range: binary;
				}
			}
			Procedure pr_editAuthorization {
				Arguments: (sp_authString);
				Body: {
					!IF NOT SessionHasVisibleGUI THEN
					!        return 0;
					!ENDIF;
					
					!LocalizationInitialize;
					
					! Initialize PRO Framework (if not initialized yet)
					p_ret := pro::Initialize();
					if not (p_ret) then return 0; endif;
					
					if not pro::handleError(p_ret) then return 0; endif;
					pr_PopulateEntitySets(1);
					
					sp_tmpEnv := pro::GetPROEnvironment;
					ep_Env := First(i_PRO_ENV | sp_PROEnvName(i_PRO_ENV) = sp_tmpEnv);
					
					! Fill the sets with the authorization string
					Empty s_currentEntity,bp_currentObjectEntityDeny, p_currentObjectEntityExec, p_currentObjectEntityRead, bp_currentObjectEntityWrite;
					pr_deconstructAuthorizationString(sp_authString, s_currentEntity, bp_currentObjectEntityDeny, p_currentObjectEntityExec, p_currentObjectEntityRead, bp_currentObjectEntityWrite);
					
					! Open the edit dialog
					bp_PROCancelAuth := 0;
					PageOpen("Authorization Manager");
					if not bp_PROCancelAuth then
					        ! Encode the string back
					        sp_authString := "";
							pr_constructAuthorizationString(s_currentEntity, bp_currentObjectEntityDeny, p_currentObjectEntityExec, p_currentObjectEntityRead, bp_currentObjectEntityWrite, sp_authString);
					else
					        return 0;
					endif;
					
					return 1;
				}
				StringParameter sp_authString {
					Property: InOut;
				}
				Parameter p_ret;
				ElementParameter ep_err {
					Range: errh::PendingErrors;
				}
				Parameter p_tmpLength;
				Parameter p_tmpLast;
				Parameter p_tmpNext;
				Parameter p_tmpCont;
				StringParameter sp_tmpAuth;
				Parameter p_tmpFlag {
					Range: integer;
				}
				Parameter bp_tmpDeny {
					Range: binary;
				}
				StringParameter sp_tmpEnt;
				StringParameter sp_tmpEnv;
				ElementParameter ep_tmpEntElem {
					Range: s_PROEntity;
				}
				Index i_n {
					Range: Integers;
				}
			}
			Procedure pr_addUserAuthorization {
				Body: {
					! Validation
					if ep_GUI_User = '' then
					        DialogError("Please select a valid user","Add User Authorization");
					        return 0;
					endif;
					
					! Add to the set
					s_currentEntity += ep_GUI_User;
					
					return 1;
				}
			}
			Procedure pr_addGroupAuthorization {
				Body: {
					! Validation
					if Pe_GUI_Group = '' then
					        DialogError("Please select a valid group","Add Group Authorization");
					        return 0;
					endif;
					
					! Add to the set
					s_currentEntity += Pe_GUI_Group;
					
					return 1;
				}
			}
			Procedure pr_removeEntityAuthorization {
				Body: {
					! Validation
					if Pe_CUR_Entity = '' then
					        DialogError("Please select a valid entity","Remove Authorization");
					        return 0;
					endif;
					
					! Add to the set
					s_currentEntity -= Pe_CUR_Entity;
					
					return 1;
				}
			}
		}
		Section Additional_utilities {
			DeclarationSection dialog_sets {
				Set s_okDone {
					Definition: data { ok, Done };
				}
				Set s_onDone {
					Definition: data { OK, Cancel };
				}
				Set s_justOK {
					Definition: data { OK };
				}
			}
			Function fnc_hasPropertyNosave {
				Arguments: (ep_id);
				Body: {
					bp_retval := 0 ;
					while ep_id do
						if FindString( AttributeToString( ep_id, 'property'), "Nosave", caseSensitive:0 ) then
							bp_retval := 1;
							break ;
						else
							ep_id := me::Parent( ep_id );
						endif ;
					endwhile ;
					fnc_hasPropertyNosave := bp_retval ;
				}
				Comment: {
					"Doesn\'t work for deployed apps; the attributes are encrypted and cannot be queried just like that."
				}
				ElementParameter ep_id {
					Range: AllSymbols;
					Property: Input;
				}
				Parameter bp_retval;
			}
			Procedure pr_artificialDataGSSPage {
				Body: {
					pr_enter(sp_gssTime, p_gssMiU, ep_messageImportance: 'info');
					block
						raise warning "Cry wolf" ;
					onerror ep_err do
						gss::pr_appendError(ep_err);
						errh::MarkAsHandled(ep_err);
					endblock ;
					pr_leave(sp_gssTime, p_gssMiU, ep_messageImportance: 'info');
				}
				Comment: {
					"Run this procedure to obtain some contents with which to tailor the 
					table ErrorWarningMessageTable and JobProfilerData"
				}
				ElementParameter ep_err {
					Range: errh::PendingErrors;
				}
				DeclarationSection gss_logging_declarations {
					StringParameter sp_gssTime;
					Parameter p_gssMiU;
				}
			}
			Procedure pr_scheduleOver {
				Arguments: (p_noSeconds,ep_payLoad);
				Body: {
					block ! Sanity checks 
						if p_noSeconds <= 0[s] then
							raise error 
								formatString("pr_scheduleOver(%n,%e): The number of seconds should be strictly positive.", 
									p_noSeconds, ep_payLoad);
						endif ;
						if not ep_payLoad then
							raise error 
								formatString("pr_scheduleOver(%n,%e): Empty payload specified.", 
									p_noSeconds, ep_payLoad);
						endif ;
					endblock ;
					
					
					p_ogv := OptionGetValue(
						OptionName :  "use_UTC_forCaseAndStartEndDate", 
						Lower      :  p_low, 
						Current    :  p_scheduleAtUsesUTC, 
						Default    :  p_def, 
						Upper      :  p_upp);
					if not p_ogv then ! Option use_UTC_forCaseAndStartEndDate is introduced with AIMMS 4.75.
						p_scheduleAtUsesUTC := 0 ; ! Assume option use_UTC_forCaseAndStartEndDate is off.
					endif ;
					p_tmpSec := CurrentToMoment([s], "2021-01-01 00:00:00") ;
					!p_tmpSec += (p_noSeconds) [s];
					p_tmpSec += p_noSeconds ;
					if p_scheduleAtUsesUTC then
						sp_launchDate := MomentToString( "%c%y-%m-%d %H:%M:%S%TZ('UTC')", [s], "2021-01-01 00:00:00", p_tmpSec );
					else
						sp_launchDate := MomentToString( "%c%y-%m-%d %H:%M:%S", [s], "2021-01-01 00:00:00", p_tmpSec );
					endif ;
					if not ScheduleAt(sp_launchDate, ep_payLoad) then
					        raise error "Error scheduling procedure \'" + ep_payload + "\': " + CurrentErrorMessage code 'PRO-Error-scheduling-progress-procedure' ;
					endif;
				}
				Comment: "Schedule a job in a couple of seconds.";
				Parameter p_noSeconds {
					Unit: s;
					Property: Input;
				}
				ElementParameter ep_payLoad {
					Range: AllProcedures;
					Property: Input;
				}
				StringParameter sp_launchDate;
				Parameter p_deltaSeconds;
				Parameter p_tmpHour {
					Range: integer;
				}
				Parameter p_tmpMin {
					Range: integer;
				}
				Parameter p_tmpSec {
					Range: integer;
					Unit: s;
				}
				Parameter p_ogv;
				Parameter p_low;
				Parameter p_scheduleAtUsesUTC;
				Parameter p_def;
				Parameter p_upp;
			}
		}
	}
	Section Private_Section {
		Property: NoSave;
		Section WebUI_helpers {
			Parameter p_noSignificantMessages {
				Definition: p_noLogMessages + p_NoWarnings + p_NoErrors;
				Comment: "This is a helper in the status bar";
			}
			Parameter ep_lastHitLine {
				Definition: {
					last( i_positiveLineNumber | 
						p_shownJobProfilerData(ep_profilerDataSelectedIdentifier, 
						i_positiveLineNumber, 'hits'))
				}
				Comment: "To define the line numbers visible in the table LineBasedProfilerData";
			}
			Parameter bp_isConnectedToPro {
				Range: binary;
				InitialData: 0;
			}
			Parameter bp_isWorkerSession {
				InitialData: 0;
			}
			Parameter bp_isVerifySession {
				Range: binary;
				InitialData: 0;
			}
		}
		Section Main_Library_procedures {
			Procedure LibraryInitialization {
				Body: {
					ep_jobIncident := '' ;
					ep_dataSessionIncident := '' ;
					pr_getThisSession();
					if not bp_isVerifySession then
						pr_getModelLibraryAndBinPaths();
					endif ;
				}
				Comment: "Add initialization statements here that do not require any other library being initialized already.";
			}
			Procedure PostLibraryInitialization {
				Body: {
					! The error data shown should not be modified in the User Interface.
					if bp_isVerifySession then
						return ;
					endif ;
					CurrentInputs -= serverSessionErrorData;
					CurrentInputs -= Shown_session_data_exchange ;
					CurrentInputs -= dataSessionProfilerErrorData ;
					
					block ! Data shown that should not be modified by the end user.
						CurrentInputs -= data { 
							'gss::sp_Application',    
							'gss::sp_CreateTime',     
							'gss::sp_UserEnv',       
							'gss::sp_UserName',       
							'gss::p_CurrentStatus',  
							'gss::bp_GotResults',
							'sp_requestDescription',
							'sp_requestProcedure',
							'gss::sp_value'
						};
					endblock ;
					
					block ! Determine priviligers and type of PRO.
						if pro::GetPROEndPoint() then
							gss::bp_isAnAdmin := 0;
							pro::Initialize();
							if pro::GetCurrentUserInfo(
								environment   :  sp_env, 
								username      :  sp_usr, 
								userBucket    :  sp_bkt, 
								userGroups    :  s_groups, 
								userGroupname :  sp_groupNames) then
								if exists( i_grp | val(i_grp) = pro::PROA_ADMIN_GROUP ) then
									gss::bp_isAnAdmin := 1 ;
								endif ;
							endif ;
							if pro::management::IsRunningOnCloud() then
								gss::bp_isRunningOnCloud := 1 ;
							else
								gss::bp_isRunningOnCloud := 0 ;
							endif ;
						else
							gss::bp_isAnAdmin := 1 ;
							gss::bp_isRunningOnCloud := 0 ;
						endif ;
					endblock ;
					
					
					block ! Ensure option "Use UTC forcaseandstartenddate" is turned on.
						bp_ogv := OptionGetValue("Use UTC forcaseandstartenddate", 
							p_optLow, p_optCur, p_optDef, p_optUpp );
						if not bp_ogv then
							raise error "my bad" ;
						endif ;
						if p_optCur <> 1 then raise warning 
							"The option \"Use UTC forcaseandstartenddate\" should be turned on"+
							" for correct logging of time in the library GuardServerSession." ;
						endif ;
					endblock ;
					! log file of a week old are to be deleted
					
					block ! construct hourly calendar for last three months.
						gss::sp_endHoursLastThreeMonths := CurrentToString("%c%y-%m-%d %H");
						gss::sp_beginHoursLastThreeMonths := MomentToString(
							Format        :  "%c%y-%m-%d %H", 
							unit          :  [hour], 
							ReferenceDate :  gss::sp_endHoursLastThreeMonths, 
							Elapsed       :  -3[month]);
						gss::ep_listSessionsSince := Element( gss::cal_HoursLastThreeMonths, card( gss::cal_HoursLastThreeMonths ) - 25 );
					endblock ;
					
					
					
					pr_setMemoryInUse( MemoryInUse() );
				}
				Comment: {
					"Add initialization statements here that require another library to be initialized already,
					or add statements that require the Data Management module to be initialized."
				}
				StringParameter sp_env;
				StringParameter sp_usr;
				StringParameter sp_bkt;
				Set s_groups {
					Index: i_grp;
				}
				StringParameter sp_groupNames {
					IndexDomain: i_grp;
				}
				Parameter bp_ogv {
					Range: binary;
				}
				Parameter p_optLow;
				Parameter p_optCur;
				Parameter p_optDef;
				Parameter p_optUpp;
			}
			Procedure PreLibraryTermination {
				Body: {
					
					return 1;
				}
				Comment: {
					"Add termination statements here that require all other libraries to be still alive.
					Return 1 if you allow the termination sequence to continue.
					Return 0 if you want to cancel the termination sequence."
				}
			}
			Procedure LibraryTermination {
				Body: {
					return 1;
				}
				Comment: {
					"Add termination statements here that do not require other libraries to be still alive.
					Return 1 to allow the termination sequence to continue.
					Return 0 if you want to cancel the termination sequence.
					It is recommended to only use the procedure PreLibraryTermination to cancel the termination sequence and let this procedure always return 1."
				}
			}
		}
		Section Incident_Summary_Utilities {
			Procedure pr_workCreateIncidentSummary {
				Arguments: (sp_createdFile);
				Body: {
					if AimmsStringConstants('Platform') = "Linux" then
						sp_slash := "/" ;
					else
						sp_slash := "\\" ;
					endif ;
					sp_fwdSlash := "/" ;
					
					block ! Ensure the proper session is selected
						ep_shownSession := first( s_trackedSessions );
						pr_storeErrorProfilerDataFromDataSessionInTrackedSessions();
						pr_showSelectedSessionInUI();
					endblock ;
					
					
					block ! Ensure a folder exists to put materials in
						if not DirectoryExists( sp_incidentSummaryFolderName ) then
							if not DirectoryCreate( sp_incidentSummaryFolderName ) then
								raise error formatString( 
									"CreateIncidentSummary(): Unable to create folder %s: %s",
										sp_incidentSummaryFolderName, CurrentErrorMessage );
							endif ;
						endif ;
					endblock ;
					
					block ! Write summary text 
						sp_summaryTextFilename := sp_incidentSummaryFolderName + sp_slash + "summary.txt" ;
						put f_summaryText ;
						put formatString("Summary of incident reported by %s@%s at %s of data session %s",
							pro::GetPROUserName(), pro::GetPROEnvironment(),
							CurrentToString("%c%y-%m-%d %H:%M:%S"), sp_thisSession),
							/, / ;
						put sp_incidentSummarySuppliedByEndUser, /, /;
					
						! Todo: list of session ids of server sessions (see tracked sessions)
					
						putclose ;
					endblock ;
					
					block ! Copy the case file
						sp_caseFilename  := sp_incidentSummaryFolderName + sp_slash + "dataSession.data" ;
						if not CaseFileSave(
								url      :  sp_caseFilename, 
								contents :  AllIdentifiers) then
							raise error formatString("CreateIncidentSummary(): Unable to save data to \"%s\": %s",
								sp_caseFilename, CurrentErrorMessage );
						endif ;
					endblock ;
					
					
					block ! Write Error report
						sp_errorReportFilename := sp_incidentSummaryFolderName + sp_slash + "errorReport.txt" ;
						pr_reportCurrentErrorsToTextFile( sp_errorReportFilename );
					endblock ;
					
					block ! Write Profiler and Errors as Data file
						sp_profilerErrorDataFilename := sp_incidentSummaryFolderName + sp_slash + "ProfilerAndErrorData.errors" ;
						pr_downloadErrorDataWork( sp_profilerErrorDataFilename );
					endblock ;
					
					block ! Copy the trace/actionLog file
						sp_actionLogFilename  := sp_incidentSummaryFolderName + sp_slash + "action.log" ;
						if not FileCopy(
								source      :  sp_tracefilename, 
								destination :  sp_actionLogFilename, 
								confirm     :  0) then
							raise error formatString("CreateIncidentSummary(): Unable to copy action log - FileCopy(from: %s, to: %s): %s",
								sp_tracefilename, sp_actionLogFilename, CurrentErrorMessage );
						endif ;
					endblock ;
					
					block ! For each solver session, write the error report, profiler/error data, and action log to a sub folder of IncidentSummary.
						for i_trackedSession | i_trackedSession <> first(s_trackedSessions) do
							ep_shownSession := i_trackedSession;
							pr_showSelectedSessionInUI();
					
							if not DirectoryExists( sp_incidentSummaryFolderName + sp_slash + ep_shownSession ) then
								DirectoryCreate( sp_incidentSummaryFolderName + sp_slash + ep_shownSession );
							endif ;
					
							block ! Write Error report
								sp_errorReportFilename := sp_incidentSummaryFolderName + sp_slash + ep_shownSession + sp_slash + "errorReport.txt" ;
								pr_reportCurrentErrorsToTextFile( sp_errorReportFilename );
							endblock ;
					
							block ! Write Profiler and Errors as Data file
								sp_profilerErrorDataFilename := sp_incidentSummaryFolderName + sp_slash + ep_shownSession + sp_slash + "ProfilerAndErrorData.errors" ;
								pr_downloadErrorDataWork( sp_profilerErrorDataFilename );
							endblock ;
					
							block ! Copy the trace/actionLog file
								sp_actionLogFilename  := sp_incidentSummaryFolderName + sp_slash + ep_shownSession + sp_slash + "action.log" ;
								sp_proStorageFileName := sp_slash + "Userdata" + sp_slash + 
									pro::GetPROEnvironment() + sp_slash + 
									pro::GetPROUserName()    + sp_slash + 
									pro::ModelName           + sp_slash +
									"tracings"               + sp_slash +
									ep_shownSession          + ".actionLog" ;
								pro::RetrieveFileFromCentralStorage( sp_proStorageFileName, sp_actionLogFilename );
							endblock ;
					
							block ! Copy the contents of bucket /UserData/<env>/<user>/<prj>/<ep_shownSession>/
								sp_bucketName := sp_fwdSlash + "Userdata" + sp_fwdSlash + 
									pro::GetPROEnvironment() + sp_fwdSlash + 
									pro::GetPROUserName()    + sp_fwdSlash + 
									pro::ModelName           + sp_fwdSlash +
									ep_shownSession          ;
								empty s_filenumbers ;
								pr_getFiles( sp_bucketName, s_fileNumbers, sp_fileNames, sp_fileTimes, p_fileSizes );
								pro::management::LocalLogInfo(formatString("Copy the contents of bucket: %s", sp_bucketName));
								for i_fileNo do
									pro::management::LocalLogInfo("    Retrieving: " + sp_fileNames(i_fileNo));
								endfor ;
								for i_fileNo do
									sp_fn := sp_fileNames( i_fileNo );
									p_slashPos1 := findNthString( sp_fn, "/", -1);
									p_slashPos2 := findNthString( sp_fn, "\\", -1);
									p_slashPos := max( p_slashPos1, p_slashPos2 );
									sp_baseFilename := substring( sp_fn, p_slashPos + 1, StringLength( sp_fn ) );
					!				sp_proStorageFileName := sp_slash + "Userdata" + sp_slash + 
					!					pro::GetPROEnvironment() + sp_slash + 
					!					pro::GetPROUserName()    + sp_slash + 
					!					pro::ModelName           + sp_slash +
					!					ep_shownSession          + sp_slash +
					!					sp_fileNames( i_fileNo ) ;
									sp_proStorageFileName := sp_fileNames( i_fileNo );
									sp_fn := sp_incidentSummaryFolderName + sp_slash + ep_shownSession + sp_slash + sp_baseFilename  ;
									pro::management::LocalLogInfo(formatString("RetrieveFileFromCentralStorage(from: %s, to: %s)", 
										sp_proStorageFileName, sp_fn));
									pro::RetrieveFileFromCentralStorage( sp_proStorageFileName, sp_fn );
								endfor ;
							endblock ;
					
						endfor ;
					endblock ;
					
					
					sp_createdFile := "IncidentSummary.zip" ;
					pr_zipFolderToFile( sp_incidentSummaryFolderName, sp_createdFile );
				}
				Comment: "Workhorse when an incident summary is to be created.";
				StringParameter sp_prevCurrentFolder;
				StringParameter sp_slash;
				StringParameter sp_fwdSlash;
				StringParameter sp_incidentSummaryFolderName {
					InitialData: "IncidentMaterials";
				}
				File f_summaryText {
					Name: sp_summaryTextFilename;
					Device: Disk;
					Mode: replace;
				}
				StringParameter sp_summaryTextFilename;
				StringParameter sp_errorReportFilename;
				StringParameter sp_profilerErrorDataFilename;
				StringParameter sp_actionLogFilename;
				StringParameter sp_caseFilename;
				StringParameter sp_zipCommand;
				StringParameter sp_createdFile {
					Property: Output;
				}
				StringParameter sp_proStorageFileName;
				StringParameter sp_bucketName;
				Set s_fileNumbers {
					SubsetOf: Integers;
					Index: i_fileNo;
				}
				StringParameter sp_fileNames {
					IndexDomain: i_fileNo;
				}
				StringParameter sp_fileTimes {
					IndexDomain: i_fileNo;
				}
				Parameter p_fileSizes {
					IndexDomain: i_fileNo;
				}
				StringParameter sp_fn;
				Parameter p_slashPos1;
				Parameter p_slashPos2;
				Parameter p_slashPos;
				Parameter p_strLen;
				StringParameter sp_baseFilename;
			}
		}
		Section Guard_utilities {
			Section Private_Tracked_session {
				Procedure pr_doGuardAndProfileServerJob {
					Arguments: (ep_work);
					Body: {
						block
							pr_openLogFile();
							empty serverSessionErrorData ;
							sp_serverSessionId := sp_thisSession ;
						
							! Ensure that the error recorded and profiler data are transmitted via the output case:
							pro::ManagedSessionOutputCaseIdentifierSet += s_outputCaseIdentifiers ;
						
							! Actual work.
							apply( ep_work);
						
							! Ensure that the definitions of all defined sets and defined parameters in 
							! output case identifier set are profiled.
							update pro::ManagedSessionOutputCaseIdentifierSet;
						
						onerror ep_err do
						
							pr_appendError( ep_err );
						
							! Don't let the server job be halted by this error; 
							! we still want the result case including the profiled data.
							errh::MarkAsHandled(ep_err);
						
						endblock ;
						ProfilerCollectAllData(
							ProfilerData       :  p_jobProfilerData, 
							GrossTimeThreshold :  0, 
							NetTimeThreshold   :  0);
						
						pr_saveActionLogFile();
					}
					Comment: {
						"To be called when a job is delegated; it will ensure that :
						1) Errors and warnings issued during the execution of the actual work in procedure ep_work are collected.
						2) That profiling information during the execution of the procedure ep_work is collected
						3) That the logging is saved and stored in AIMMS PRO Storage."
					}
					ElementParameter ep_err {
						Range: errh::PendingErrors;
					}
					ElementParameter ep_work {
						Range: AllProcedures;
						Default: 'gss::pr_sampleProc';
						Property: Input;
					}
				}
				Procedure pr_uploadErrorDataWork {
					Arguments: (sp_filename);
					Body: {
						empty Shown_session_data_exchange;
						ep_trackedSession := StringToElement( s_trackedSessions, sp_filename, create:1);
						read from file sp_filename ;
						
						block ! Copy the data loaded in from the case in the Tracked session container.
							sp_sessionGivenDescriptions( ep_trackedSession ) := sp_shownSessionDescription ;
							p_trackedJobProfilerData(ep_trackedSession, IndexIdentifiers, i_lineNumber, IndexProfilerTypes) := p_shownJobProfilerData(IndexIdentifiers, i_lineNumber, IndexProfilerTypes);
							sp_trackedJobErrorMessages(ep_trackedSession, i_jobErrorMessageNumber) := sp_shownJobErrorMessages(i_jobErrorMessageNumber);
							sp_trackedJobErrorMoments(ep_trackedSession, i_jobErrorMessageNumber) := sp_shownJobErrorMoments(i_jobErrorMessageNumber);
							ep_trackedJobErrorSeverity(ep_trackedSession, i_jobErrorMessageNumber) := ep_shownJobErrorSeverity(i_jobErrorMessageNumber);
							ep_trackedJobErrorNodes(ep_trackedSession, i_jobErrorMessageNumber, i_stackPosition) := ep_shownJobErrorNodes(i_jobErrorMessageNumber, i_stackPosition);
							ep_trackedJobErrorAttributes(ep_trackedSession, i_jobErrorMessageNumber, i_stackPosition) := ep_shownJobErrorAttributes(i_jobErrorMessageNumber, i_stackPosition);
							p_trackedJobErrorLines(ep_trackedSession, i_jobErrorMessageNumber, i_stackPosition) := p_shownJobErrorLines(i_jobErrorMessageNumber, i_stackPosition);
							ep_shownSession := ep_trackedSession ;
						endblock ;
					}
					StringParameter sp_filename {
						Property: Input;
					}
					ElementParameter ep_trackedSession {
						Range: s_trackedSessions;
					}
				}
				Procedure pr_downloadErrorDataWork {
					Arguments: (sp_finalLocation);
					Body: {
						if not sp_finalLocation then
							raise error "A file without a name cannot be written to";
						endif ;
						block where single_column_display := 1;
							write Shown_session_data_exchange to file sp_finalLocation ;
						endblock ;
					}
					StringParameter sp_finalLocation {
						Property: Input;
					}
				}
			}
			Parameter bp_locSeenErrorsAreHandled {
				Range: binary;
				InitialData: 0;
			}
			Index i_errorSeverity {
				Range: errh::AllErrorSeverities;
			}
			ElementParameter ep_errorToMessageLevelMap {
				IndexDomain: i_errorSeverity;
				Range: s_messageLevels;
				Definition: data { 'severe' : 'fatal', 'error' : 'error', 'warning' : 'warn' };
			}
			ElementParameter ep_jobIncident {
				Range: s_jobErrorMessageNumbers;
			}
			Procedure pr_storeErrorProfilerDataFromDataSessionInTrackedSessions {
				Body: {
					ProfilerCollectAllData(
						ProfilerData       :  p_dataSessionProfilerData, 
						GrossTimeThreshold :  0, 
						NetTimeThreshold   :  0);
					
					p_trackedJobProfilerData(ep_shownSession, IndexIdentifiers, i_lineNumber, IndexProfilerTypes) := p_dataSessionProfilerData(IndexIdentifiers, i_lineNumber, IndexProfilerTypes);
					sp_trackedJobErrorMessages(ep_shownSession, i_jobErrorMessageNumber) := sp_dataSessionErrorMessages(i_jobErrorMessageNumber);
					sp_trackedJobErrorMoments(ep_shownSession, i_jobErrorMessageNumber) := sp_dataSessionErrorMoments(i_jobErrorMessageNumber);
					ep_trackedJobErrorSeverity(ep_shownSession, i_jobErrorMessageNumber) := ep_dataSessionErrorSeverity(i_jobErrorMessageNumber);
					ep_trackedJobErrorNodes(ep_shownSession, i_jobErrorMessageNumber, i_stackPosition) := ep_dataSessionErrorNodes(i_jobErrorMessageNumber, i_stackPosition);
					ep_trackedJobErrorAttributes(ep_shownSession, i_jobErrorMessageNumber, i_stackPosition) := ep_dataSessionErrorAttributes(i_jobErrorMessageNumber, i_stackPosition);
					p_trackedJobErrorLines(ep_shownSession, i_jobErrorMessageNumber, i_stackPosition) := p_dataSessionErrorLines(i_jobErrorMessageNumber, i_stackPosition);
				}
			}
			Procedure pr_reportCurrentErrorsToTextFile {
				Arguments: (sp_filename);
				Body: {
					block where listing_page_width := 32000 ;
						f_out.pagewidth := 32000 ;
						put f_out;
						for i_jobErrorMessageNumber | sp_shownJobErrorMessages(i_jobErrorMessageNumber) do
							put     ep_shownJobErrorSeverity(i_jobErrorMessageNumber), " ", 
								sp_shownJobErrorMoments( i_jobErrorMessageNumber), " : ",
								sp_shownJobErrorMessages(i_jobErrorMessageNumber), / ;
							for i_stackPosition | p_shownJobErrorLines(i_jobErrorMessageNumber, i_stackPosition) do
								put "    ", p_shownJobErrorLines(i_jobErrorMessageNumber, i_stackPosition):4:0, 
								" : ", ep_shownJobErrorNodes(i_jobErrorMessageNumber, i_stackPosition):0, / ;
							endfor ;
							put / ;
						endfor ;
						putclose ;
					endblock ;
				}
				Comment: {
					"Helper procedure of pr_downloadErrorReport; this will actually fill the put file."
				}
				StringParameter sp_filename {
					Property: Input;
				}
				File f_out {
					Name: sp_filename;
					Device: Disk;
					Mode: replace;
				}
			}
			Procedure pr_showSelectedSessionInUI {
				Body: {
					empty Shown_session_data_exchange ;
					
					sp_shownSessionDescription :=
						if ep_shownSession = first( s_trackedSessions ) then
							"data session"
						else
							sp_sessionGivenDescriptions(ep_shownSession)
						endif ;
					
					p_shownJobProfilerData(IndexIdentifiers, i_lineNumber, IndexProfilerTypes ) := 
						if ep_shownSession <> first( s_trackedSessions ) then
							p_trackedJobProfilerData(ep_shownSession, IndexIdentifiers, i_lineNumber, IndexProfilerTypes)
						else
							p_dataSessionProfilerData(IndexIdentifiers, i_lineNumber, IndexProfilerTypes)
						endif;
					
					sp_shownJobErrorMessages(i_jobErrorMessageNumber) := 
						if ep_shownSession <> first( s_trackedSessions ) then
							sp_trackedJobErrorMessages(ep_shownSession, i_jobErrorMessageNumber)
						else
							sp_dataSessionErrorMessages(i_jobErrorMessageNumber)
						endif ;
					
					sp_shownJobErrorMoments(i_jobErrorMessageNumber) := 
						if ep_shownSession <> first( s_trackedSessions ) then
							sp_trackedJobErrorMoments(ep_shownSession, i_jobErrorMessageNumber)
						else
							sp_dataSessionErrorMoments(i_jobErrorMessageNumber)
						endif;
					
					ep_shownJobErrorSeverity(i_jobErrorMessageNumber) := 
						if ep_shownSession <> first( s_trackedSessions ) then
							ep_trackedJobErrorSeverity(ep_shownSession, i_jobErrorMessageNumber)
						else
							ep_dataSessionErrorSeverity(i_jobErrorMessageNumber)
						endif;
					
					ep_shownJobErrorNodes(i_jobErrorMessageNumber, i_stackPosition) := 
						if ep_shownSession <> first( s_trackedSessions ) then
							ep_trackedJobErrorNodes(ep_shownSession, i_jobErrorMessageNumber,i_stackPosition)
						else
							ep_dataSessionErrorNodes(i_jobErrorMessageNumber,i_stackPosition)
						endif;
					
					ep_shownJobErrorAttributes(i_jobErrorMessageNumber, i_stackPosition) := 
						if ep_shownSession <> first( s_trackedSessions ) then
							ep_trackedJobErrorAttributes(ep_shownSession, i_jobErrorMessageNumber,i_stackPosition)
						else
							ep_dataSessionErrorAttributes(i_jobErrorMessageNumber,i_stackPosition)
						endif;
					
					p_shownJobErrorLines(i_jobErrorMessageNumber, i_stackPosition) := 
						if ep_shownSession <> first( s_trackedSessions ) then
							p_trackedJobErrorLines(ep_shownSession, i_jobErrorMessageNumber,i_stackPosition)
						else
							p_dataSessionErrorLines(i_jobErrorMessageNumber,i_stackPosition)
						endif;
				}
			}
			Procedure pr_sampleProc {
				Body: {
					! Do not delete this procedure, it is used as default of element parameter gss::ep_Work.
				}
			}
			Procedure pr_newIncidentDataSession {
				Body: {
					if ep_dataSessionIncident then
						if ep_dataSessionIncident = last( s_jobErrorMessageNumbers ) then
							p_maxNoErrorsPerSession *= 2 ;		
						endif ;
						ep_dataSessionIncident += 1 ;
					else
						ep_dataSessionIncident := first( s_jobErrorMessageNumbers );
					endif;
				}
				Comment: "Get error possition for a new incident in a data session.";
			}
			Procedure pr_newIncidentJob {
				Body: {
					if ep_jobIncident then
						if ep_jobIncident = last( s_jobErrorMessageNumbers ) then
							p_maxNoErrorsPerSession *= 2 ;		
						endif ;
						ep_jobIncident += 1 ;
					else
						ep_jobIncident := first( s_jobErrorMessageNumbers );
					endif;
				}
				Comment: "Get error possition for a new incident in a solver session (job).";
			}
		}
		Section AIMMS_PRO_utilities {
			Procedure pr_ensurePath {
				Arguments: (sp_path);
				Body: {
					if not pr_proFolderExists( sp_path ) then
					        pro::CreateStorageFolder( sp_path );
					endif ;
				}
				StringParameter sp_path {
					Property: Input;
				}
			}
			Function fnc_fileFriendlyName {
				Arguments: (ep_id);
				Range: string;
				Body: {
					sp_retVal := formatString("%e", ep_id );
					sp_retVal := FindReplaceStrings( sp_retVal, ":", "_" );
					
					fnc_fileFriendlyName := sp_retVal ;
				}
				Comment: "Replace : chars with _ chars to obtain name that is a valid file name.";
				ElementParameter ep_id {
					Range: AllIdentifiers;
					Property: Input;
				}
				StringParameter sp_retVal;
			}
			Procedure pr_proFolderExists {
				Arguments: (sp_filepath);
				Body: {
					! proFolderExists, proDirectoryExists, FolderExists, DirectoryExists
					pro::NormalizeStoragePath(sp_filepath);
					p_ret := pro::storage::ListBuckets(
								path       :  sp_filepath, 
								BucketSet  :  s_locBucketSet, 
								BucketSize :  p_locBucketSize, 
								BucketAuth :  sp_locBucketAuth, 
								BucketDate :  sp_locBucketDate);
					return p_ret ;
				}
				StringParameter sp_filepath {
					Property: Input;
				}
				Parameter p_ret;
				Set s_locBucketSet {
					Index: bs;
				}
				Parameter p_locBucketSize {
					IndexDomain: bs;
				}
				StringParameter sp_locBucketAuth {
					IndexDomain: bs;
				}
				StringParameter sp_locBucketDate {
					IndexDomain: bs;
				}
			}
			Procedure pr_proFileExists {
				Arguments: (sp_filename);
				Body: {
					pro::NormalizeStoragePath(sp_filename);
					pro::SplitStoragePath(sp_filename,sp_storageBucketPath,sp_storageFileWithoutPath);
					if not pr_proFolderExists( sp_storageBucketPath ) then return 0 ; endif ;
					p_ret := pro::storage::GetObjectInfo(sp_storageBucketPath, sp_storageFileWithoutPath,
							sp_tmpLocalFileName, sp_tmpType, p_tmpNum, sp_tmpAuth, p_tmpVersion );
					if p_ret = 0 or p_tmpNum <= 0 then
						return 0 ;
					endif ;
					return 1 ;
				}
				Comment: {
					"d:\\u\\s\\aimms3\\deps\\vc120_x64_Debug\\Libraries\\AimmsWebUI\\AimmsWebUI.ams line 1600
					d:\\u\\s\\Customers\\K3 Delta\\Escalation March 2017\\6763\\UploadTool\\UploadTool\\UploadTool\\FileExistsFolderExists.ams line 40"
				}
				StringParameter sp_filename {
					Property: Input;
				}
				Parameter p_ret;
				StringParameter sp_storageBucketPath;
				StringParameter sp_storageFileWithoutPath;
				Parameter p_tmpNum;
				StringParameter sp_tmpLocalFileName;
				StringParameter sp_tmpType;
				StringParameter sp_tmpAuth;
				Parameter p_tmpVersion;
			}
			Function fnc_hasProPrefix {
				Arguments: (sp_filename);
				Range: binary;
				Body: {
					p_retval := 0 ;
					
					if Stringlength( sp_filename ) > 4 then
						if findstring( substring( sp_filename, 1, 4 ), "pro:", CaseSensitive:0 ) then
							p_retval := 1 ;
						else
							p_retval := 0 ;
						endif ;
					else
						p_retval := 0 ;
					endif ;
					
					fnc_hasProPrefix := p_retval ;
				}
				StringParameter sp_filename {
					Property: Input;
				}
				Parameter p_retval {
					Range: binary;
				}
			}
		}
		Section Generic_utilities {
			Procedure pr_getDownloadFolder {
				Arguments: (sp_downloadFolderName);
				Body: {
					pr_getSetting('DownloadFolder', sp_downloadOverride);
					if sp_downloadOverride then
						sp_downloadFolderName := sp_downloadOverride ;
					else
						EnvironmentGetString(
							Key   :  "USERPROFILE", 
							Value :  sp_userProfile);
						if not sp_userProfile then
							sp_downloadFolderName := "c:\\temp" ;
							raise warning "pr_getDownloadFolder(): Unable to obtain USERPROFILE" ;
						else
							sp_downloadFolderName := sp_userProfile + "\\downloads" ;
						endif ;
					endif ;
				}
				StringParameter sp_downloadFolderName {
					Property: Output;
				}
				StringParameter sp_userProfile;
				StringParameter sp_downloadOverride;
			}
			Function fnc_nonExistingFilename {
				Arguments: (sp_filename);
				Range: string;
				Body: {
					! split the filename in a base part and an extension part, such that we insert " (no)" in between if needed.
					p_dot := FindNthString( sp_filename, ".", -1 );
					if p_dot > 1 then
						sp_extension := substring( sp_filename, p_dot, StringLength( sp_filename ) );
						sp_baseFilename := substring( sp_filename, 1, p_dot -1 );
					else
						sp_extension := "" ;
						sp_baseFilename := sp_filename ;
					endif ;
					
					p_cnt := 0 ;
					while FileExists( sp_filename ) do
						p_cnt += 1 ;
						sp_filename := formatString("%s (%i)%s", sp_baseFilename, p_cnt, sp_extension );
					endwhile ;
					fnc_nonExistingFilename := sp_filename ;
				}
				Comment: {
					"Ensure that the file sp_filename doesn\'t exist yet.
					If it exists, then create a <file> (no).<ext> variation of the filename 
					such as you often see in download folders."
				}
				StringParameter sp_extension;
				Parameter p_cnt;
				Parameter p_dot;
				StringParameter sp_filename {
					Property: Input;
				}
				StringParameter sp_baseFilename;
			}
			Section Various_paths {
				StringParameter sp_currentFolder;
				StringParameter sp_startupFolder;
			}
			Procedure pr_getModelLibraryAndBinPaths {
				Body: {
					DirectoryGetCurrent( sp_startupFolder );
					sp_currentFolder := sp_startupFolder ;
				}
				Set s_fileNumbers {
					SubsetOf: Integers;
					Index: i_fileNo;
				}
				StringParameter sp_fileNames {
					IndexDomain: i_fileNo;
				}
			}
			Procedure pr_getCurDir {
				Body: {
					DirectoryGetCurrent( sp_currentFolder );
				}
			}
			Procedure pr_zipFolderToFile {
				Arguments: (sp_folderName,sp_destinationFile);
				Body: {
					CurrentErrorMessage := "" ;
					sp_destinationFile := "IncidentSummary.zip";
					if FileExists( sp_destinationFile ) then
						FileDelete( sp_destinationFile );
					endif ;
					if AimmsStringConstants('Platform') = "Linux" then
						Execute( "zip", "-r " + sp_destinationFile + " " + sp_folderName , wait:1) ;
					else
						Execute( "powershell \"Compress-Archive -Path "+ sp_folderName+" -DestinationPath "+sp_destinationFile+"\"", wait:1);
					endif ;
					if not FileExists( sp_destinationFile ) then
						raise error "Unable to create " + sp_destinationFile + ": " + CurrentErrorMessage ;
					endif ;
				}
				StringParameter sp_folderName {
					Property: Input;
				}
				StringParameter sp_destinationFile {
					Property: Input;
				}
			}
			Section Utilities_from_Copy_Files_From_Server {
				StringParameter spMySlash {
					Definition: "/";
				}
				Procedure pr_GetFolders {
					Arguments: (spInpPath,sFolderNumbers,sFolderNames);
					Body: {
						if not pro::GetPROEndPoint() then return; endif ;
						
						pro::NormalizeStoragePath(spInpPath);
						ret := pro::storage::ListBuckets(
							path       :  spInpPath, 
							BucketSet  :  sLocBucketSet, 
							BucketSize :  pLocBucketSize, 
							BucketAuth :  spLocBucketAuth, 
							BucketDate :  spLocBucketDate);
						empty sFolderNumbers;                	
						for i_bs do
							SetElementAdd(sFolderNumbers,eFN,FormatString("%i",card(sFolderNumbers)+1));
							if eFN <> last( sFolderNumbers ) then raise error "internal error" ; endif ;
							sFolderNames(eFN) := i_bs ;
						endfor ;
						return card(sLocBucketSet);
					}
					Set sFolderNumbers {
						Index: iFN;
						Parameter: eFN;
						Property: Output;
					}
					StringParameter spInpPath {
						Property: Input;
					}
					StringParameter sFolderNames {
						IndexDomain: iFN;
						Property: Output;
					}
					DeclarationSection Local_declarations {
						Parameter ret;
						Set sLocBucketSet {
							Index: i_bs;
						}
						Parameter pLocBucketSize {
							IndexDomain: i_bs;
						}
						StringParameter spLocBucketAuth {
							IndexDomain: i_bs;
						}
						StringParameter spLocBucketDate {
							IndexDomain: i_bs;
						}
					}
				}
				Procedure pr_GetAllDirectories {
					Arguments: (spInpPath,sAllDirectoryNumbers,spAllDirectoryNames);
					Body: {
						block ! Initialize Directory List to "only root directory"
							sAllDirectoryNumbers := data { 1 };
							eADN := first( sAllDirectoryNumbers );
							spAllDirectoryNames(eADN) := spInpPath ;
							pNoVisitedDirectories := 0 ;
							pLastDirectoryToBeVisited := 1 ;
						endblock ;
						
						while pNoVisitedDirectories < pLastDirectoryToBeVisited do
						
							DialogProgress(
								formatString("Phase 1, obtaining folders %i of %i handled", pNoVisitedDirectories, pLastDirectoryToBeVisited),
								100 * ( pNoVisitedDirectories / pLastDirectoryToBeVisited ) );
						
							! Move to the next folder
							pNoVisitedDirectories += 1;
							eADN := pNoVisitedDirectories ;
							spCurrentDirectory := spAllDirectoryNames(eADN);
						
							! Get the directory names inside spCurrentDirectory
							res := pr_GetFolders( spCurrentDirectory, sRecentDirectoryNumbers, spRecentDirectoryNames );
							pNoRegisteredDirectoryNames := 0 ;
							while pNoRegisteredDirectoryNames < res do
								pNoRegisteredDirectoryNames += 1 ;
								eRDN := pNoRegisteredDirectoryNames ;
								sAllDirectoryNumbers += ( pLastDirectoryToBeVisited + pNoRegisteredDirectoryNames );
								eADN := ( pLastDirectoryToBeVisited + pNoRegisteredDirectoryNames );
								spAllDirectoryNames( eADN ) := spCurrentDirectory + spMySlash + spRecentDirectoryNames( eRDN );
							endwhile ; 
							pLastDirectoryToBeVisited += res ;
						
						endwhile ;
					}
					StringParameter spInpPath {
						Property: Input;
					}
					Set sAllDirectoryNumbers {
						SubsetOf: Integers;
						Index: iADN;
						Parameter: eADN;
						Property: ElementsAreLabels;
					}
					StringParameter spAllDirectoryNames {
						IndexDomain: iADN;
						Property: Output;
					}
					DeclarationSection Local_declarations {
						Parameter pNoVisitedDirectories;
						Parameter pLastDirectoryToBeVisited;
						Parameter pLastFileToBeVisited;
						StringParameter spCurrentDirectory;
						Set sRecentDirectoryNumbers {
							SubsetOf: Integers;
							Index: iRDN;
							Parameter: eRDN;
							Property: ElementsAreLabels;
						}
						StringParameter spRecentDirectoryNames {
							IndexDomain: iRDN;
						}
						Parameter pNoRegisteredDirectoryNames;
						Parameter res;
					}
				}
				Procedure pr_GetFiles {
					Arguments: (spInpPath,sFileNumbers,spFileNames,spFileTimes,pFileSizes);
					Body: {
						if not pro::GetPROEndPoint() then return; endif ;
						
						ret := pro::storage::ListObjects(spInpPath,sChildrenObj,spChildrenObjName,spChildrenObjType,pChildrenObjSize,spChildrenObjAuth);
						!if not handleError(ret) then return 0; endif; 
						res := card( sChildrenObj );
						for CURPATH_OBJ do
							sFileNumbers += ord( CURPATH_OBJ );
							ep_fin := last( sFileNumbers );
							spFileNames( ep_fin ) := spInpPath + spMySlash + CURPATH_OBJ ;
							spFullFileName := spInpPath + CURPATH_OBJ ;
							pro::storage::ListVersions(
								path        :  spInpPath, 
								objectLabel :  CURPATH_OBJ, 
								VersionSet  :  sVer, 
								VersionSize :  pVerSize, 
								BucketDate  :  spVerFileTimes );
							eVer := last(sVer);
							spFileTimes(ep_fin) := spVerFileTimes(eVer);
							pFileSizes(ep_fin) := PVerSize(eVer);
						endfor ;
					}
					DeclarationSection Argument_Declarations {
						StringParameter spInpPath {
							Property: Input;
						}
						Set sFileNumbers {
							SubsetOf: Integers;
							Index: iFN;
							Property: ElementsAreLabels;
						}
						StringParameter spFileNames {
							IndexDomain: iFN;
							Property: Output;
						}
						StringParameter spFileTimes {
							IndexDomain: iFN;
							Property: Output;
						}
						Parameter pFileSizes {
							IndexDomain: iFN;
							Property: Output;
						}
					}
					DeclarationSection Local_Declarations {
						ElementParameter ep_fin {
							Range: sFileNumbers;
						}
						Parameter ret;
						Parameter res;
						Set sVer {
							Index: iVer;
							Parameter: eVer;
						}
						Parameter pVerSize {
							IndexDomain: iVer;
						}
						StringParameter spVerFileTimes {
							IndexDomain: iVer;
						}
						Set sChildrenObj {
							Index: CURPATH_OBJ;
							Parameter: ChildrenObjElement;
						}
						StringParameter spFullFileName;
						StringParameter spChildrenObjName {
							IndexDomain: CURPATH_OBJ;
						}
						StringParameter spChildrenObjType {
							IndexDomain: CURPATH_OBJ;
						}
						Parameter pChildrenObjSize {
							IndexDomain: CURPATH_OBJ;
						}
						StringParameter spChildrenObjAuth {
							IndexDomain: CURPATH_OBJ;
						}
					}
				}
				Procedure pr_GetAllFiles {
					Arguments: (spInpPath,sFileNumbers,spFileNames,spFileTimes,pFileSizes);
					Body: {
						pr_GetAllDirectories(
							spInpPath            :  spInpPath, 
							sAllDirectoryNumbers :  sAllDirectoryNumbers, 
							spAllDirectoryNames  :  spAllDirectoryNames);
						p_noFolders := card( sAllDirectoryNumbers );
						
						for iADN do
						
							empty sLocFilenumbers ;
							eFN := last( sFileNumbers );
						
							DialogProgress(
								formatString("Phase 2, obtaining files, %e of %i folders handled, %e Files handled", 
								iADN, p_noFolders, eFN),
								100 * ( iADN / p_noFolders ) );
						
							pr_GetFiles( spAllDirectoryNames(iADN), sLocFilenumbers, 
								spLocFilenames, spLocFiletimes, pLocFilesizes );
							for iLFN do
								sFileNumbers += if eFN then val( eFN ) else 0 endif + val( iLFN );
								eNFN := last( sFilenumbers );
								spFilenames( eNFN ) := spLocFilenames( iLFN );
								spFileTimes( eNFN ) := spLocFiletimes( iLFN );
								 pFileSizes( eNFN ) :=  pLocFileSizes( iLFN );
							endfor ;
						
						endfor ;
					}
					DeclarationSection Argument_Declarations {
						StringParameter spInpPath {
							Property: Input;
						}
						Set sFileNumbers {
							SubsetOf: Integers;
							Index: iFN;
							Parameter: eFN, eNFN;
							Property: ElementsAreLabels;
						}
						StringParameter spFileNames {
							IndexDomain: iFN;
							Property: Output;
						}
						StringParameter spFileTimes {
							IndexDomain: iFN;
							Property: Output;
						}
						Parameter pFileSizes {
							IndexDomain: iFN;
							Property: Output;
						}
					}
					DeclarationSection Local_Declarations {
						Set sAllDirectoryNumbers {
							SubsetOf: Integers;
							Index: iADN;
							Parameter: eADN;
							Property: ElementsAreLabels;
						}
						StringParameter spAllDirectoryNames {
							IndexDomain: iADN;
						}
						Set sLocFileNumbers {
							SubsetOf: Integers;
							Index: iLFN;
							Parameter: eLFN;
							Property: ElementsAreLabels;
						}
						StringParameter spLocFilenames {
							IndexDomain: iLFN;
						}
						StringParameter spLocFiletimes {
							IndexDomain: iLFN;
						}
						Parameter pLocFilesizes {
							IndexDomain: iLFN;
						}
						Parameter p_noFolders;
					}
				}
				Procedure NIY {
					Body: {
						raise error "Not Implemented Yet";
					}
				}
			}
		}
		Section Logging_utilities {
			Procedure pr_openLogFile {
				Body: {
					f_traceFile.pagewidth := 32000 ;
					putclose f_traceFile ;
					put f_traceFile;
					put "Opening log file ", sp_traceFilename, " at ", CurrentToSTring("%c%y-%m-%d %H:%M:%S"), / ;
					if bp_isConnectedToPro then
						if bp_isWorkerSession then
							put "This file contains the log of a solver session handling request ", 
								pro::workerRequestDescription, / ;
						else
							put "This file contains the log of a data session on behalf of ", 
								pro::GetPROUserName(), "@", pro::GetPROEnvironment(), / ;
						endif ;
					else
						put "This file contains the log of an AIMMS Developer session ", / ;
					endif ;
					
					putclose ;
				}
				Comment: "Open log file and add identifying first few lines.";
				DeclarationSection Debugging_Declarations;
			}
			Procedure pr_logMsgTraceFile {
				Arguments: (sp_argMsg,ep_messageImportance);
				Body: {
					if ep_messageImportance >= ep_tracingFilterlevel then
						put f_traceFile ;
						put sp_argMsg, / ;
						putclose ;
						if bp_replicateInSessionLog then
							if pro::GetPROEndPoint() then
								pro::management::LocalLogInfo(  sp_argMsg );
					!			switch ep_messageImportance do
					!				'trace':   pro::management::LocalLogTrace( sp_argMsg );
					!				'debug':   pro::management::LocalLogDebug( sp_argMsg );
					!				'info':    pro::management::LocalLogInfo(  sp_argMsg );
					!				'warn':    pro::management::LocalLogInfo(  sp_argMsg );
					!				'error':   pro::management::LocalLogError( sp_argMsg );
					!				default:   pro::management::LocalLogInfo(  sp_argMsg );
					!			endswitch ;
							endif ;
						endif ;
					endif ;
					!
				}
				Comment: {
					"Trace to the log file; this procedure should not be called before LibraryInitialization finished."
				}
				StringParameter sp_argMsg {
					Property: Input;
				}
				ElementParameter ep_messageImportance {
					Range: s_messageLevels;
					Default: 'trace';
					Property: Optional;
				}
			}
			Procedure pr_downloadActionLogWork {
				Arguments: (sp_filename);
				Body: {
					sp_slash := "/" ;
					if ep_shownSession <> first( s_trackedSessions ) then
						! The first tracked session is the data session.
						! The other session, are server sessions, and they are stored
						! in /Userdata/<env>/<user>/<model>/tracings" + 
						sp_proStorageFilename := sp_slash + "Userdata" + sp_slash + 
							pro::GetPROEnvironment() + sp_slash + 
							pro::GetPROUserName()    + sp_slash + 
							pro::ModelName           + sp_slash + 
							sp_tracingsFolderName    + sp_slash + 
							ep_shownSession          + ".actionLog";
						sp_localTraceFilename := sp_tracingsFolderName + sp_slash + ep_shownSession + ".actionLog" ;
						! Copy the .actionLog file from AIMMS PRO storage to the folder "tracings".
						pro::RetrieveFileFromCentralStorage(
							storagePath :  sp_proStorageFilename, 
							localPath   :  sp_localTraceFilename);
					else
						sp_localTraceFilename := sp_traceFilename ;
					endif ;
					p_slashFwd := FindNthString( sp_localTraceFilename, "/", -1 );
					p_slashBwd := FindNthString( sp_localTraceFilename, "\\", -1 );
					p_slash := max( p_slashFwd, p_slashBwd);
					if p_slash then
						p_len := StringLength( sp_localTraceFilename );
						sp_filename := SubString( sp_localTraceFilename, p_slash+1, p_len); 
						FileCopy( sp_localTraceFilename, sp_filename );
					else
						sp_filename := sp_localTraceFilename;
					endif ;
				}
				StringParameter sp_filename {
					Property: InOut;
				}
				StringParameter sp_slash;
				StringParameter sp_proStorageFilename;
				StringParameter sp_localTraceFilename;
				Parameter p_slashFwd;
				Parameter p_slashBwd;
				Parameter p_slash;
				Parameter p_len;
			}
			Procedure pr_getThisSession {
				Body: {
					bp_nextArgIsSessionId := 0 ;
					bp_isConnectedToPro := 0 ;
					bp_isWorkerSession := 0 ;
					bp_isVerifySession := 0 ;
					sp_thisSession := "" ;
					block ! loop over arguments to find the session id.
						p_argno := 1 ;
						repeat 
							bp_argExists := SessionArgument( p_argno, sp_arg );
							if not bp_argExists then
								break ;
							endif ;
							if bp_nextArgIsSessionId then
								sp_thisSession := sp_arg ;
							elseif sp_arg = "_pro-session-id" then
								bp_nextArgIsSessionId := 1 ;
								bp_isWorkerSession := 1 ;
								bp_isConnectedToPro := 1 ;
							elseif sp_arg = "_pro-webui-session-id" then
								bp_nextArgIsSessionId := 1 ;
								bp_isConnectedToPro := 1 ;
							elseif sp_arg = "verify" then
								bp_isVerifySession := 1 ;
							endif ;
							p_argno += 1 ;
						endrepeat ;
					endblock ;
					if bp_isVerifySession then
						return ;
					endif ;
					if not sp_thisSession then
						sp_thisSession := CurrentToString("%c%y%m%dT%H%M%S%t%TZ('UTC')");
					endif ;
					
					
					block ! Initialize logging
						if bp_isConnectedToPro then
							if not bp_isWorkerSession then
								ep_trackedSession := stringToElement( s_trackedSessions, sp_thisSession, create:1);
							endif ;
						else
							ep_trackedSession := stringToElement( s_trackedSessions, sp_thisSession, create:1);
						endif ;
					
						if sp_thisSession then
							sp_traceFilename := sp_tracingsFolderName + "/" + sp_thisSession + ".actionLog" ;
						endif ;
					
						if not  DirectoryExists( sp_tracingsFolderName ) then
							DirectoryCreate( sp_tracingsFolderName );
						endif ;
						if fileExists( sp_traceFilename ) then
							FileDelete( sp_traceFilename );
						endif ;
					endblock ;
					
					! Open log file for data session or AIMMS Developer session.
					if bp_isConnectedToPro then
						if bp_isWorkerSession then
							! pr_openLogFile();
							! The log file for a server session is opened at the beginning of pr_guardAndProfileServerJob().
						else
							pr_openLogFile();
						endif ;
					else
						pr_openLogFile();
					endif ;
				}
				Comment: {
					"Get the unique identifier of this session. 
					Whenever possible, align with AIMMS PRO - to make matching with AIMMS PRO generated logging information easier.
					When not on PRO, use timestamp."
				}
				Parameter p_argno;
				Parameter bp_argExists;
				StringParameter sp_arg;
				ElementParameter ep_trackedSession {
					Range: s_trackedSessions;
				}
				Parameter bp_nextArgIsSessionId {
					Range: binary;
				}
			}
			Procedure pr_actuallySaveActionLogFile {
				Arguments: (sp_fn,sp_folder);
				Body: {
					sp_slash := "/" ;
					if fileExists( sp_fn ) then
						sp_proStorageFileName := sp_folder + sp_slash + sp_fn ;
						pro::SaveFileToCentralStorage(
							localPath     :  sp_fn, 
							storagePath   :  sp_proStorageFileName);
						pro::management::LocalLogInfo(formatString(
							"pr_actuallySaveActionLogFile(): pro::SaveFileToCentralStorage(%s,%s)",
							sp_fn, sp_proStorageFileName));
					else
						pro::management::LocalLogInfo(
							"pr_actuallySaveActionLogFile() sp_fn = " + 
							sp_fn + 
							" does not exist."
						);
					endif ;
				}
				Comment: "Helper procedure of pr_saveActionLogFile.";
				StringParameter sp_fn {
					Property: Input;
				}
				StringParameter sp_folder {
					Property: Input;
				}
				StringParameter sp_slash;
				StringParameter sp_proStorageFileName;
			}
			Procedure pr_saveLogfilesProTempfolder {
				Body: {
					DirectoryGetFiles(
						directory       :  pro::GetPROTempFolder(), 
						filter          :  "", 
						filenames       :  sp_filenames, 
						recursive       :  0, 
						attributeFilter :  {});
					sp_slash := "/" ;
					sp_folder := sp_slash + "Userdata" + sp_slash + 
							pro::GetPROEnvironment() + sp_slash + 
							pro::GetPROUserName()    + sp_slash + 
							pro::ModelName           + sp_slash + 
							sp_thisSession           + sp_slash
							;
					block ! Tracing the saving of log files.
						pro::management::LocalLogInfo(formatString(
							"pr_saveLogfilesProTempfolder(): pro::GetPROTempFolder() = %s, sp_folder = %s",
							pro::GetPROTempFolder(), sp_folder));
						for i_fileNo do
							pro::management::LocalLogInfo("    Saving: " + sp_filenames(i_fileNo));
						endfor ;
					endblock ;
					
					for i_fileNo do
						sp_fn := pro::GetPROTempFolder() + sp_slash + sp_filenames(i_fileNo );
						sp_proStorageFileName := sp_folder + sp_filenames(i_fileNo );
						pro::SaveFileToCentralStorage(
							localPath     :  sp_fn, 
							storagePath   :  sp_proStorageFileName);	
					endfor ;
				}
				Set s_fileNumbers {
					SubsetOf: Integers;
					Index: i_fileNo;
				}
				StringParameter sp_filenames {
					IndexDomain: i_fileNo;
				}
				StringParameter sp_fn;
				StringParameter sp_proStorageFileName;
				StringParameter sp_folder;
				StringParameter sp_slash;
			}
			StringParameter sp_tracingsFolderName {
				Definition: "tracings";
				Comment: "Logging is first written to a subfolder of the project folder.";
			}
			StringParameter sp_thisSession {
				InitialData: "this-session";
				Comment: "the unique code for this session.";
			}
			File f_traceFile {
				Name: sp_traceFilename;
				Device: Disk;
				Mode: merge;
			}
			ElementParameter ep_traceTimezone {
				Range: AllTimeZones;
				InitialData: {
					!'local'
					'LocalDST'
					! 'UTC'
				}
				Comment: {
					"Tracing time zone.
					See ticket 11"
				}
			}
			Parameter bp_replicateInSessionLog {
				Range: binary;
				InitialData: 0;
			}
		}
		Section Memory_in_use {
			Parameter p_memoryInUse {
				InitialData: 0;
			}
			Parameter p_peakMemoryInUse {
				InitialData: 0;
			}
		}
		Section Request_Mngmt {
			Parameter bp_isAnAdmin {
				Range: binary;
				Comment: "See also p_nonAdminUser";
			}
			Parameter bp_isRunningOnCloud {
				Range: binary;
			}
			StringParameter sp_beginHoursLastThreeMonths;
			StringParameter sp_endHoursLastThreeMonths;
			StringParameter sp_TimeFmtLocalTimezone {
				Definition: "%c%y-%m-%d %H:%M:%S%TZ('Local')";
			}
			Procedure pr_itsOK {
				Arguments: (sp_response);
				StringParameter sp_response {
					Property: Input;
				}
			}
			Function fnc_currentToStringDelta {
				Arguments: (p_deltaSeconds);
				Range: string;
				Body: {
					p_ogv := OptionGetValue(
						OptionName :  "use_UTC_forCaseAndStartEndDate", 
						Lower      :  p_low, 
						Current    :  p_cur, 
						Default    :  p_def, 
						Upper      :  p_upp);
					if not p_ogv then ! Option use_UTC_forCaseAndStartEndDate is introduced with AIMMS 4.75.
						p_cur := 0 ; ! Assume option use_UTC_forCaseAndStartEndDate is off.
					endif ;
					p_tmpSec := CurrentToMoment([s], "2021-01-01 00:00:00") ;
					p_tmpSec += (p_deltaSeconds) [s];
					if p_cur then
						fnc_currentToStringDelta := MomentToString( "%c%y-%m-%d %H:%M:%S%TZ('UTC')", [s], "2021-01-01 00:00:00", p_tmpSec );
					else
						fnc_currentToStringDelta := MomentToString( "%c%y-%m-%d %H:%M:%S", [s], "2021-01-01 00:00:00", p_tmpSec );
					endif ;
				}
				Comment: {
					"The function fnc_currentToStringDelta is a helper function for ScheduleAt.
					It constructs the time string to be used when another procedure is to be scheduled.
					
					ScheduleAt interprets this string as in LocalDST when the option use_UTC_forCaseAndStartEndDate is off, and 
					it interprets it as in UTC when the option use_UTC_forCaseAndStartEndDate is on.
					
					Original code from guipro:currentToStringDelta
					tmpSec := CurrentToMoment([s], \"2011-01-01 00:00:00\") ;
					tmpSec += (deltaSeconds) [s];
					CurrentToStringDelta := MomentToString( \"%c%y-%m-%d %H:%M:%S\", [s], \"2011-01-01 00:00:00\", tmpSec );"
				}
				Parameter p_deltaSeconds {
					Property: Input;
				}
				Parameter p_tmpHour {
					Range: integer;
				}
				Parameter p_tmpMin {
					Range: integer;
				}
				Parameter p_tmpSec {
					Range: integer;
					Unit: s;
				}
				Parameter p_ogv;
				Parameter p_low;
				Parameter p_cur;
				Parameter p_def;
				Parameter p_upp;
			}
			Procedure pr_saveAndOpenVersionInTemp {
				Arguments: (sp_versionID);
				Body: {
					p_ret := pro::LoadLogMessages( sp_versionID, sp_sessionLogFile );
					if not (p_ret) then return 0; endif;
					
					!!PageOpen("Log File Viewer");
					webui::OpenDialogPage(
						pageId  :  'WUIP_view_log_file', 
						title   :  "View log file", 
						actions :  s_okDone, 
						onDone  :  'gss::pr_itsOk');
					
					return 1;
				}
				StringParameter sp_versionID {
					Property: Input;
				}
				StringParameter sp_getFileName {
					InitialData: "";
				}
				Parameter p_ret;
				StringParameter sp_logFolder;
			}
			Procedure pr_onDoneRequestManager {
				Arguments: (sp_response);
				Body: {
					! Nothing to do.
				}
				StringParameter sp_response {
					Property: Input;
				}
			}
			Function fnc_statusDescription {
				Arguments: (p_stat);
				Range: string;
				Body: {
					sp_retval := "" ;
					if p_stat = 0 then
						sp_retval := "created" ;
					elseif p_stat = 1 then
						sp_retval := "queued" ;
					elseif p_stat = 2 then
						sp_retval := "initializing" ;
					elseif p_stat = 3 then
						sp_retval := "ready" ;
					elseif p_stat = 4 then
						sp_retval := "running" ;
					elseif p_stat = 5 then
						sp_retval := "closing" ;
					elseif p_stat = 6 then
						sp_retval := "finished" ;
					elseif p_stat = 7 then
						sp_retval := "terminated" ;
					elseif p_stat = 8 then
						sp_retval := "error" ;
					elseif p_stat = 9 then
						sp_retval := "deleted" ;
					else
						sp_retval := "unknown" ;
					endif ;
					fnc_statusDescription := sp_retval ;
				}
				Comment: "based on the pro::PROTS_ ... constants.";
				Parameter p_stat {
					Property: Input;
				}
				StringParameter sp_retval;
			}
			Procedure pr_emptyProc;
			Procedure pr_responseProtocol {
				Arguments: (sp_requestId);
				StringParameter sp_requestId {
					Property: Input;
				}
			}
		}
		Section Authorization_tools {
			DeclarationSection User_and_Group_Entities {
				Set s_PROEnv {
					Index: i_PRO_ENV;
					Parameter: ep_Env, ep_GUI_Env;
					OrderBy: i_PRO_ENV;
				}
				Set s_PROEntity {
					Index: i_PRO_ENT, i_PRO_ENT_U, i_PRO_ENT_G;
					Parameter: ep_Entity;
				}
				Set s_PROUser {
					SubsetOf: s_PROEntity;
					Index: i_PRO_USER;
					Parameter: ep_User;
					OrderBy: sp_PROUserName(i_PRO_USER);
				}
				Set s_PROEnvUser {
					IndexDomain: (i_PRO_ENV);
					SubsetOf: s_PROUser;
				}
				Set s_PROGroup {
					SubsetOf: s_PROEntity;
					Index: i_PRO_GRP;
					Parameter: ep_Group;
					OrderBy: sp_PROGroupName(i_PRO_GRP);
				}
				Set s_PROEnvGroup {
					IndexDomain: (i_PRO_ENV);
					SubsetOf: s_PROGroup;
				}
				StringParameter sp_PROEnvName {
					IndexDomain: (i_PRO_ENV);
				}
				StringParameter sp_PROEnvDescr {
					IndexDomain: (i_PRO_ENV);
				}
				StringParameter sp_PROEnvAuth {
					IndexDomain: (i_PRO_ENV);
				}
				StringParameter sp_PROUserName {
					IndexDomain: (i_PRO_ENT_U);
				}
				StringParameter sp_PROGroupName {
					IndexDomain: (i_PRO_ENT_G);
				}
				Parameter bp_PROUserGroup {
					IndexDomain: (i_PRO_ENT_U,i_PRO_ENT_G);
					Range: binary;
				}
				Parameter bp_PROEntityIsGroup {
					IndexDomain: i_PRO_ENT;
					Range: binary;
				}
				StringParameter sp_PROEntityType {
					IndexDomain: i_PRO_ENT;
					Definition: {
						if bp_PROEntityIsGroup(i_PRO_ENT) then
						        "group"
						else
						        "user"
						endif
					}
				}
				ElementParameter ep_PROEntityEnvironment {
					IndexDomain: i_PRO_ENT;
					Range: s_PROEnv;
					Default: '';
				}
				StringParameter sp_PROEntityEnvironmentName {
					IndexDomain: i_PRO_ENT;
					Definition: {
						if ep_PROEntityEnvironment(i_PRO_ENT) = '' then
						        if (Val(i_PRO_ENT) = 16777215 OR Val(i_PRO_ENT) = 16777087) then
						                "<<all>>"
						        else
						                "?"
						        endif
						else
						        sp_PROEnvName(ep_PROEntityEnvironment(i_PRO_ENT))
						endif
					}
				}
				StringParameter sp_PROEntityName {
					IndexDomain: i_PRO_ENT;
				}
			}
			Procedure pr_PopulateEntitySets {
				Arguments: (bp_addUniversalSets);
				Body: {
					! Populate users and groups
					p_ret := pro::authentication::GetEnvironmentList(s_PROEnv,sp_PROEnvName,sp_PROEnvDescr,sp_PROEnvAuth);
					for (i_PRO_ENV) do
					        block
					                empty s_userCurrentEnv, s_groupCurrentEnv;
					
					                p_ret := pro::authentication::GetEnvironmentUsersAndGroups(sp_PROEnvName(i_PRO_ENV),s_userCurrentEnv,s_groupCurrentEnv,sp_PROUserName,sp_PROGroupName);
					
					                if (bp_addUniversalSets) then
					                        sp_tmpEnt := FormatString("%i",16776960 + Val(i_PRO_ENV));   ! 0xFFFF00 = 0xFFFF | 0x0 (+ 7 bits to the environment id)
					                        SetElementAdd(s_PROUser,ep_User,sp_tmpEnt);
					                        sp_PROUserName(ep_User) := "<<all>>";
					                        s_userCurrentEnv += ep_User;
					                        sp_tmpEnt := FormatString("%i",16777088 + Val(i_PRO_ENV));   ! 0xFFFF80 = 0xFFFF | 0x1 (+ 7 bits to the environment id)
					                        SetElementAdd(s_PROGroup,ep_Group,sp_tmpEnt);
					                        sp_PROGroupName(ep_Group) := "<<all>>";
					                        s_groupCurrentEnv += ep_Group;
					                endif;
					
					                s_PROEnvUser(i_PRO_ENV) := s_userCurrentEnv;
					                s_PROEnvGroup(i_PRO_ENV) := s_groupCurrentEnv;
					
					                ep_PROEntityEnvironment(i_PRO_ENT in s_userCurrentEnv) := i_PRO_ENV;
					                ep_PROEntityEnvironment(i_PRO_ENT in s_groupCurrentEnv) := i_PRO_ENV;
					        onerror ep_err do
					                errh::MarkAsHandled(ep_err);
					        endblock;
					endfor;
					
					! Retrieve user and group relationships
					empty bp_PROUserGroup;
					for (i_PRO_ENV) do
					        block
					                p_ret := pro::authentication::GetEntityList(sp_PROEnvName(i_PRO_ENV),s_PROUser,s_PROGroup,sp_PROUserName,sp_PROGroupName,bp_PROUserGroup);
					        onerror ep_err do
					                errh::MarkAsHandled(ep_err);
					        endblock;
					endfor;
					
					! Add universal group
					if (bp_addUniversalSets) then
					        empty s_userCurrentEnv,s_groupCurrentEnv;
					
					        sp_tmpEnt := FormatString("%i", 127);
					        SetElementAdd(s_PROEnv,ep_Env,sp_tmpEnt);
					        sp_PROEnvName(ep_Env) := "<<all>>";
					
					        sp_tmpEnt := FormatString("%i",16776960 + Val(ep_Env));    ! 0xFFFF00 = 0xFFFF | 0x0 (+ 7 bits to the environment id)
					        SetElementAdd(s_PROUser,ep_User,sp_tmpEnt);
					        sp_PROUserName(ep_User) := "<<all>>";
					        s_userCurrentEnv += ep_User;
					
					        sp_tmpEnt := FormatString("%i",16777088 + Val(ep_Env));    ! 0xFFFF80 = 0xFFFF | 0x1 (+ 7 bits to the environment id)
					        SetElementAdd(s_PROGroup,ep_Group,sp_tmpEnt);
					        sp_PROGroupName(ep_Group) := "<<all>>";
					        s_groupCurrentEnv += ep_Group;
					
					        s_PROEnvUser(ep_Env) := s_userCurrentEnv;
					        s_PROEnvGroup(ep_Env) := s_groupCurrentEnv;
					        ep_PROEntityEnvironment(i_PRO_ENT in s_userCurrentEnv) := ep_Env;
					        ep_PROEntityEnvironment(i_PRO_ENT in s_groupCurrentEnv) := ep_Env;
					endif;
					
					empty bp_PROEntityIsGroup;
					bp_PROEntityIsGroup(i_PRO_GRP) := 1;
					sp_PROEntityName(i_PRO_USER) := sp_PROUserName(i_PRO_USER);
					sp_PROEntityName(i_PRO_GRP) := sp_PROGroupName(i_PRO_GRP);
				}
				Parameter p_ret;
				ElementParameter ep_err {
					Range: errh::PendingErrors;
				}
				Set s_userCurrentEnv {
					SubsetOf: s_PROUser;
				}
				Set s_groupCurrentEnv {
					SubsetOf: s_PROGroup;
				}
				StringParameter sp_tmpEnt;
				Parameter bp_addUniversalSets {
					Range: binary;
					Default: 0;
					Property: Optional;
				}
			}
			Procedure pr_deconstructAuthorizationString {
				Arguments: (sp_authString,s_authEntity,p_authEntityDeny,p_authEntityExec,p_authEntityRead,p_authEntityWrite);
				Body: {
					if SubString(sp_authString,1,1) = "#" then
					        p_tmpLength := StringLength(sp_authString);
					        p_tmpLast := 2;
					        p_tmpCont := 2;
					        p_tmpNext := FindNthString(sp_authString,"#",p_tmpCont);
					        while p_tmpLast < p_tmpLength do
					                if (p_tmpNext = 0) then p_tmpNext := p_tmpLength + 1; endif;
					
					                sp_tmpAuth := SubString(sp_authString,p_tmpLast,p_tmpNext - 1);
					
					                sp_tmpEnt := SubString(sp_tmpAuth,3,1000);
					                ip_tmpFlag := Val(SubString(sp_tmpAuth,1,1));
					                if SubString(sp_tmpAuth,2,2) = "-" then
					                        bp_tmpDeny := 1;
					                else
					                        bp_tmpDeny := 0;
					                endif;
					
					                ep_Entity := StringToElement(s_PROEntity,sp_tmpEnt);
					                s_authEntity += ep_Entity;
					                p_authEntityDeny(ep_Entity) := bp_tmpDeny;
					
					                if Mod(div(ip_tmpFlag,2^0),2)=1 then p_authEntityExec(ep_Entity) := 1; endif;
					                if Mod(div(ip_tmpFlag,2^1),2)=1 then p_authEntityWrite(ep_Entity) := 1; endif;
					                if Mod(div(ip_tmpFlag,2^2),2)=1 then p_authEntityRead(ep_Entity) := 1; endif;
					
					                p_tmpLast := min(p_tmpNext + 1,p_tmpLength);
					                p_tmpCont += 1;
					                p_tmpNext := FindNthString(sp_authString,"#",p_tmpCont);
					        endwhile;
					
					endif;
				}
				StringParameter sp_authString {
					Property: Input;
				}
				Set s_authEntity {
					SubsetOf: s_PROEntity;
					Index: auth_ent;
					Property: Output;
				}
				Parameter p_authEntityDeny {
					IndexDomain: auth_ent;
					Property: Output;
				}
				Parameter p_authEntityExec {
					IndexDomain: auth_ent;
					Property: Output;
				}
				Parameter p_authEntityRead {
					IndexDomain: auth_ent;
					Property: Output;
				}
				Parameter p_authEntityWrite {
					IndexDomain: auth_ent;
					Property: Output;
				}
				Parameter p_tmpLength;
				Parameter p_tmpLast;
				Parameter p_tmpNext;
				Parameter p_tmpCont;
				Parameter ip_tmpFlag {
					Range: integer;
				}
				StringParameter sp_tmpAuth;
				Parameter bp_tmpDeny {
					Range: binary;
				}
				StringParameter sp_tmpEnt;
			}
			Procedure pr_constructAuthorizationString {
				Arguments: (s_authEntity,p_authEntityDeny,p_authEntityExec,p_authEntityRead,p_authEntityWrite,sp_authString);
				Body: {
					for auth_ent do
					    ip_tmpFlag := 0;
					    if p_authEntityExec(auth_ent) then ip_tmpFlag += 2^0; endif;
					    if p_authEntityWrite(auth_ent) then ip_tmpFlag += 2^1; endif;
					    if p_authEntityRead(auth_ent) then ip_tmpFlag += 2^2; endif;
					    if p_authEntityDeny(auth_ent) then sp_tmpAuth := "-"; else sp_tmpAuth := "+"; endif;
					    sp_authString += FormatString("#%i%s%e",ip_tmpFlag,sp_tmpAuth,auth_ent);
					endfor;
				}
				Set s_authEntity {
					SubsetOf: s_PROEntity;
					Index: auth_ent;
					Property: Input;
				}
				Parameter p_authEntityDeny {
					IndexDomain: auth_ent;
					Property: Input;
				}
				Parameter p_authEntityExec {
					IndexDomain: auth_ent;
					Property: Input;
				}
				Parameter p_authEntityRead {
					IndexDomain: auth_ent;
					Property: Input;
				}
				Parameter p_authEntityWrite {
					IndexDomain: auth_ent;
					Property: Input;
				}
				StringParameter sp_authString {
					Property: Output;
				}
				Parameter ip_tmpFlag {
					Range: integer;
				}
				StringParameter sp_tmpAuth;
			}
		}
		Section Internal_checks {
			Section Current_Directory_Check {
				Parameter bp_warningIssuedChangeCurrentDirectory {
					Range: binary;
					InitialData: 0;
				}
				Procedure pr_checkCurrentFolder {
					Body: {
						if not bp_warningIssuedChangeCurrentDirectory then
							DirectoryGetCurrent( sp_currentFolder );
							if sp_currentFolder <> sp_startupFolder then
								raise warning formatString("Unexpected change in the current folder from %s to %s",
									sp_startupFolder, sp_currentFolder) ;
								bp_warningIssuedChangeCurrentDirectory := 1;
							endif ;
						endif ;
					}
					Comment: {
						"AIMMS only supports DirectoryGetCurrent and not DirectorySetCurrent; 
						because the AIMMS process needs to have the current directory constant -
						namely the folder in which the .aimms is located.  
						This folder is also known as the project folder.
						
						This function verifies that the current directory is still the same as the 
						directory in which the AIMMS process started.
						This function is called in gss::pr_enter, and gss::pr_leave."
					}
				}
			}
		}
	}
}
