## ams_version=1.0

LibraryModule Library_GuardServerSessionTest {
	Prefix: gsst;
	Section MyTest {
		Set s_identifiersSavedInCase {
			SubsetOf: AllIdentifiers;
			InitialData: {
				data 
				    { 'gss::s_inputCaseIdentifiers' ,
				      'gss::s_outputCaseIdentifiers',
				      'gss::ep_tracingFilterlevel'  ,
				      'gss::sp_serverSessionId'     ,
				      'gss::p_jobProfilerData'      ,
				      'gss::sp_jobErrorMessages'    ,
				      'gss::sp_jobErrorMoments'     ,
				      'gss::ep_jobErrorSeverity'    ,
				      'gss::ep_jobErrorNodes'       ,
				      'gss::ep_jobErrorAttributes'  ,
				      'gss::p_jobErrorLines'        }
			}
		}
		Set s_identifiersSavedInCaseCheck {
			SubsetOf: AllIdentifiers;
			InitialData: {
				data 
				    { 'gss::s_inputCaseIdentifiers' ,
				      'gss::s_outputCaseIdentifiers',
				      'gss::ep_tracingFilterlevel'  ,
				      'gss::sp_serverSessionId'     ,
				      'gss::p_jobProfilerData'      ,
				      'gss::sp_jobErrorMessages'    ,
				      'gss::sp_jobErrorMoments'     ,
				      'gss::ep_jobErrorSeverity'    ,
				      'gss::ep_jobErrorNodes'       ,
				      'gss::ep_jobErrorAttributes'  ,
				      'gss::p_jobErrorLines'        }
			}
		}
		Set s_diffIdentifiersSavedInCase {
			SubsetOf: AllIdentifiers;
			Definition: {
				( s_identifiersSavedInCase - s_identifiersSavedInCaseCheck ) +
				( s_identifiersSavedInCaseCheck - s_identifiersSavedInCase )
			}
		}
		Procedure pr_findIdentifiersSavedInCase {
			Body: {
				s_identifiersSavedInCase := 
					{ indexIdentifiers | not gss::fnc_hasPropertyNoSave( IndexIdentifiers ) } *
					( allparameters + allsets + allvariables + allconstraints + AllMathematicalPrograms ) *
					Library_GuardServerSession ;
				aimmsunit::AssertTrue( 
					"Ensure the same GSS identifiers are still saved in a PRO Input / Output case",
					card( s_diffIdentifiersSavedInCase ) = 0 );
			}
			aimmsunit::TestSuite: GSSunitTest;
		}
	}
	Procedure LibraryInitialization {
		Comment: "Add initialization statements here that do not require any other library being initialized already.";
	}
	Procedure PostLibraryInitialization {
		Comment: {
			"Add initialization statements here that require another library to be initialized already,
			or add statements that require the Data Management module to be initialized."
		}
	}
	Procedure PreLibraryTermination {
		Body: {
			return 1;
		}
		Comment: {
			"Add termination statements here that require all other libraries to be still alive.
			Return 1 if you allow the termination sequence to continue.
			Return 0 if you want to cancel the termination sequence."
		}
	}
	Procedure LibraryTermination {
		Body: {
			return 1;
		}
		Comment: {
			"Add termination statements here that do not require other libraries to be still alive.
			Return 1 to allow the termination sequence to continue.
			Return 0 if you want to cancel the termination sequence.
			It is recommended to only use the procedure PreLibraryTermination to cancel the termination sequence and let this procedure always return 1."
		}
	}
}
