Taking Multiple into account calling an OpenAPI REST API
============================================================

:download:`AIMMS 4.90 project download <model/LocationIQOpenAPIClient.zip>` 


Calling a generated OpenAPI Library, the word "multiple" comes back in several ways:

#.  A single service URL can service multiple endpoints, 
    for instance for for finding coordinates of an address, and 
    another for finding an address at some coordinates. 
    Not only are there several endpoints, there are also several schemas for the requests and the responses.
    It is thus important to find which endpoint to use, and which schemas to fill with data, 
    and which schemas to copy data from.

#.  The response of a single request can have multiple items. 
    For instance, searching for "Church street" will give several results. 

#.  Multiple requests are needed to find the locations of cities on a map.  
    For instance, finding an optimal route involves multiple locations.

#.  Rate limits of a service, limit the number of requests per time period.  
    Rate limits often depend on your license.

This how-to article discusses modeling approaches for each of the above.
Before going into the details of the above, we present an API to serve as the background of this article.


The Story
-----------

The service `Search by LocationIQ.com <https://locationiq.com/>`_ offers, `amongst others <https://locationiq.com/demo>`_, the following methods:

*   **search**: Forward Geocoding: A free form address to Geographical coordinates,

*   **Matrix**: Compute distance, by time or length, between locations.

Overview
--------

First get an OpenAPI specification of the API at hand.

After that, we will focus on the **search** method, and do:

*   Making an API Call, we need to put together the method, its inputs, and its outputs.

*   The response of a single request may contain several answers. 

*   Making multiple requests, and respecting the rate limit.

The OpenAPI specification
---------------------------

OpenAPI specifications can be found at various places, including `APIs.guru <https://apis.guru/>`_, `github <https://github.com/>`_,  and others.
The one used in this article was found on `Github LocationIQ <https://github.com/>`_  

Reading tips for an OpenAPI specification
----------------------------------------------

An OpenAPI specification is written in a ``.json`` or ``.yaml`` file. 
Although these are text files, I find the following two tools more effective in understanding how to use an OpenAPI specification in an AIMMS application:

*   The site: `Swagger editor <https://editor.swagger.io/>`_.
    After loading the OpenAPI spec file downloaded from github, the search interface shows:
    
    .. image:: images/Swagger-LocationIQ-search.png
        :align: center

    In addition, this editor will show no request body, but a response file for this method.

*   Peek at the code generated for the search method:

    *   ``apiCall``: this procedure does not use a request body, but does use several arguments, most of which are optional.

    *   ``callback``: this procedure reads in a response body (schema ``media_type_schema_15``, not present in the OpenAPI spec, so generated by DEX).
        This means that upon success, the identifiers in the schema ``media_type_schema_15`` will be filled when the response hook starts.

        .. image:: images/valid-response-uses-media-type-schema.png
            :align: center

The first search call
------------------------

When searching for a landmark, sometimes the same name is used at multiple places on the globe.
For instance, searching for ``Brandenburg Gate``, returns 3 locations, as illustrated in the next image:

    .. image:: images/single-call-multiple-answers.png
        :align: center

The calling code that achieves this is:

.. code-block:: aimms 
    :linenos:

    Procedure pr_testWithOpenAPI_1 {
        Body: {
            Empty s_locations ;
            pr_makeRequest( first( s_addressNumbers ) );
        }
    }

The code for making a request, does not need to take multiple answers into account:

Making the request
^^^^^^^^^^^^^^^^^^^^^

Making a request is coded in the procedure ``locationSearch::pr_makeRequest``.
Note that this code is structured similarly to the API calling code `in the previous article <https://how-to.aimms.com/Articles/562/562-ipTwist.html#calling-the-api>`_.

.. code-block:: aimms 
    :linenos:
    :emphasize-lines: 8,14-18

    ! Request call instance - used by response hook to determine the request to which the response belongs.
    LocationIQ::api::NewCallInstance( ep_callInstance );

    ! Fill in the data for making the request.
    ! Nothing here, but data is passed in the LocationIQ::api::search::apiCall arguments.

    ! Fill in the data for administration used inside this module.
    ep_addresses( ep_callInstance ) := ep_addressNo ;

    ! Install hook, which will copy the data or handle the error
    LocationIQ::api::search::UserResponseHook := 'locationSearch::pr_responseHook' ;

    ! Start the request.
    LocationIQ::api::search::apiCall(
        callInstance    :  ep_callInstance, 
        q               :  sp_addressString(ep_addressNo), 
        format_         :  'json', 
        normalizecity   :  '1') ;

Remarks:

*   Lines 7,8: The module ``LocationSearchModule``, prefix ``LocationSearch``, uses 
    element parameter ``LocationSearch::ep_addresses`` to map each call instance to an address number.

*   Lines 14-18: The ``apiCall`` for the ``LocationIQ`` method search, passes information in the URL. 
    This information is passed in its arguments. 
    This example only fills the mandatory arguments.

The code for handling a response, however, does need to take multiple answers into account:


Handling the response
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Handling a response is coded in the procedure ``locationSearch::pr_responseHook``

.. code-block:: aimms 
    :linenos:

    ep_addr := ep_addresses( ep_callInstance );
    switch LocationIQ::api::CallStatusCode(ep_callInstance) do
        '200':
            for LocationIQ::_media_type_schema_15::i_media_type_schema_15 | LocationIQ::_media_type_schema_15::display_name(ep_callInstance, LocationIQ::_media_type_schema_15::i_media_type_schema_15) do

                s_locations += card( s_locations ) + 1; ! Get a new location id.
                ep_loc := last( s_locations );

                ! Copy data from OpenAPI lib.
                p_lat( ep_loc ) := val( LocationIQ::_media_type_schema_15::lat(ep_callInstance, LocationIQ::_media_type_schema_15::i_media_type_schema_15) );
                p_lon( ep_loc ) := val( LocationIQ::_media_type_schema_15::lon(ep_callInstance, LocationIQ::_media_type_schema_15::i_media_type_schema_15) );
                sp_displayName( ep_loc ) := LocationIQ::_media_type_schema_15::display_name(ep_callInstance, LocationIQ::_media_type_schema_15::i_media_type_schema_15);

                ! Copy data from own administration.
                sp_givenName( ep_loc ) := sp_addressString(ep_addr);
            endfor ;
            block ! Cleanup
                LocationIQ::_media_type_schema_15::EmptyInstance( ep_callInstance );
                empty ep_addresses( ep_callInstance ); ! Maintaining own administration.
            endblock ;

        '400','401','403','404','429','500':
            raise error formatString("LocationIQ/Search(%s) failed. Code: %e, errNo: %i: %s",
                sp_addressString(ep_addr),
                LocationIQ::api::CallStatusCode(ep_callInstance), 
                LocationIQ::api::CallErrorCode(ep_callInstance), 
                LocationIQ::_error::error_(ep_callInstance) );

        default:
            raise error formatString("LocationIQ/Search(%s) failed. Code: %e, errNo: %i: %s",
                sp_addressString(ep_addr),
                LocationIQ::api::CallStatusCode(ep_callInstance), 
                LocationIQ::api::CallErrorCode(ep_callInstance), 
                "unknown error" );

    endswitch ;

Remarks:

*   Line 4: An array of locations found is returned. We copy only those, that have a display name.

*   Lines 6,7: Every entry gets a location number.

*   Lines 9-12: Copy the data for each location from the OpenAPI generated library.

*   Lines 14,15: Use own administration to fill in the short name of a location.

*   Lines 18,19: Cleanup. Not only information from the response schema, but also from our own administration.

*   Line 22: The status codes for which an error string is filled can be copied easily from the corresponding generated ``callback`` call.

*   Lines 23-28, 30-35: Handle an error by passing both information about the call 
    (``LocationIQ/Search(%s)`` filling in ``sp_addressString(ep_addr)``), 
    and information retrieved from the response.

Making multiple requests and respecting rate limits
------------------------------------------------------

Two calls
^^^^^^^^^^^^^ 

Let's start with making two calls. 
Our input data is in ``locationSearch::sp_addressString(locationSearch::i_addressNo)``. 

.. code-block:: aimms 
    :linenos:

    Procedure pr_testWithOpenAPI_2 {
        Body: {
            Empty s_locations ;
            for i_addressNo | ord( i_addressNo ) <= 2 do
                pr_makeRequest( i_addressNo );
            endfor ;
        }
    }

This interpretation of this for loop is that after executing ``pr_makeRequest( '1' )``, 
the interpreter will directly continue with ``pr_makeRequest( '2' )``.  
Handling the corresponding responses comes later, after the server finished processing the requests.

Note that handling the response of request 2 may come before handling the response for request 1.
This underlines the importance of parameters like ``ep_addressses``; it handles relating responses to their corresponding requests.

Going over the limit
^^^^^^^^^^^^^^^^^^^^^^^^^^ 

I usually develop with a free API key, so the rate limit is two calls per second. 
What happens when I go over the limit?

.. code-block:: aimms 
    :linenos:

    Procedure pr_testWithOpenAPI_3 {
        Body: {
            Empty s_locations ;
            for i_addressNo | ord( i_addressNo ) <= 3 do
                pr_makeRequest( i_addressNo );
            endfor ;
        }
    }

Well, ``LocationIQ`` reports a rate limit exceeded.  
My error message is as follows: ``LocationIQ/Search(Brandenburg Gate) failed. Code: 429, errNo: 0: Rate Limited Second.``

Accepting a rate limit
^^^^^^^^^^^^^^^^^^^^^^

Making a request takes almost no time, thus doing at most 2 calls per seconds 
implies that we need to wait a second after making two requests.

.. code-block:: aimms 
    :linenos:

    Procedure pr_testWithOpenAPI_4 {
        Body: {
            Empty s_locations ;
            for i_addressNo do
            
                pr_makeRequest( i_addressNo );
            
                if mod( ord( i_addressNo ), p_maxRateSecond ) = 0 then
                    pr_handleResponsesFor( 1[s] );
                endif ;

            endfor ;
        }
        Parameter p_maxRateSecond {
            InitialData: 2;
        }
    }
    
Here the utility procedure ``pr_handleResponsesFor`` is coded as follows:

.. code-block:: aimms 
    :linenos:

    Procedure pr_handleResponsesFor {
        Arguments: (p_seconds);
        Body: {
            sp_fmt := "%c%y-%m-%d %H:%M:%S:%T%TZ('UTC')" ;
            sp_startTime := CurrentToString( sp_fmt );
            p_secondsNoUnit := (p_seconds)[-];
            p_milliSeconds := 1000 * p_secondsNoUnit ;
            p_responsesHandled := dex::client::WaitForResponses( p_milliSeconds );
            while p_responsesHandled do
                sp_now := CurrentToString( sp_fmt );
                p_ticks := StringToMoment(
                    Format        :  sp_fmt, 
                    Unit          :  [tick], 
                    ReferenceDate :  sp_startTime, 
                    Timeslot      :  sp_now);
                if p_ticks > p_seconds then ! Time exceeded. AIMMS handles unit conversions.
                    break ;
                endif ;
                p_remainingSeconds := p_seconds - p_ticks ;
                p_secondsNoUnit :=  (p_remainingSeconds)[-];
                p_milliSeconds := 1000 * p_secondsNoUnit ;
                p_responsesHandled := dex::client::WaitForResponses( p_milliSeconds );
            endwhile ;
        }
        Comment: "Wait at least p_second seconds, and handle responses meanwhile.";
        DeclarationSection Argument_declarations {
            Parameter p_seconds {
                Unit: s;
                Property: Input;
            }
        }
        DeclarationSection Local_declarations {
            Parameter p_secondsNoUnit;
            Parameter p_milliSeconds;
            StringParameter sp_startTime;
            StringParameter sp_now;
            StringParameter sp_fmt;
            Parameter p_responsesHandled;
            Parameter p_ticks {
                Unit: tick;
            }
            Parameter p_remainingSeconds {
                Unit: s;
            }
        }
    }

.. spelling::
   github